Index: build/jam/HaikuImage
===================================================================
--- build/jam/HaikuImage	(revision 37465)
+++ build/jam/HaikuImage	(working copy)
@@ -46,8 +46,8 @@
 	mkfifo mkfs mkindex mktemp modifiers mount mount_nfs mountvolume mv
 	netcat netstat nl nohup notify nproc
 	od open
-	passwd paste patch pathchk pc ping play playfile playsound playwav pr prio
-	printenv printf profile ps ptx pwd
+	passwd paste patch pathchk pc ping ping6 play playfile playsound playwav
+	pr prio printenv printf profile ps ptx pwd
 	query quit
 	rc readlink ReadOnlyBootPrompt reindex release renice rlog rm rmattr
 	rmindex rmdir roster route
@@ -108,9 +108,9 @@
 
 SYSTEM_NETWORK_DEVICES = ethernet loopback ;
 SYSTEM_NETWORK_DATALINK_PROTOCOLS = ethernet_frame <module>arp loopback_frame
-	ipv4_datagram ;
+	ipv4_datagram ipv6_datagram ;
 #SYSTEM_NETWORK_PPP = ipcp modem pap pppoe ;
-SYSTEM_NETWORK_PROTOCOLS = ipv4 tcp udp icmp unix ;
+SYSTEM_NETWORK_PROTOCOLS = ipv4 ipv6 tcp udp icmp icmp6 unix ;
 
 SYSTEM_ADD_ONS_ACCELERANTS = $(X86_ONLY)radeon.accelerant
 	$(X86_ONLY)nvidia.accelerant $(X86_ONLY)matrox.accelerant
Index: src/tests/kits/net/Jamfile
===================================================================
--- src/tests/kits/net/Jamfile	(revision 37465)
+++ src/tests/kits/net/Jamfile	(working copy)
@@ -12,9 +12,6 @@
 SimpleTest tcp_server : tcp_server.c : $(TARGET_NETWORK_LIBS) ;
 SimpleTest tcp_client : tcp_client.c : $(TARGET_NETWORK_LIBS) ;
 
-SimpleTest ipv46_server : ipv46_server.cpp : $(TARGET_NETWORK_LIBS) ;
-SimpleTest ipv46_client : ipv46_client.cpp : $(TARGET_NETWORK_LIBS) ;
-
 SimpleTest getpeername : getpeername.cpp : $(TARGET_NETWORK_LIBS) ;
 
 SimpleTest tcp_connection_test : tcp_connection_test.cpp
@@ -27,6 +24,7 @@
 	: $(TARGET_NETWORK_LIBS) $(HAIKU_NETAPI_LIB) be $(TARGET_LIBSUPC++) ;
 
 SubInclude HAIKU_TOP src tests kits net DialUpPreflet ;
+SubInclude HAIKU_TOP src tests kits net ipv6 ;
 SubInclude HAIKU_TOP src tests kits net multicast ;
 SubInclude HAIKU_TOP src tests kits net netperf ;
 SubInclude HAIKU_TOP src tests kits net preflet ;
Index: src/tests/kits/net/ipv6/udp_server.cpp
===================================================================
--- src/tests/kits/net/ipv6/udp_server.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/udp_server.cpp	(revision 0)
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PORT = 40000;
+
+
+void
+recvLoop(int fd)
+{
+	for (;;) {
+		char buffer[1000];
+		sockaddr_storage address;
+		socklen_t socklen = sizeof(address);
+		memset(&address, 0, socklen);
+
+		int status = recvfrom(fd, buffer, sizeof(buffer) - 1, 0,
+			(sockaddr *) &address, &socklen);
+		if (status < 0) {
+			perror("recvfrom");
+			exit(-1);
+		}
+		if (status == 0) {
+			printf("received EOF!\n");
+			break;
+		} else {
+			buffer[status] = 0;
+			printf("received %d bytes: \"%s\"\n", status, buffer);
+		}
+	}
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketFamily = AF_INET;
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-4"))
+			socketFamily = AF_INET;
+		else if (!strcmp(argv[1], "-6"))
+			socketFamily = AF_INET6;
+	}
+
+	int fd = socket(socketFamily, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage localAddress;
+	memset(&localAddress, 0, sizeof(localAddress));
+	if (socketFamily == AF_INET) {
+		sockaddr_in *sa = (sockaddr_in *) &localAddress;
+		sa->sin_family = AF_INET;
+		sa->sin_port = htons(TEST_PORT);
+	} else {
+		sockaddr_in6 *sa = (sockaddr_in6 *) &localAddress;
+		sa->sin6_family = AF_INET6;
+		sa->sin6_port = htons(TEST_PORT);
+		// loopback
+		sa->sin6_addr.s6_addr[15] = 0x01;
+	}
+
+	if (bind(fd, (sockaddr *)&localAddress, socketFamily == AF_INET ?
+			sizeof(sockaddr_in) : sizeof(sockaddr_in6)) < 0) {
+		perror("bind");
+		return -1;
+	}
+
+	for (;;)
+		recvLoop(fd);
+}
Index: src/tests/kits/net/ipv6/raw_server.cpp
===================================================================
--- src/tests/kits/net/ipv6/raw_server.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/raw_server.cpp	(revision 0)
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PROTOCOL = 89;
+
+
+void
+recvLoop(int fd)
+{
+	for (;;) {
+		char buffer[1000];
+		sockaddr_storage address;
+		socklen_t socklen = sizeof(address);
+		memset(&address, 0, socklen);
+
+		int status = recvfrom(fd, buffer, sizeof(buffer) - 1, 0,
+			(sockaddr *) &address, &socklen);
+		if (status < 0) {
+			perror("recvfrom");
+			exit(-1);
+		}
+		if (status == 0) {
+			printf("received EOF!\n");
+			break;
+		} else {
+			char *p = buffer;
+			if (address.ss_family == AF_INET && status >= sizeof(struct ip))
+				p += sizeof(struct ip);
+			buffer[status] = 0;
+			printf("received %d bytes: \"%s\"\n", status, p);
+		}
+	}
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketFamily = AF_INET;
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-4"))
+			socketFamily = AF_INET;
+		else if (!strcmp(argv[1], "-6"))
+			socketFamily = AF_INET6;
+	}
+
+	int fd = socket(socketFamily, SOCK_RAW, TEST_PROTOCOL);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage localAddress;
+	memset(&localAddress, 0, sizeof(localAddress));
+	if (socketFamily == AF_INET) {
+		sockaddr_in *sa = (sockaddr_in *) &localAddress;
+		sa->sin_family = AF_INET;
+	} else {
+		sockaddr_in6 *sa = (sockaddr_in6 *) &localAddress;
+		sa->sin6_family = AF_INET6;
+	}
+
+	// TODO: is this even necessary?
+	if (bind(fd, (sockaddr *)&localAddress, socketFamily == AF_INET ?
+			sizeof(sockaddr_in) : sizeof(sockaddr_in6)) < 0) {
+		perror("bind");
+		return -1;
+	}
+
+	for (;;)
+		recvLoop(fd);
+}
Index: src/tests/kits/net/ipv6/tcp_udp_server.cpp
===================================================================
--- src/tests/kits/net/ipv6/tcp_udp_server.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/tcp_udp_server.cpp	(revision 0)
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PORT = 40000;
+
+
+void
+usage()
+{
+	printf("server [tcp|udp] [4|6] [local-address]\n");
+	exit(1);
+}
+
+
+void
+recvLoop(int fd)
+{
+	for (;;)	{
+		char buffer[1000];
+		int status = recv(fd, buffer, sizeof(buffer) - 1, 0);
+		if (status < 0) {
+			perror("recv");
+			exit(-1);
+		}
+		if (status == 0) {
+			printf("received EOF!\n");
+			break;
+		} else {
+			buffer[status] = 0;
+			printf("received %d bytes: \"%s\"\n", status, buffer);
+		}
+	}
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketType = SOCK_DGRAM;
+	int socketFamily = AF_INET;
+	if (argc > 1) {
+		if (!strcmp(argv[1], "tcp"))
+			socketType = SOCK_STREAM;
+		else if (!strcmp(argv[1], "udp"))
+			socketType = SOCK_DGRAM;
+		else
+			usage();
+	}
+	if (argc > 2) {
+		switch (atoi(argv[2])) {
+		case 4:
+			socketFamily = AF_INET;
+			break;
+		case 6:
+			socketFamily = AF_INET6;
+			break;
+		default:
+			usage();
+		}
+	}
+
+	sockaddr_storage localAddress;
+	memset(&localAddress, 0, sizeof(localAddress));
+	localAddress.ss_family = socketFamily;
+	((sockaddr_in *) &localAddress)->sin_port = htons(TEST_PORT);
+
+	if (argc > 3) {
+		do {
+			void *dstBuffer = &((sockaddr_in *) &localAddress)->sin_addr;
+			if (inet_pton(AF_INET, argv[3], dstBuffer) == 1) {
+				printf("using IPv4 local address\n");
+				localAddress.ss_family = AF_INET;
+				break;
+			}
+
+			dstBuffer = &((sockaddr_in6 *) &localAddress)->sin6_addr;
+			if (inet_pton(AF_INET6, argv[3], dstBuffer) == 1) {
+				printf("using IPv6 local address\n");
+				localAddress.ss_family = AF_INET6;
+				break;
+			}
+
+			usage();
+		} while (false);
+	}
+
+	int fd = socket(socketFamily, socketType, 0);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	if (bind(fd, (sockaddr *)&localAddress, localAddress.ss_family == AF_INET ?
+			sizeof(sockaddr_in) : sizeof(sockaddr_in6)) < 0) {
+		perror("bind");
+		return -1;
+	}
+
+	switch (socketType) {
+	case SOCK_DGRAM:
+		for (;;)
+			recvLoop(fd);
+		break;
+	case SOCK_STREAM:
+		if (listen(fd, 5) < 0) {
+			perror("listen");
+			return 1;
+		}
+		for (;;) {
+			int clientfd = accept(fd, NULL, 0);
+			if (clientfd < 0) {
+				perror("accept");
+				return 1;
+			}
+			printf("TCP server: got some client!\n");
+			if (fork() != 0) {
+				// parent code
+				close(clientfd);
+				continue;
+			}
+			// child code
+			close(fd);
+			recvLoop(clientfd);
+			exit(0);
+		}
+		break;
+	}
+}
Index: src/tests/kits/net/ipv6/multicast_sender.cpp
===================================================================
--- src/tests/kits/net/ipv6/multicast_sender.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/multicast_sender.cpp	(revision 0)
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PORT = 40000;
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketFamily = AF_INET;
+
+	int i = 1;
+	if (argc > i) {
+		if (!strcmp(argv[i], "-4")) {
+			i++;
+			socketFamily = AF_INET;
+		} else if (!strcmp(argv[i], "-6")) {
+			i++;
+			socketFamily = AF_INET6;
+		}
+	}
+	in_addr multicastSource;
+	multicastSource.s_addr = 0;
+	if (argc > i) {
+		if (!strcmp(argv[i], "-s")) {
+			++i;
+			if (inet_aton(argv[i], &multicastSource) == 0) {
+				fprintf(stderr, "IPv4 source address expected");
+				return -1;
+			}
+			++i;
+		}
+	}
+
+	int fd = socket(socketFamily, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage saddr;
+	memset(&saddr, 0, sizeof(saddr));
+	if (socketFamily == AF_INET) {
+		sockaddr_in *sa = (sockaddr_in *) &saddr;
+		sa->sin_family = AF_INET;
+		sa->sin_port = htons(TEST_PORT);
+		sa->sin_addr.s_addr = htonl(INADDR_ALLHOSTS_GROUP);
+	} else {
+		sockaddr_in6 *sa = (sockaddr_in6 *) &saddr;
+		sa->sin6_family = AF_INET6;
+		sa->sin6_port = htons(TEST_PORT);
+		// ff01::1 (all nodes multicast)
+		sa->sin6_addr.s6_addr[0] = 0xff;
+		sa->sin6_addr.s6_addr[1] = 0x01;
+		sa->sin6_addr.s6_addr[15] = 0x01;
+	}
+
+	if (multicastSource.s_addr) {
+		if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,
+				&multicastSource, sizeof(multicastSource)) < 0) {
+			perror("setsockopt IP_MULTICAST_IF");
+			return -1;
+		}
+	}
+
+	const char *buffer = "hello world";
+	unsigned length = strlen(buffer);
+	int status = sendto(fd, buffer, length, 0, (sockaddr *) &saddr,
+		socketFamily == AF_INET ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));
+	if (status < length) {
+		if (status < 0)
+			perror("sendto");
+		else if (status == 0)
+			printf("no data sent!\n");
+		else
+			printf("not all data sent!\n");
+	} else
+		printf("send(): success\n");
+
+	close(fd);
+	return 0;
+}
Index: src/tests/kits/net/ipv6/Jamfile
===================================================================
--- src/tests/kits/net/ipv6/Jamfile	(revision 0)
+++ src/tests/kits/net/ipv6/Jamfile	(revision 0)
@@ -0,0 +1,12 @@
+SubDir HAIKU_TOP src tests kits net ipv6 ;
+
+SimpleTest raw_server : raw_server.cpp : $(TARGET_NETWORK_LIBS) ;
+SimpleTest raw_client : raw_client.cpp : $(TARGET_NETWORK_LIBS) ;
+
+SimpleTest udp_server : udp_server.cpp : $(TARGET_NETWORK_LIBS) ;
+SimpleTest udp_client : udp_client.cpp : $(TARGET_NETWORK_LIBS) ;
+
+SimpleTest tcp_udp_server : tcp_udp_server.cpp : $(TARGET_NETWORK_LIBS) ;
+SimpleTest tcp_udp_client : tcp_udp_client.cpp : $(TARGET_NETWORK_LIBS) ;
+
+SimpleTest multicast_sender : multicast_sender.cpp : $(TARGET_NETWORK_LIBS) ;
Index: src/tests/kits/net/ipv6/udp_client.cpp
===================================================================
--- src/tests/kits/net/ipv6/udp_client.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/udp_client.cpp	(revision 0)
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PORT = 40000;
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketFamily = AF_INET;
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-4"))
+			socketFamily = AF_INET;
+		else if (!strcmp(argv[1], "-6"))
+			socketFamily = AF_INET6;
+	}
+
+	int fd = socket(socketFamily, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage saddr;
+	memset(&saddr, 0, sizeof(saddr));
+	if (socketFamily == AF_INET) {
+		sockaddr_in *sa = (sockaddr_in *) &saddr;
+		sa->sin_family = AF_INET;
+		sa->sin_port = htons(TEST_PORT);
+		sa->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+	} else {
+		sockaddr_in6 *sa = (sockaddr_in6 *) &saddr;
+		sa->sin6_family = AF_INET6;
+		sa->sin6_port = htons(TEST_PORT);
+		sa->sin6_addr.s6_addr[15] = 0x01; // loopback
+
+		// 2001::1
+		// sa->sin6_addr.s6_addr[0] = 0x20;
+		// sa->sin6_addr.s6_addr[1] = 0x01;
+		// sa->sin6_addr.s6_addr[15] = 0x01;
+	}
+
+	const char *buffer = "hello world";
+	unsigned length = strlen(buffer);
+	int status = sendto(fd, buffer, length, 0, (sockaddr *) &saddr,
+		socketFamily == AF_INET ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));
+	if (status < length) {
+		if (status < 0)
+			perror("sendto");
+		else if (status == 0)
+			printf("no data sent!\n");
+		else
+			printf("not all data sent!\n");
+	} else
+		printf("send(): success\n");
+
+	close(fd);
+	return 0;
+}
Index: src/tests/kits/net/ipv6/raw_client.cpp
===================================================================
--- src/tests/kits/net/ipv6/raw_client.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/raw_client.cpp	(revision 0)
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PROTOCOL = 89;
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketFamily = AF_INET;
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "-4"))
+			socketFamily = AF_INET;
+		else if (!strcmp(argv[1], "-6"))
+			socketFamily = AF_INET6;
+	}
+
+	int fd = socket(socketFamily, SOCK_RAW, TEST_PROTOCOL);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage saddr;
+	memset(&saddr, 0, sizeof(saddr));
+	if (socketFamily == AF_INET) {
+		sockaddr_in *sa = (sockaddr_in *) &saddr;
+		sa->sin_family = AF_INET;
+		sa->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+	} else {
+		sockaddr_in6 *sa = (sockaddr_in6 *) &saddr;
+		sa->sin6_family = AF_INET6;
+		sa->sin6_addr.s6_addr[15] = 0x01; // loopback
+	}
+
+	const char *buffer = "hello world";
+	unsigned length = strlen(buffer);
+	int status = sendto(fd, buffer, length, 0, (sockaddr *) &saddr,
+		socketFamily == AF_INET ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));
+	if (status < length) {
+		if (status < 0)
+			perror("sendto");
+		else if (status == 0)
+			printf("no data sent!\n");
+		else
+			printf("not all data sent!\n");
+	} else
+		printf("send(): success\n");
+
+	close(fd);
+	return 0;
+}
Index: src/tests/kits/net/ipv6/tcp_udp_client.cpp
===================================================================
--- src/tests/kits/net/ipv6/tcp_udp_client.cpp	(revision 0)
+++ src/tests/kits/net/ipv6/tcp_udp_client.cpp	(revision 0)
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2010, Atis Elsts, the.kfx@gmail.com
+ * Distributed under the terms of the MIT license.
+ */
+
+
+#include <unistd.h>
+#include <memory.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+
+const unsigned short TEST_PORT = 40000;
+
+
+void
+usage()
+{
+	printf("client [tcp|udp] [4|6] [4|6]\n");
+	exit(1);
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	int socketType = SOCK_DGRAM;
+	int socketFamily1 = AF_INET;
+	int socketFamily2 = AF_INET;
+
+	if (argc > 1) {
+		if (!strcmp(argv[1], "tcp"))
+			socketType = SOCK_STREAM;
+		else if (!strcmp(argv[1], "udp"))
+			socketType = SOCK_DGRAM;
+		else
+			usage();
+	}
+	if (argc > 2) {
+		switch (atoi(argv[2])) {
+		case 4:
+			socketFamily1 = AF_INET;
+			break;
+		case 6:
+			socketFamily1 = AF_INET6;
+			break;
+		default:
+			usage();
+		}
+	}
+	if (argc > 3) {
+		switch (atoi(argv[3])) {
+		case 4:
+			socketFamily2 = AF_INET;
+			break;
+		case 6:
+			socketFamily2 = AF_INET6;
+			break;
+		default:
+			usage();
+		}
+	}
+
+	int fd = socket(socketFamily1, socketType, 0);
+	if (fd < 0) {
+		perror("socket");
+		return -1;
+	}
+
+	sockaddr_storage saddr;
+	memset(&saddr, 0, sizeof(saddr));
+	saddr.ss_family = socketFamily2;
+	((sockaddr_in *) &saddr)->sin_port = htons(TEST_PORT);
+	if (connect(fd, (sockaddr *) &saddr, socketFamily2 == AF_INET ?
+			sizeof(sockaddr_in) : sizeof(sockaddr_in6)) < 0) {
+		perror("connect");
+		close(fd);
+		return -1;
+	}
+
+	const char *buffer = "hello world";
+	unsigned length = strlen(buffer);
+	int status = send(fd, buffer, length, 0);
+	if (status < length) {
+		if (status < 0)
+			perror("send");
+		else if (status == 0)
+			printf("no data sent!\n");
+		else
+			printf("not all data sent!\n");
+	} else
+		printf("send(): success\n");
+	close(fd);
+	return 0;
+}
Index: src/tests/kits/Jamfile
===================================================================
--- src/tests/kits/Jamfile	(revision 37465)
+++ src/tests/kits/Jamfile	(working copy)
@@ -12,4 +12,3 @@
 SubInclude HAIKU_TOP src tests kits support ;
 SubInclude HAIKU_TOP src tests kits translation ;
 SubInclude HAIKU_TOP src tests kits opengl ;
-
Index: src/add-ons/kernel/network/protocols/l2cap/l2cap_address.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/l2cap/l2cap_address.cpp	(revision 37465)
+++ src/add-ons/kernel/network/protocols/l2cap/l2cap_address.cpp	(working copy)
@@ -413,6 +413,7 @@
 		0,
 		NULL
 	},
+	true, // has_broadcast_address
 	l2cap_copy_address,
 	l2cap_mask_address,
 	l2cap_equal_addresses,
Index: src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp	(revision 37465)
+++ src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp	(working copy)
@@ -1595,6 +1595,7 @@
 	memcpy(buffer->destination, &destination, sizeof(sockaddr_in));
 
 	uint8 protocol = buffer->protocol = header.protocol;
+	buffer->hoplimit = header.time_to_live;
 
 	// remove any trailing/padding data
 	status_t status = gBufferModule->trim(buffer, packetLength);
Index: src/add-ons/kernel/network/protocols/ipv4/ipv4_address.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv4/ipv4_address.cpp	(revision 37465)
+++ src/add-ons/kernel/network/protocols/ipv4/ipv4_address.cpp	(working copy)
@@ -489,14 +489,15 @@
 	return B_OK;
 }
 
+
 static void
-ipv4_get_loopback_address(sockaddr *result)
+ipv4_get_loopback_address(sockaddr *_address)
 {
-	sockaddr_in *resultIn = (sockaddr_in *)result;
-	memset(resultIn, 0, sizeof(resultIn));
-	resultIn->sin_len = sizeof(sockaddr_in);
-	resultIn->sin_family = AF_INET;
-	resultIn->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+	sockaddr_in *address = (sockaddr_in *)_address;
+	memset(address, 0, sizeof(sockaddr_in));
+	address->sin_len = sizeof(sockaddr_in);
+	address->sin_family = AF_INET;
+	address->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 }
 
 
@@ -506,6 +507,7 @@
 		0,
 		NULL
 	},
+	true, // has_broadcast_address
 	ipv4_copy_address,
 	ipv4_mask_address,
 	ipv4_equal_addresses,
Index: src/add-ons/kernel/network/protocols/unix/UnixAddress.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/unix/UnixAddress.cpp	(revision 37465)
+++ src/add-ons/kernel/network/protocols/unix/UnixAddress.cpp	(working copy)
@@ -290,7 +290,7 @@
 		0,
 		NULL
 	},
-
+	true, // has_broadcast_address
 	unix_copy_address,
 	unix_mask_address,
 	unix_equal_addresses,
Index: src/add-ons/kernel/network/protocols/ipv6/ipv6_address.h
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/ipv6_address.h	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/ipv6_address.h	(revision 0)
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef IPV6_ADDRESS_H
+#define IPV6_ADDRESS_H
+
+#include <netinet6/in6.h>
+#include <string.h>
+
+
+extern struct net_address_module_info gIPv6AddressModule;
+
+
+#define NET_IPV6_MODULE_NAME "network/protocols/ipv6/v1"
+
+
+static inline bool
+operator==(const in6_addr &a1, const in6_addr &a2)
+{
+	// TODO: optimize
+	return !memcmp(&a1, &a2, sizeof(in6_addr));
+}
+
+
+#endif	// IPV6_ADDRESS_H
Index: src/add-ons/kernel/network/protocols/ipv6/ipv6.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/ipv6.cpp	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/ipv6.cpp	(revision 0)
@@ -0,0 +1,1221 @@
+
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Based on code from ipv4.cpp
+ */
+
+
+#include "ipv6_address.h"
+#include "ipv6_utils.h"
+#include "multicast.h"
+#include "../../stack/domains.h"
+
+#include <net_datalink.h>
+#include <net_datalink_protocol.h>
+#include <net_device.h>
+#include <net_protocol.h>
+#include <net_stack.h>
+#include <NetBufferUtilities.h>
+#include <ProtocolUtilities.h>
+
+#include <ByteOrder.h>
+#include <KernelExport.h>
+#include <util/AutoLock.h>
+#include <util/list.h>
+#include <util/DoublyLinkedList.h>
+#include <util/MultiHashTable.h>
+
+#include <netinet6/in6.h>
+#include <netinet/ip6.h>
+#include <netinet/icmp6.h>
+#include <new>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <utility>
+
+
+#define TRACE_IPV6
+#ifdef TRACE_IPV6
+#	define TRACE(format, args...) \
+		dprintf("IPv6 [%llu] " format "\n", system_time() , ##args)
+#	define TRACE_SK(protocol, format, args...) \
+		dprintf("IPv6 [%llu] %p " format "\n", system_time(), \
+			protocol , ##args)
+#else
+#	define TRACE(args...)		do { } while (0)
+#	define TRACE_SK(args...)	do { } while (0)
+#endif
+
+
+struct IPv6Header {
+	struct ip6_hdr h;
+
+	uint8 ProtocolVersion() const { return h.ip6_vfc & IPV6_VERSION_MASK; }
+	uint8 ServiceType() const { return ntohl(h.ip6_flow) >> 20;}
+ 	uint16 PayloadLength() const { return ntohs(h.ip6_plen); }
+	const in6_addr& Dst() const { return h.ip6_dst; }
+	const in6_addr& Src() const { return h.ip6_src; }
+	uint16 GetTransportHeaderOffset(net_buffer* buffer) const;
+};
+
+class RawSocket
+	: public DoublyLinkedListLinkImpl<RawSocket>, public DatagramSocket<> {
+public:
+							RawSocket(net_socket* socket);
+};
+
+typedef DoublyLinkedList<RawSocket> RawSocketList;
+
+
+typedef MulticastGroupInterface<IPv6Multicast> IPv6GroupInterface;
+typedef MulticastFilter<IPv6Multicast> IPv6MulticastFilter;
+
+struct MulticastStateHash {
+	typedef std::pair<const in6_addr*, uint32> KeyType;
+	typedef IPv6GroupInterface ValueType;
+
+	size_t HashKey(const KeyType &key) const;
+	size_t Hash(ValueType* value) const
+		{ return HashKey(std::make_pair(&value->Address(),
+			value->Interface()->index)); }
+	bool Compare(const KeyType &key, ValueType* value) const
+		{ return value->Interface()->index == key.second
+			&& value->Address() == *key.first; }
+	bool CompareValues(ValueType* value1, ValueType* value2) const
+		{ return value1->Interface()->index == value2->Interface()->index
+			&& value1->Address() == value2->Address(); }
+	ValueType*& GetLink(ValueType* value) const { return value->HashLink(); }
+};
+
+
+struct ipv6_protocol : net_protocol {
+	ipv6_protocol()
+		:
+		multicast_filter(this)
+	{
+	}
+
+	RawSocket	*raw;
+	uint8		service_type;
+	uint8		time_to_live;
+	uint8		multicast_time_to_live;
+	uint8		receive_hoplimit;
+	uint8		receive_pktinfo;
+	struct sockaddr* interface_address; // for IPV6_MULTICAST_IF
+
+	IPv6MulticastFilter multicast_filter;
+};
+
+
+static const int kDefaultTTL = 254;
+static const int kDefaultMulticastTTL = 1;
+
+
+extern net_protocol_module_info gIPv6Module;
+	// we need this in ipv6_std_ops() for registering the AF_INET domain
+
+net_stack_module_info* gStackModule;
+net_buffer_module_info* gBufferModule;
+
+static struct net_domain* sDomain;
+static net_datalink_module_info* sDatalinkModule;
+static net_socket_module_info* sSocketModule;
+static RawSocketList sRawSockets;
+static mutex sRawSocketsLock;
+static mutex sMulticastGroupsLock;
+
+typedef MultiHashTable<MulticastStateHash> MulticastState;
+static MulticastState* sMulticastState;
+
+static net_protocol_module_info* sReceivingProtocol[256];
+static mutex sReceivingProtocolLock;
+
+
+uint16
+IPv6Header::GetTransportHeaderOffset(net_buffer* buffer) const
+{
+	uint16 offset = sizeof(struct ip6_hdr);
+	uint8 next = h.ip6_nxt;
+
+	// these are the extension headers that might be supported one day
+	while (next == IPPROTO_HOPOPTS
+		|| next == IPPROTO_ROUTING
+		|| next == IPPROTO_FRAGMENT
+		|| next == IPPROTO_ESP
+		|| next == IPPROTO_AH
+		|| next == IPPROTO_DSTOPTS) {
+		struct ip6_ext extensionHeader;
+		status_t status = gBufferModule->read(buffer, offset,
+			&extensionHeader, sizeof(ip6_ext));
+		if (status != B_OK)
+			break;
+
+		next = extensionHeader.ip6e_nxt;
+		offset += extensionHeader.ip6e_len;
+	}
+
+	buffer->protocol = next;
+	return offset;
+}
+
+
+RawSocket::RawSocket(net_socket* socket)
+	:
+	DatagramSocket<>("ipv6 raw socket", socket)
+{
+}
+
+
+size_t
+MulticastStateHash::HashKey(const KeyType &key) const
+{
+	size_t result = 0;
+	result = jenkins_hashword((const uint32*)&key.first, 
+		sizeof(in6_addr) / sizeof(uint32), result);
+	result = jenkins_hashword(&key.second, 1, result);
+	return result;
+}
+
+
+//	#pragma mark -
+
+
+static inline void
+dump_ipv6_header(IPv6Header &header)
+{
+#ifdef TRACE_IPV6
+	char addrbuf[INET6_ADDRSTRLEN];
+	dprintf("  version: %d\n", header.ProtocolVersion() >> 4);
+	dprintf("  service_type: %d\n", header.ServiceType());
+	dprintf("  payload_length: %d\n", header.PayloadLength());
+	dprintf("  next_header: %d\n", header.h.ip6_nxt);
+	dprintf("  hop_limit: %d\n", header.h.ip6_hops);
+	dprintf("  source: %s\n", ip6_sprintf(&header.h.ip6_src, addrbuf));
+	dprintf("  destination: %s\n", ip6_sprintf(&header.h.ip6_dst, addrbuf));
+#endif
+}
+
+
+static status_t
+deliver_multicast(net_protocol_module_info* module, net_buffer* buffer,
+ 	bool deliverToRaw, net_interface *interface)
+{
+	sockaddr_in6* multicastAddr = (sockaddr_in6*)buffer->destination;
+
+	MulticastState::ValueIterator it = sMulticastState->Lookup(std::make_pair(
+		&multicastAddr->sin6_addr, interface->index));
+
+	while (it.HasNext()) {
+		IPv6GroupInterface* state = it.Next();
+		ipv6_protocol* ipproto = state->Parent()->Socket();
+
+		if (deliverToRaw && ipproto->raw == NULL)
+			continue;
+
+		if (state->FilterAccepts(buffer)) {
+			// TODO: do as in IPv4 code
+			module->deliver_data(ipproto, buffer);
+		}
+	}
+
+	return B_OK;
+}
+
+
+static status_t
+deliver_multicast(net_protocol_module_info* module, net_buffer* buffer,
+ 	bool deliverToRaw)
+{
+	if (module->deliver_data == NULL)
+		return B_OK;
+
+	MutexLocker _(sMulticastGroupsLock);
+
+	status_t status = B_OK;
+	if (buffer->interface) {
+		status = deliver_multicast(module, buffer, deliverToRaw,
+			buffer->interface);
+	} else {
+		// REVIEWME: does this look ok?
+		net_domain_private* domain = (net_domain_private*)sDomain;
+		RecursiveLocker locker(domain->lock);
+
+		net_interface* interface = NULL;
+		while (true) {
+			interface = (net_interface*)list_get_next_item(
+				&domain->interfaces, interface);
+			if (interface == NULL)
+				break;
+
+			status = deliver_multicast(module, buffer, deliverToRaw, interface);
+			if (status < B_OK)
+				break;
+		}
+	}
+	return status;
+}
+
+
+static void
+raw_receive_data(net_buffer* buffer)
+{
+	MutexLocker locker(sRawSocketsLock);
+
+	if (sRawSockets.IsEmpty())
+		return;
+
+	TRACE("RawReceiveData(%i)", buffer->protocol);
+
+	if ((buffer->flags & MSG_MCAST) != 0) {
+		deliver_multicast(&gIPv6Module, buffer, true);
+	} else {
+		RawSocketList::Iterator iterator = sRawSockets.GetIterator();
+
+		while (iterator.HasNext()) {
+			RawSocket* raw = iterator.Next();
+
+			if (raw->Socket()->protocol == buffer->protocol)
+				raw->SocketEnqueue(buffer);
+		}
+	}
+}
+
+
+static inline sockaddr*
+fill_sockaddr_in6(sockaddr_in6* target, const in6_addr &address)
+{
+	target->sin6_family = AF_INET6;
+	target->sin6_len = sizeof(sockaddr_in6);
+	target->sin6_port = 0;
+	target->sin6_flowinfo = 0;
+	memcpy(target->sin6_addr.s6_addr, address.s6_addr, sizeof(in6_addr));
+	target->sin6_scope_id = 0;
+	return (sockaddr*)target;
+}
+
+
+status_t
+IPv6Multicast::JoinGroup(IPv6GroupInterface* state)
+{
+	MutexLocker _(sMulticastGroupsLock);
+
+	sockaddr_in6 groupAddr;
+	net_interface* interface = state->Interface();
+
+	status_t status = interface->first_info->join_multicast(
+		interface->first_protocol,
+		fill_sockaddr_in6(&groupAddr, state->Address()));
+	if (status != B_OK)
+		return status;
+
+	sMulticastState->Insert(state);
+	return B_OK;
+}
+
+
+status_t
+IPv6Multicast::LeaveGroup(IPv6GroupInterface* state)
+{
+	MutexLocker _(sMulticastGroupsLock);
+
+	sMulticastState->Remove(state);
+
+	sockaddr_in6 groupAddr;
+	net_interface* interface = state->Interface();
+
+	return interface->first_protocol->module->join_multicast(
+		interface->first_protocol,
+		fill_sockaddr_in6(&groupAddr, state->Address()));
+}
+
+
+static net_protocol_module_info*
+receiving_protocol(uint8 protocol)
+{
+	net_protocol_module_info* module = sReceivingProtocol[protocol];
+	if (module != NULL)
+		return module;
+
+	MutexLocker locker(sReceivingProtocolLock);
+
+	module = sReceivingProtocol[protocol];
+	if (module != NULL)
+		return module;
+
+	if (gStackModule->get_domain_receiving_protocol(sDomain, protocol,
+			&module) == B_OK)
+		sReceivingProtocol[protocol] = module;
+
+	return module;
+}
+
+
+static status_t
+ipv6_delta_group(IPv6GroupInterface* group, int option,
+	net_interface* interface, const in6_addr* sourceAddr)
+{
+	switch (option) {
+		case IPV6_JOIN_GROUP:
+			return group->Add();
+		case IPV6_LEAVE_GROUP:
+			return group->Drop();
+	}
+
+	return B_ERROR;
+}
+
+
+static status_t
+ipv6_delta_membership(ipv6_protocol* protocol, int option,
+	net_interface* interface, const in6_addr* groupAddr,
+	const in6_addr* sourceAddr)
+{
+	IPv6MulticastFilter &filter = protocol->multicast_filter;
+	IPv6GroupInterface* state = NULL;
+	status_t status = B_OK;
+
+	switch (option) {
+		// TODO: support more options
+		case IPV6_JOIN_GROUP:
+			status = filter.GetState(*groupAddr, interface, state, true);
+			break;
+
+		case IPV6_LEAVE_GROUP:
+			filter.GetState(*groupAddr, interface, state, false);
+			if (state == NULL)
+				return EADDRNOTAVAIL;
+			break;
+	}
+
+	if (status != B_OK)
+		return status;
+
+	status = ipv6_delta_group(state, option, interface, sourceAddr);
+	filter.ReturnState(state);
+	return status;
+}
+
+
+static status_t
+ipv6_delta_membership(ipv6_protocol* protocol, int option,
+	uint32 interfaceIndex, in6_addr* groupAddr, in6_addr* sourceAddr)
+{
+	net_interface* interface;
+
+	// TODO: can the interface be unspecified?
+	interface = sDatalinkModule->get_interface(sDomain, interfaceIndex);
+
+	if (interface == NULL)
+		return ENODEV;
+
+	return ipv6_delta_membership(protocol, option, interface,
+		groupAddr, sourceAddr);
+}
+
+
+static status_t
+get_int_option(void* target, size_t length, int value)
+{
+	if (length != sizeof(int))
+		return B_BAD_VALUE;
+
+	return user_memcpy(target, &value, sizeof(int));
+}
+
+
+template<typename Type> static status_t
+set_int_option(Type &target, const void* _value, size_t length)
+{
+	int value;
+
+	if (length != sizeof(int))
+		return B_BAD_VALUE;
+
+	if (user_memcpy(&value, _value, sizeof(int)) != B_OK)
+		return B_BAD_ADDRESS;
+
+	target = value;
+	return B_OK;
+}
+
+
+//	#pragma mark -
+
+
+net_protocol*
+ipv6_init_protocol(net_socket* socket)
+{
+	ipv6_protocol* protocol = new (std::nothrow) ipv6_protocol();
+	if (protocol == NULL)
+		return NULL;
+
+	protocol->raw = NULL;
+	protocol->service_type = 0;
+	protocol->time_to_live = kDefaultTTL;
+	protocol->multicast_time_to_live = kDefaultMulticastTTL;
+	protocol->receive_hoplimit = 0;
+	protocol->receive_pktinfo = 0;
+	protocol->interface_address = NULL;
+	return protocol;
+}
+
+
+status_t
+ipv6_uninit_protocol(net_protocol* _protocol)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+	delete protocol->raw;
+	delete protocol->interface_address;
+	delete protocol;
+	return B_OK;
+}
+
+
+/*!	Since open() is only called on the top level protocol, when we get here
+	it means we are on a SOCK_RAW socket.
+*/
+status_t
+ipv6_open(net_protocol* _protocol)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+	RawSocket* raw = new (std::nothrow) RawSocket(protocol->socket);
+	if (raw == NULL)
+		return B_NO_MEMORY;
+
+	status_t status = raw->InitCheck();
+	if (status != B_OK) {
+		delete raw;
+		return status;
+	}
+
+	TRACE_SK(protocol, "Open()");
+
+	protocol->raw = raw;
+
+	MutexLocker locker(sRawSocketsLock);
+	sRawSockets.Add(raw);
+	return B_OK;
+}
+
+
+status_t
+ipv6_close(net_protocol* _protocol)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+	RawSocket* raw = protocol->raw;
+	if (raw == NULL)
+		return B_ERROR;
+
+	TRACE_SK(protocol, "Close()");
+
+	MutexLocker locker(sRawSocketsLock);
+	sRawSockets.Remove(raw);
+	delete raw;
+	protocol->raw = NULL;
+
+	return B_OK;
+}
+
+
+status_t
+ipv6_free(net_protocol* protocol)
+{
+	return B_OK;
+}
+
+
+status_t
+ipv6_connect(net_protocol* protocol, const struct sockaddr* address)
+{
+	return B_ERROR;
+}
+
+
+status_t
+ipv6_accept(net_protocol* protocol, struct net_socket** _acceptedSocket)
+{
+	return EOPNOTSUPP;
+}
+
+
+status_t
+ipv6_control(net_protocol* _protocol, int level, int option, void* value,
+	size_t* _length)
+{
+	if ((level & LEVEL_MASK) != IPPROTO_IPV6)
+		return sDatalinkModule->control(sDomain, option, value, _length);
+
+	return B_BAD_VALUE;
+}
+
+
+status_t
+ipv6_getsockopt(net_protocol* _protocol, int level, int option, void* value,
+	int* _length)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+ 	if (level == IPPROTO_IPV6) {
+		// TODO: support more of these options
+
+		if (option == IPV6_MULTICAST_HOPS) {
+			return get_int_option(value, *_length,
+				protocol->multicast_time_to_live);
+		}
+		if (option == IPV6_MULTICAST_LOOP)
+			return EOPNOTSUPP;
+		if (option == IPV6_UNICAST_HOPS)
+			return get_int_option(value, *_length, protocol->time_to_live);
+		if (option == IPV6_V6ONLY)
+			return EOPNOTSUPP;
+		if (option == IPV6_RECVPKTINFO)
+			return get_int_option(value, *_length, protocol->receive_pktinfo);
+		if (option == IPV6_RECVHOPLIMIT)
+			return get_int_option(value, *_length, protocol->receive_hoplimit);
+		if (option == IPV6_JOIN_GROUP
+			|| option == IPV6_LEAVE_GROUP)
+			return EOPNOTSUPP;
+
+		dprintf("IPv6::getsockopt(): get unknown option: %d\n", option);
+		return ENOPROTOOPT;
+	}
+
+	return sSocketModule->get_option(protocol->socket, level, option, value,
+		_length);
+}
+
+
+status_t
+ipv6_setsockopt(net_protocol* _protocol, int level, int option,
+	const void* value, int length)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+ 	if (level == IPPROTO_IPV6) {
+		// TODO: support more of these options
+
+		if (option == IPV6_MULTICAST_IF) {
+			if (length != sizeof(struct in6_addr))
+				return B_BAD_VALUE;
+
+			struct sockaddr_in6* address = new (std::nothrow) sockaddr_in6;
+			if (address == NULL)
+				return B_NO_MEMORY;
+
+			if (user_memcpy(&address->sin6_addr, value, sizeof(in6_addr))
+					!= B_OK) {
+				delete address;
+				return B_BAD_ADDRESS;
+			}
+
+			// Using the unspecifed address to remove the previous setting.
+			if (IN6_IS_ADDR_UNSPECIFIED(&address->sin6_addr)) {
+				delete address;
+				delete protocol->interface_address;
+				protocol->interface_address = NULL;
+				return B_OK;
+			}
+
+			struct net_interface* interface
+				= sDatalinkModule->get_interface_with_address(sDomain,
+					(struct sockaddr*)address);
+			if (interface == NULL) {
+				delete address;
+				return EADDRNOTAVAIL;
+			}
+
+			delete protocol->interface_address;
+			protocol->interface_address = (struct sockaddr*)address;
+			return B_OK;
+		}
+		if (option == IPV6_MULTICAST_HOPS) {
+			return set_int_option(protocol->multicast_time_to_live,
+				value, length);
+		}
+		if (option == IPV6_MULTICAST_LOOP)
+			return EOPNOTSUPP;
+		if (option == IPV6_UNICAST_HOPS)
+			return set_int_option(protocol->time_to_live, value, length);
+		if (option == IPV6_V6ONLY)
+			return EOPNOTSUPP;
+		if (option == IPV6_RECVPKTINFO)
+			return set_int_option(protocol->receive_pktinfo, value, length);
+		if (option == IPV6_RECVHOPLIMIT)
+			return set_int_option(protocol->receive_hoplimit, value, length);
+		if (option == IPV6_JOIN_GROUP || option == IPV6_LEAVE_GROUP) {
+			ipv6_mreq mreq;
+			if (length != sizeof(ipv6_mreq))
+				return B_BAD_VALUE;
+			if (user_memcpy(&mreq, value, sizeof(ipv6_mreq)) != B_OK)
+				return B_BAD_ADDRESS;
+
+			return ipv6_delta_membership(protocol, option, mreq.ipv6mr_interface,
+				&mreq.ipv6mr_multiaddr, NULL);
+		}
+
+		dprintf("IPv6::setsockopt(): set unknown option: %d\n", option);
+		return ENOPROTOOPT;
+	}
+
+	return sSocketModule->set_option(protocol->socket, level, option,
+		value, length);
+}
+
+
+status_t
+ipv6_bind(net_protocol* protocol, const sockaddr* _address)
+{
+	if (_address->sa_family != AF_INET6)
+		return EAFNOSUPPORT;
+
+	const sockaddr_in6* address = (const sockaddr_in6*)_address;
+
+	// only INADDR_ANY and addresses of local interfaces are accepted:
+	if (IN6_IS_ADDR_UNSPECIFIED(&address->sin6_addr)
+		|| IN6_IS_ADDR_MULTICAST(&address->sin6_addr)
+ 		|| sDatalinkModule->is_local_address(sDomain, _address, NULL, NULL)) {
+		memcpy(&protocol->socket->address, address, sizeof(sockaddr_in6));
+		protocol->socket->address.ss_len = sizeof(sockaddr_in6);
+			// explicitly set length, as our callers can't be trusted to
+			// always provide the correct length!
+		return B_OK;
+	}
+
+	return B_ERROR;
+		// address is unknown on this host
+}
+
+
+status_t
+ipv6_unbind(net_protocol* protocol, struct sockaddr* address)
+{
+	// nothing to do here
+	return B_OK;
+}
+
+
+status_t
+ipv6_listen(net_protocol* protocol, int count)
+{
+	return EOPNOTSUPP;
+}
+
+
+status_t
+ipv6_shutdown(net_protocol* protocol, int direction)
+{
+	return EOPNOTSUPP;
+}
+
+
+static uint8
+ip6_select_hoplimit(net_protocol* _protocol, net_buffer* buffer)
+{
+	// TODO: the precedence should be as follows:
+	// 1. Hoplimit value specified via ioctl.
+	// 2. (If the outgoing interface is detected) the current
+	//     hop limit of the interface specified by router advertisement.
+	// 3. The system default hoplimit.
+	
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+	const bool isMulticast = buffer->flags & MSG_MCAST;
+
+	if (protocol) {
+		return isMulticast ? protocol->multicast_time_to_live
+			: protocol->time_to_live;
+ 	}
+	return isMulticast ? kDefaultMulticastTTL : kDefaultTTL;
+}
+
+
+status_t
+ipv6_send_routed_data(net_protocol* _protocol, struct net_route* route,
+	net_buffer* buffer)
+{
+	if (route == NULL)
+		return B_BAD_VALUE;
+
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+	net_interface* interface = route->interface;
+	uint8 protocolNumber;
+	if (protocol != NULL && protocol->socket != NULL)
+		protocolNumber = protocol->socket->protocol;
+	else
+		protocolNumber = buffer->protocol;
+
+	TRACE_SK(protocol, "SendRoutedData(%p, %p [%ld bytes])", route, buffer,
+		buffer->size);
+
+	sockaddr_in6& source = *(sockaddr_in6*)buffer->source;
+	sockaddr_in6& destination = *(sockaddr_in6*)buffer->destination;
+
+	buffer->flags &= ~(MSG_BCAST | MSG_MCAST);
+
+	if (IN6_IS_ADDR_UNSPECIFIED(&destination.sin6_addr))
+		return EDESTADDRREQ;
+
+	if (IN6_IS_ADDR_MULTICAST(&destination.sin6_addr))
+ 		buffer->flags |= MSG_MCAST;
+
+	uint16 dataLength = buffer->size;
+
+	// Add IPv6 header
+
+	NetBufferPrepend<ip6_hdr> header(buffer);
+	if (header.Status() != B_OK)
+		return header.Status();
+
+	if (buffer->size > 0xffff)
+		return EMSGSIZE;
+
+	uint32 flowinfo = 0;
+		// TODO: fill in the flow id from somewhere
+	if (protocol) {
+		// fill in traffic class
+		flowinfo |= htonl(protocol->service_type << 20);
+	}
+	// set lower 28 bits
+	header->ip6_flow = htonl(flowinfo) & IPV6_FLOWINFO_MASK;
+	// set upper 4 bits
+	header->ip6_vfc |= IPV6_VERSION;
+	header->ip6_plen = htons(dataLength);
+	header->ip6_nxt = protocolNumber;
+	header->ip6_hlim = ip6_select_hoplimit(protocol, buffer);
+	memcpy(&header->ip6_src, &source.sin6_addr, sizeof(in6_addr));
+	memcpy(&header->ip6_dst, &destination.sin6_addr, sizeof(in6_addr));
+
+	header.Sync();
+
+	// write the checksum for ICMPv6 sockets
+	if (protocolNumber == IPPROTO_ICMPV6
+		&& dataLength >= sizeof(struct icmp6_hdr)) {
+		NetBufferField<uint16, 
+			sizeof(ip6_hdr) + offsetof(icmp6_hdr, icmp6_cksum)>
+			icmpChecksum(buffer);
+		// first make sure the existing checksum is zero
+		*icmpChecksum = 0;
+		icmpChecksum.Sync();
+
+		uint16 checksum = gBufferModule->checksum(buffer, sizeof(ip6_hdr),
+			buffer->size - sizeof(ip6_hdr), false);
+		checksum = ipv6_checksum(&header->ip6_src,
+			&header->ip6_dst, dataLength, protocolNumber,
+			checksum);
+		*icmpChecksum = checksum;
+	}
+
+	char addrbuf[INET6_ADDRSTRLEN];
+	TRACE_SK(protocol, "  SendRoutedData(): destination: %s",
+		ip6_sprintf(&destination.sin6_addr, addrbuf));
+
+	uint32 mtu = route->mtu ? route->mtu : interface->mtu;
+	if (buffer->size > mtu) {
+		// we need to fragment the packet
+		return EMSGSIZE; // TODO
+		//return send_fragments(protocol, route, buffer, mtu);
+	}
+
+	return sDatalinkModule->send_data(route, buffer);
+}
+
+
+status_t
+ipv6_send_data(net_protocol* _protocol, net_buffer* buffer)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+	TRACE_SK(protocol, "SendData(%p [%ld bytes])", buffer, buffer->size);
+
+	sockaddr_in6* destination = (sockaddr_in6*)buffer->destination;
+
+	// handle IPV6_MULTICAST_IF
+	if (IN6_IS_ADDR_MULTICAST(&destination->sin6_addr)
+			&& protocol->interface_address != NULL) {
+		net_interface* interface
+			= sDatalinkModule->get_interface_with_address(sDomain,
+				protocol->interface_address);
+		if (interface == NULL || (interface->flags & IFF_UP) == 0)
+			return EADDRNOTAVAIL;
+
+		buffer->interface = interface;
+
+		net_route* route = sDatalinkModule->get_route(sDomain,
+			interface->address);
+		if (route == NULL)
+			return ENETUNREACH;
+
+		return sDatalinkModule->send_data(route, buffer);
+	}
+
+	return sDatalinkModule->send_datagram(protocol, sDomain, buffer);
+}
+
+
+ssize_t
+ipv6_send_avail(net_protocol* protocol)
+{
+	return B_ERROR;
+}
+
+
+status_t
+ipv6_read_data(net_protocol* _protocol, size_t numBytes, uint32 flags,
+	net_buffer** _buffer)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+	RawSocket* raw = protocol->raw;
+	if (raw == NULL)
+		return B_ERROR;
+
+	TRACE_SK(protocol, "ReadData(%lu, 0x%lx)", numBytes, flags);
+
+	return raw->SocketDequeue(flags, _buffer);
+}
+
+
+ssize_t
+ipv6_read_avail(net_protocol* _protocol)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+	RawSocket* raw = protocol->raw;
+	if (raw == NULL)
+		return B_ERROR;
+
+	return raw->AvailableData();
+}
+
+
+struct net_domain*
+ipv6_get_domain(net_protocol* protocol)
+{
+	return sDomain;
+}
+
+
+size_t
+ipv6_get_mtu(net_protocol* protocol, const struct sockaddr* address)
+{
+	net_route* route = sDatalinkModule->get_route(sDomain, address);
+	if (route == NULL)
+		return 0;
+
+	size_t mtu;
+	if (route->mtu != 0)
+		mtu = route->mtu;
+	else
+		mtu = route->interface->mtu;
+
+	sDatalinkModule->put_route(sDomain, route);
+	// TODO: what about extension headers?
+	// this function probably shoud be changed in calling places, not here
+	return mtu - sizeof(ip6_hdr);
+}
+
+
+status_t
+ipv6_receive_data(net_buffer* buffer)
+{
+	TRACE("ReceiveData(%p [%ld bytes])", buffer, buffer->size);
+
+	NetBufferHeaderReader<IPv6Header> bufferHeader(buffer);
+	if (bufferHeader.Status() != B_OK)
+		return bufferHeader.Status();
+
+	IPv6Header &header = bufferHeader.Data();
+	// dump_ipv6_header(header);
+
+	if (header.ProtocolVersion() != IPV6_VERSION)
+		return B_BAD_TYPE;
+
+	uint16 packetLength = header.PayloadLength() + sizeof(ip6_hdr);
+	if (packetLength > buffer->size)
+		return B_BAD_DATA;
+
+	// lower layers notion of Broadcast or Multicast have no relevance to us
+	buffer->flags &= ~(MSG_BCAST | MSG_MCAST);
+
+	sockaddr_in6 destination;
+	fill_sockaddr_in6(&destination, header.Dst());
+
+	if (IN6_IS_ADDR_MULTICAST(&destination.sin6_addr)) {
+		buffer->flags |= MSG_MCAST;
+	} else {
+		// test if the packet is really for us
+		if (!sDatalinkModule->is_local_address(sDomain, (sockaddr*)&destination,
+				&buffer->interface, NULL)
+			&& !sDatalinkModule->is_local_link_address(sDomain, true,
+				buffer->destination, &buffer->interface)) {
+			char srcbuf[INET6_ADDRSTRLEN];
+			char dstbuf[INET6_ADDRSTRLEN];
+			TRACE("  ReceiveData(): packet was not for us %s -> %s",
+				ip6_sprintf(&header.Src(), srcbuf),
+				ip6_sprintf(&header.Dst(), dstbuf));
+			return B_ERROR;
+		}
+	}
+
+	// set net_buffer's source/destination address
+	fill_sockaddr_in6((struct sockaddr_in6*)buffer->source, header.Src());
+	memcpy(buffer->destination, &destination, sizeof(sockaddr_in6));
+
+	// get the transport protocol and transport header offset
+	uint16 transportHeaderOffset = header.GetTransportHeaderOffset(buffer);
+	uint8 protocol = buffer->protocol;
+
+	buffer->hoplimit = header.h.ip6_hlim;
+
+	// remove any trailing/padding data
+	status_t status = gBufferModule->trim(buffer, packetLength);
+	if (status != B_OK)
+		return status;
+
+	//
+	// TODO: check for fragmentation
+	//
+
+	gBufferModule->remove_header(buffer, transportHeaderOffset);
+
+	raw_receive_data(buffer);
+
+	net_protocol_module_info* module = receiving_protocol(protocol);
+	if (module == NULL) {
+		// no handler for this packet
+		return EAFNOSUPPORT;
+	}
+
+	if ((buffer->flags & MSG_MCAST) != 0) {
+		// Unfortunely historical reasons dictate that the IP multicast
+		// model be a little different from the unicast one. We deliver
+		// this frame directly to all sockets registered with interest
+		// for this multicast group.
+		return deliver_multicast(module, buffer, false);
+	}
+
+	return module->receive_data(buffer);
+}
+
+
+status_t
+ipv6_deliver_data(net_protocol* _protocol, net_buffer* buffer)
+{
+	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;
+
+	if (protocol->raw == NULL)
+		return B_ERROR;
+
+	return protocol->raw->SocketEnqueue(buffer);
+}
+
+
+status_t
+ipv6_error(uint32 code, net_buffer* data)
+{
+	return B_ERROR;
+}
+
+
+status_t
+ipv6_error_reply(net_protocol* protocol, net_buffer* causedError, uint32 code,
+	void* errorData)
+{
+	return B_ERROR;
+}
+
+
+ssize_t
+ipv6_process_ancillary_data_no_container(net_protocol* protocol,
+	net_buffer* buffer, void* msgControl, size_t msgControlLen)
+{
+	ssize_t bytesWritten = 0;
+
+	if (((ipv6_protocol*)protocol)->receive_hoplimit != 0) {
+		TRACE("receive_hoplimit");
+
+		if (msgControlLen < CMSG_SPACE(sizeof(int)))
+			return B_NO_MEMORY;
+
+		cmsghdr* messageHeader = (cmsghdr*)((char*)msgControl + bytesWritten);
+		messageHeader->cmsg_len = CMSG_LEN(sizeof(int));
+		messageHeader->cmsg_level = IPPROTO_IPV6;
+		messageHeader->cmsg_type = IPV6_HOPLIMIT;
+
+		int hoplimit = buffer->hoplimit;
+		memcpy(CMSG_DATA(messageHeader), &hoplimit, sizeof(int));
+
+		bytesWritten += CMSG_SPACE(sizeof(int));
+		msgControlLen -= CMSG_SPACE(sizeof(int));
+	}
+
+	if (((ipv6_protocol*)protocol)->receive_pktinfo != 0) {
+		TRACE("receive_pktinfo");
+
+		if (msgControlLen < CMSG_SPACE(sizeof(struct in6_pktinfo)))
+			return B_NO_MEMORY;
+
+		cmsghdr* messageHeader = (cmsghdr*)((char*)msgControl + bytesWritten);
+		messageHeader->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+		messageHeader->cmsg_level = IPPROTO_IPV6;
+		messageHeader->cmsg_type = IPV6_PKTINFO;
+
+		struct in6_pktinfo pi;
+		memcpy(&pi.ipi6_addr,
+			&((struct sockaddr_in6*)buffer->destination)->sin6_addr,
+		 	sizeof(struct in6_addr));
+		// REVIEWME: assume buffer->interface cannot be NULL
+		pi.ipi6_ifindex = buffer->interface->index;
+		memcpy(CMSG_DATA(messageHeader), &pi, sizeof(struct in6_pktinfo));
+
+		bytesWritten += CMSG_SPACE(sizeof(struct in6_pktinfo));
+		msgControlLen -= CMSG_SPACE(sizeof(struct in6_pktinfo));
+	}
+
+	return bytesWritten;
+}
+
+
+//	#pragma mark -
+
+
+status_t
+init_ipv6()
+{
+	mutex_init(&sRawSocketsLock, "raw sockets");
+	mutex_init(&sMulticastGroupsLock, "IPv6 multicast groups");
+	mutex_init(&sReceivingProtocolLock, "IPv6 receiving protocols");
+
+	status_t status;
+
+	sMulticastState = new MulticastState();
+	if (sMulticastState == NULL) {
+		status = B_NO_MEMORY;
+		goto err;
+	}
+
+	status = sMulticastState->Init();
+	if (status != B_OK)
+		goto err;
+
+	new (&sRawSockets) RawSocketList;
+		// static initializers do not work in the kernel,
+		// so we have to do it here, manually
+		// TODO: for modules, this shouldn't be required
+
+	status = gStackModule->register_domain_protocols(AF_INET6, SOCK_RAW, 0,
+		NET_IPV6_MODULE_NAME, NULL);
+	if (status != B_OK)
+		goto err;
+
+	status = gStackModule->register_domain(AF_INET6, "internet6", &gIPv6Module,
+		&gIPv6AddressModule, &sDomain);
+	if (status != B_OK)
+		goto err;
+
+	TRACE("init_ipv6: OK\n");
+	return B_OK;
+
+err:
+	delete sMulticastState;
+	mutex_destroy(&sReceivingProtocolLock);
+	mutex_destroy(&sMulticastGroupsLock);
+	mutex_destroy(&sRawSocketsLock);
+	TRACE("init_ipv6: error, status=%u\n", status);
+	return status;
+}
+
+
+status_t
+uninit_ipv6()
+{
+	mutex_lock(&sReceivingProtocolLock);
+
+	// put all the domain receiving protocols we gathered so far
+	for (uint32 i = 0; i < 256; i++) {
+		if (sReceivingProtocol[i] != NULL)
+			gStackModule->put_domain_receiving_protocol(sDomain, i);
+	}
+
+	delete sMulticastState;
+
+	gStackModule->unregister_domain(sDomain);
+	mutex_unlock(&sReceivingProtocolLock);
+
+	mutex_destroy(&sMulticastGroupsLock);
+	mutex_destroy(&sRawSocketsLock);
+	mutex_destroy(&sReceivingProtocolLock);
+
+	return B_OK;
+}
+
+
+static status_t
+ipv6_std_ops(int32 op, ...)
+{
+	switch (op) {
+		case B_MODULE_INIT:
+			return init_ipv6();
+		case B_MODULE_UNINIT:
+			return uninit_ipv6();
+
+		default:
+			return B_ERROR;
+	}
+}
+
+
+net_protocol_module_info gIPv6Module = {
+	{
+		NET_IPV6_MODULE_NAME,
+		0,
+		ipv6_std_ops
+	},
+	NET_PROTOCOL_ATOMIC_MESSAGES,
+
+	ipv6_init_protocol,
+	ipv6_uninit_protocol,
+	ipv6_open,
+	ipv6_close,
+	ipv6_free,
+	ipv6_connect,
+	ipv6_accept,
+	ipv6_control,
+	ipv6_getsockopt,
+	ipv6_setsockopt,
+	ipv6_bind,
+	ipv6_unbind,
+	ipv6_listen,
+	ipv6_shutdown,
+	ipv6_send_data,
+	ipv6_send_routed_data,
+	ipv6_send_avail,
+	ipv6_read_data,
+	ipv6_read_avail,
+	ipv6_get_domain,
+	ipv6_get_mtu,
+	ipv6_receive_data,
+	ipv6_deliver_data,
+	ipv6_error,
+	ipv6_error_reply,
+	NULL,		// add_ancillary_data()
+	NULL,		// process_ancillary_data()
+	ipv6_process_ancillary_data_no_container,
+	NULL,		// send_data_no_buffer()
+	NULL		// read_data_no_buffer()
+};
+
+module_dependency module_dependencies[] = {
+	{NET_STACK_MODULE_NAME, (module_info**)&gStackModule},
+	{NET_BUFFER_MODULE_NAME, (module_info**)&gBufferModule},
+	{NET_DATALINK_MODULE_NAME, (module_info**)&sDatalinkModule},
+	{NET_SOCKET_MODULE_NAME, (module_info**)&sSocketModule},
+	{}
+};
+
+module_info* modules[] = {
+	(module_info*)&gIPv6Module,
+	NULL
+};
Index: src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.cpp	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.cpp	(revision 0)
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+/* Parts of this file are covered under the following copyright */
+/*
+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (c) 1996-1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS.	 IN NO EVENT SHALL ISC BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <net_datalink.h>
+
+#include <ByteOrder.h>
+#include <KernelExport.h>
+#include <NetUtilities.h>
+
+#include <memory.h>
+#include <netinet6/in6.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ipv6_utils.h"
+
+
+#define NS_IN6ADDRSZ 16
+#define NS_INT16SZ 2
+
+#define SPRINTF(x) ((size_t)sprintf x)
+
+
+/*!	Convert IPv6 binary address into presentation (printable) format.
+	Author: Paul Vixie, 1996.
+	\return pointer to dst string if address as been printed
+	\return NULL if the buffer is too short
+*/
+const char *
+ip6_sprintf(const in6_addr *srcaddr, char *dst, size_t size)
+{
+	/*
+	 * Note that int32_t and int16_t need only be "at least" large enough
+	 * to contain a value of the specified size.  On some systems, like
+	 * Crays, there is no such thing as an integer variable with 16 bits.
+	 * Keep this in mind if you think this function should have been coded
+	 * to use pointer overlays.	 All the world's not a VAX.
+	 */
+	char tmp[INET6_ADDRSTRLEN], *tp;
+	struct { int base, len; } best, cur;
+	uint16 words[NS_IN6ADDRSZ / NS_INT16SZ];
+	int i;
+	const uint8 *src = srcaddr->s6_addr;
+
+	/*
+	 * Preprocess:
+	 *	Copy the input (bytewise) array into a wordwise array.
+	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+	 */
+	memset(words, '\0', sizeof words);
+	for (i = 0; i < NS_IN6ADDRSZ; i++)
+		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
+	best.base = -1;
+	best.len = 0;
+	cur.base = -1;
+	cur.len = 0;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		if (words[i] == 0) {
+			if (cur.base == -1)
+				cur.base = i, cur.len = 1;
+			else
+				cur.len++;
+		} else {
+			if (cur.base != -1) {
+				if (best.base == -1 || cur.len > best.len)
+					best = cur;
+				cur.base = -1;
+			}
+		}
+	}
+	if (cur.base != -1) {
+		if (best.base == -1 || cur.len > best.len)
+			best = cur;
+	}
+	if (best.base != -1 && best.len < 2)
+		best.base = -1;
+
+	/*
+	 * Format the result.
+	 */
+	tp = tmp;
+	for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
+		/* Are we inside the best run of 0x00's? */
+		if (best.base != -1 && i >= best.base &&
+			i < (best.base + best.len)) {
+			if (i == best.base)
+				*tp++ = ':';
+			continue;
+		}
+		/* Are we following an initial run of 0x00s or any real hex? */
+		if (i != 0)
+			*tp++ = ':';
+		/* Is this address an encapsulated IPv4? */
+#if 0
+		if (i == 6 && best.base == 0 && (best.len == 6 ||
+			(best.len == 7 && words[7] != 0x0001) ||
+			(best.len == 5 && words[5] == 0xffff))) {
+			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+				return (NULL);
+			tp += strlen(tp);
+			break;
+		}
+#endif
+		tp += SPRINTF((tp, "%x", words[i]));
+	}
+	/* Was it a trailing run of 0x00's? */
+	if (best.base != -1 && (best.base + best.len) ==
+		(NS_IN6ADDRSZ / NS_INT16SZ))
+		*tp++ = ':';
+	*tp++ = '\0';
+
+	/*
+	 * Check for overflow, copy, and we're done.
+	 */
+	if ((size_t)(tp - tmp) > size)
+		return NULL;
+
+	strcpy(dst, tmp);
+	return dst;
+}
Index: src/add-ons/kernel/network/protocols/ipv6/multicast.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/multicast.cpp	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/multicast.cpp	(revision 0)
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+#include "ipv6_address.h"
+#include "multicast.h"
+
+#include <net_buffer.h>
+
+#include <netinet6/in6.h>
+
+#include <new>
+
+
+using std::nothrow;
+
+
+template<typename Addressing>
+MulticastGroupInterface<Addressing>::MulticastGroupInterface(Filter *parent,
+	const AddressType &address, net_interface *interface)
+	: fParent(parent), fMulticastAddress(address), fInterface(interface)
+{
+}
+
+
+template<typename Addressing>
+MulticastGroupInterface<Addressing>::~MulticastGroupInterface()
+{
+	Clear();
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::Add()
+{
+	if (fFilterMode == kInclude && !fAddresses.IsEmpty())
+		return EINVAL;
+
+	fFilterMode = kExclude;
+	return B_OK;
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::Drop()
+{
+	fAddresses.Clear();
+	fFilterMode = kInclude;
+	return B_OK;
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::BlockSource(
+	const AddressType &sourceAddress)
+{
+	if (fFilterMode != kExclude)
+		return EINVAL;
+
+	fAddresses.Add(sourceAddress);
+	return B_OK;
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::UnblockSource(
+	const AddressType &sourceAddress)
+{
+	if (fFilterMode != kExclude)
+		return EINVAL;
+
+	if (!fAddresses.Has(sourceAddress))
+		return EADDRNOTAVAIL;
+
+	fAddresses.Add(sourceAddress);
+	return B_OK;
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::AddSSM(const AddressType &sourceAddress)
+{
+	if (fFilterMode == kExclude)
+		return EINVAL;
+
+	fAddresses.Add(sourceAddress);
+	return B_OK;
+}
+
+
+template<typename Addressing> status_t
+MulticastGroupInterface<Addressing>::DropSSM(const AddressType &sourceAddress)
+{
+	if (fFilterMode == kExclude)
+		return EINVAL;
+
+	if (!fAddresses.Has(sourceAddress))
+		return EADDRNOTAVAIL;
+
+	fAddresses.Add(sourceAddress);
+	return B_OK;
+}
+
+
+template<typename Addressing> bool
+MulticastGroupInterface<Addressing>::IsEmpty() const
+{
+	return fFilterMode == kInclude && fAddresses.IsEmpty();
+}
+
+
+template<typename Addressing> void
+MulticastGroupInterface<Addressing>::Clear()
+{
+	if (IsEmpty())
+		return;
+
+	fFilterMode = kInclude;
+	fAddresses.Clear();
+	Addressing::LeaveGroup(this);
+}
+
+
+template<typename Addressing> bool
+MulticastGroupInterface<Addressing>::FilterAccepts(net_buffer *buffer) const
+{
+	bool has = fAddresses.Has(Addressing::AddressFromSockAddr(
+		buffer->source));
+
+	return (has && fFilterMode == kInclude)
+		|| (!has && fFilterMode == kExclude);
+}
+
+
+template<typename Addressing>
+MulticastFilter<Addressing>::MulticastFilter(ProtocolType *socket)
+	: fParent(socket), fStates()
+{
+}
+
+
+template<typename Addressing>
+MulticastFilter<Addressing>::~MulticastFilter()
+{
+	while (true) {
+		typename States::Iterator iterator = fStates.GetIterator();
+		if (!iterator.HasNext())
+			return;
+
+		GroupInterface *state = iterator.Next();
+		state->Clear();
+		_ReturnState(state);
+	}
+}
+
+
+template<typename Addressing> status_t
+MulticastFilter<Addressing>::GetState(const AddressType &groupAddress,
+	net_interface *interface, GroupInterface* &state, bool create)
+{
+	state = fStates.Lookup(std::make_pair(&groupAddress, interface->index));
+
+	if (state == NULL && create) {
+		state = new (nothrow) GroupInterface(this, groupAddress, interface);
+		if (state == NULL)
+			return B_NO_MEMORY;
+
+		status_t status = fStates.Insert(state);
+		if (status < B_OK) {
+			delete state;
+			return status;
+		}
+
+		status = Addressing::JoinGroup(state);
+		if (status < B_OK) {
+			fStates.Remove(state);
+			delete state;
+			return status;
+		}
+
+	}
+
+	return B_OK;
+}
+
+
+template<typename Addressing> void
+MulticastFilter<Addressing>::ReturnState(GroupInterface *state)
+{
+	if (state->IsEmpty())
+		_ReturnState(state);
+}
+
+
+template<typename Addressing> void
+MulticastFilter<Addressing>::_ReturnState(GroupInterface *state)
+{
+	fStates.Remove(state);
+	delete state;
+}
+
+// IPv6 explicit template instantiation
+template class MulticastFilter<IPv6Multicast>;
+template class MulticastGroupInterface<IPv6Multicast>;
Index: src/add-ons/kernel/network/protocols/ipv6/Jamfile
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/Jamfile	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/Jamfile	(revision 0)
@@ -0,0 +1,29 @@
+SubDir HAIKU_TOP src add-ons kernel network protocols ipv6 ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+if $(TARGET_PLATFORM) != haiku {
+	UseHeaders [ FStandardOSHeaders ] : true ;
+		# Needed for <support/Errors.h> and maybe other stuff.
+	UseHeaders [ FDirName $(HAIKU_TOP) headers posix ] : true ;
+		# We need the public network headers also when not compiling for Haiku.
+		# Unfortunately we get more than we want, namely all POSIX headers.
+}
+
+UsePrivateKernelHeaders ;
+UsePrivateHeaders net ;
+
+KernelAddon ipv6 :
+	ipv6.cpp
+	ipv6_address.cpp
+	ipv6_utils.cpp
+	multicast.cpp
+;
+
+# Installation
+HaikuInstall install-networking : /boot/home/config/add-ons/kernel/haiku_network/protocols
+	: ipv6 ;
+
+Package haiku-networkingkit-cvs :
+	haiku :
+	boot home config add-ons kernel haiku_network protocols ;
Index: src/add-ons/kernel/network/protocols/ipv6/jenkins.h
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/jenkins.h	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/jenkins.h	(revision 0)
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Taken from http://burtleburtle.net/bob/c/lookup3.c
+ */
+#ifndef LIBKERN_JENKINS_H
+#define LIBKERN_JENKINS_H
+
+
+/*
+  -------------------------------------------------------------------------------
+  lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+
+  These are functions for producing 32-bit hashes for hash table lookup.
+  hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
+  are externally useful functions.	Routines to test the hash are included
+  if SELF_TEST is defined.	You can use this free for any purpose.	It's in
+  the public domain.  It has no warranty.
+
+  You probably want to use hashlittle().  hashlittle() and hashbig()
+  hash byte arrays.	 hashlittle() is is faster than hashbig() on
+  little-endian machines.  Intel and AMD are little-endian machines.
+  On second thought, you probably want hashlittle2(), which is identical to
+  hashlittle() except it returns two 32-bit hashes for the price of one.
+  You could implement hashbig2() if you wanted but I haven't bothered here.
+
+  If you want to find a hash of, say, exactly 7 integers, do
+  a = i1;	 b = i2;  c = i3;
+  mix(a,b,c);
+  a += i4; b += i5; c += i6;
+  mix(a,b,c);
+  a += i7;
+  final(a,b,c);
+  then use c as the hash value.	 If you have a variable length array of
+  4-byte integers to hash, use hashword().	If you have a byte array (like
+  a character string), use hashlittle().  If you have several byte arrays, or
+  a mix of things, see the comments above hashlittle().
+  
+  Why is this so big?  I read 12 bytes at a time into 3 4-byte integers,
+  then mix those integers.	This is fast (you can do a lot more thorough
+  mixing with 12*3 instructions on 3 integers than you can with 3 instructions
+  on 1 byte), but shoehorning those bytes into integers efficiently is messy.
+  -------------------------------------------------------------------------------
+*/
+
+#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
+
+/*
+  -------------------------------------------------------------------------------
+  mix -- mix 3 32-bit values reversibly.
+
+  This is reversible, so any information in (a,b,c) before mix() is
+  still in (a,b,c) after mix().
+
+  If four pairs of (a,b,c) inputs are run through mix(), or through
+  mix() in reverse, there are at least 32 bits of the output that
+  are sometimes the same for one pair and different for another pair.
+  This was tested for:
+  * pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+  * "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+  * the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+  Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
+  satisfy this are
+  4  6  8 16 19  4
+  9 15  3 18 27 15
+  14  9  3	 7 17  3
+  Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
+  for "differ" defined as + with a one-bit base and a two-bit delta.	I
+  used http://burtleburtle.net/bob/hash/avalanche.html to choose 
+  the operations, constants, and arrangements of the variables.
+
+  This does not achieve avalanche.  There are input bits of (a,b,c)
+  that fail to affect some output bits of (a,b,c), especially of a.  The
+  most thoroughly mixed value is c, but it doesn't really even achieve
+  avalanche in c.
+
+  This allows some parallelism.  Read-after-writes are good at doubling
+  the number of bits affected, so the goal of mixing pulls in the opposite
+  direction as the goal of parallelism.  I did what I could.	Rotates
+  seem to cost as much as shifts on every machine I could lay my hands
+  on, and rotates are much kinder to the top and bottom bits, so I used
+  rotates.
+  -------------------------------------------------------------------------------
+*/
+#define mix(a,b,c)								\
+	{											\
+		a -= c;  a ^= rot(c, 4);	c += b;		\
+		b -= a;  b ^= rot(a, 6);	a += c;		\
+		c -= b;  c ^= rot(b, 8);	b += a;		\
+		a -= c;  a ^= rot(c,16);	c += b;		\
+		b -= a;  b ^= rot(a,19);	a += c;		\
+		c -= b;  c ^= rot(b, 4);	b += a;		\
+	}
+
+/*
+  -------------------------------------------------------------------------------
+  final -- final mixing of 3 32-bit values (a,b,c) into c
+
+  Pairs of (a,b,c) values differing in only a few bits will usually
+  produce values of c that look totally different.  This was tested for
+  * pairs that differed by one bit, by two bits, in any combination
+  of top bits of (a,b,c), or in any combination of bottom bits of
+  (a,b,c).
+  * "differ" is defined as +, -, ^, or ~^.  For + and -, I transformed
+  the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
+  is commonly produced by subtraction) look like a single 1-bit
+  difference.
+  * the base values were pseudorandom, all zero but one bit set, or 
+  all zero plus a counter that starts at zero.
+
+  These constants passed:
+  14 11 25 16 4 14 24
+  12 14 25 16 4 14 24
+  and these came close:
+  4	 8 15 26 3 22 24
+  10	 8 15 26 3 22 24
+  11	 8 15 26 3 22 24
+  -------------------------------------------------------------------------------
+*/
+#define final(a,b,c)							\
+	{											\
+		c ^= b; c -= rot(b,14);					\
+		a ^= c; a -= rot(c,11);					\
+		b ^= a; b -= rot(a,25);					\
+		c ^= b; c -= rot(b,16);					\
+		a ^= c; a -= rot(c,4);					\
+		b ^= a; b -= rot(a,14);					\
+		c ^= b; c -= rot(b,24);					\
+	}
+
+/*
+  --------------------------------------------------------------------
+  This works on all machines.  To be useful, it requires
+  -- that the key be an array of uint32's, and
+  -- that the length be the number of uint32's in the key
+
+  The function hashword() is identical to hashlittle() on little-endian
+  machines, and identical to hashbig() on big-endian machines,
+  except that the length has to be measured in uint32s rather than in
+  bytes.	 hashlittle() is more complicated than hashword() only because
+  hashlittle() has to dance around fitting the key bytes into registers.
+  --------------------------------------------------------------------
+*/
+static uint32
+jenkins_hashword(const uint32 *k,  /* the key, an array of uint32 values */
+	size_t length,		 /* the length of the key, in uint32s */
+	uint32 initval)	/* the previous hash, or an arbitrary value */
+{
+	uint32 a,b,c;
+
+	/* Set up the internal state */
+	a = b = c = 0xdeadbeef + (((uint32)length)<<2) + initval;
+
+	/*------------------------------------------------- handle most of the key */
+	while (length > 3)
+	{
+		a += k[0];
+		b += k[1];
+		c += k[2];
+		mix(a,b,c);
+		length -= 3;
+		k += 3;
+	}
+
+	/*------------------------------------------- handle the last 3 uint32's */
+	switch(length)					 /* all the case statements fall through */
+	{ 
+	case 3 : c+=k[2];
+	case 2 : b+=k[1];
+	case 1 : a+=k[0];
+		final(a,b,c);
+	case 0:	  /* case 0: nothing left to add */
+		break;
+	}
+	/*------------------------------------------------------ report the result */
+	return c;
+}
+
+#endif 
Index: src/add-ons/kernel/network/protocols/ipv6/ipv6_address.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/ipv6_address.cpp	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/ipv6_address.cpp	(revision 0)
@@ -0,0 +1,566 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Based on code from ipv4_address.cpp
+ */
+
+
+#include <net_datalink.h>
+
+#include <NetUtilities.h>
+
+#include <memory.h>
+#include <netinet6/in6.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "ipv6_address.h"
+#include "ipv6_utils.h"
+#include "jenkins.h"
+
+
+const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
+const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
+
+
+static void
+ipv6_mask_adress_inplace(sockaddr *address, const sockaddr *mask)
+{
+	in6_addr &i6addr = ((sockaddr_in6 *)address)->sin6_addr;
+	const in6_addr &i6mask = ((const sockaddr_in6 *)mask)->sin6_addr;
+
+	for (uint32 i = 0; i < sizeof(in6_addr); i++)
+		i6addr.s6_addr[i] &= i6mask.s6_addr[i];
+}
+
+
+/*!	Routing utility function: copies address \a from into a new address
+	that is put into \a to.
+	If \a replaceWithZeros is set \a from will be replaced by an empty
+	address.
+	If a \a mask is given it is applied to \a from (such that \a to is the
+	result of \a from & \a mask).
+	\return B_OK if the address could be copied
+	\return B_NO_MEMORY if the new address could not be allocated
+	\return B_BAD_VALUE if any of \a from or \a mask refers to an uninitialized
+			address
+	\return B_MISMATCHED_VALUES if \a address does not match family AF_INET
+*/
+static status_t
+ipv6_copy_address(const sockaddr *from, sockaddr **to,
+	bool replaceWithZeros = false, const sockaddr *mask = NULL)
+{
+	if (replaceWithZeros) {
+		*to = (sockaddr *)malloc(sizeof(sockaddr_in6));
+		if (*to == NULL)
+			return B_NO_MEMORY;
+
+		memset(*to, 0, sizeof(sockaddr_in6));
+		(*to)->sa_family = AF_INET6;
+		(*to)->sa_len = sizeof(sockaddr_in6);
+	} else {
+		if (from == NULL)
+			return B_OK;
+		if (from->sa_len == 0 || (mask != NULL && mask->sa_len == 0))
+			return B_BAD_VALUE;
+		if (from->sa_family != AF_INET6)
+			return B_MISMATCHED_VALUES;
+
+		*to = (sockaddr *)malloc(sizeof(sockaddr_in6));
+		if (*to == NULL)
+			return B_NO_MEMORY;
+
+		memcpy(*to, from, sizeof(sockaddr_in6));
+
+		if (mask != NULL)
+			ipv6_mask_adress_inplace(*to, mask);
+	}
+	return B_OK;
+}
+
+
+/*!	Routing utility function: applies \a mask to given \a address and puts
+	the resulting address into \a result.
+	\return B_OK if the mask has been applied
+	\return B_BAD_VALUE if \a address is NULL or if any of \a address or \a mask
+			refers to an uninitialized address
+*/
+static status_t
+ipv6_mask_address(const sockaddr *address, const sockaddr *mask,
+	sockaddr *result)
+{
+	if (address == NULL || address->sa_len == 0 || result == NULL
+			|| (mask != NULL && mask->sa_len == 0))
+		return B_BAD_VALUE;
+
+	memcpy(result, address, sizeof(sockaddr_in6));
+	if (mask != NULL)
+		ipv6_mask_adress_inplace(result, mask);
+
+	return B_OK;
+}
+
+
+/*!	Checks if the given \a address is the empty address. By default, the port
+	is checked, too, but you can avoid that by passing \a checkPort = false.
+	\return true if \a address is NULL, uninitialized or the empty address,
+		false if not
+*/
+static bool
+ipv6_is_empty_address(const sockaddr *_address, bool checkPort)
+{
+	if (_address == NULL || _address->sa_len == 0)
+		return true;
+
+	const sockaddr_in6 *address = (const sockaddr_in6 *)_address;
+	if (checkPort && address->sin6_port != 0) return false;
+	return IN6_IS_ADDR_UNSPECIFIED(&address->sin6_addr);
+}
+
+
+/*!	Checks if the given \a address is an Ipv6 address.
+	\return false if \a address is NULL, or with family different from AF_INET
+		true if it has AF_INET address family
+*/
+static bool
+ipv6_is_same_family(const sockaddr *address)
+{
+	if (address == NULL)
+		return false;
+
+	return address->sa_family == AF_INET6;
+}
+
+
+/*!	Compares the IP-addresses of the two given address structures \a a and \a b.
+	\return true if IP-addresses of \a a and \a b are equal, false if not
+*/
+static bool
+ipv6_equal_addresses(const sockaddr *a, const sockaddr *b)
+{
+	if (a == NULL && b == NULL)
+		return true;
+	if (a != NULL && b == NULL)
+		return ipv6_is_empty_address(a, false);
+	if (a == NULL && b != NULL)
+		return ipv6_is_empty_address(b, false);
+
+	const sockaddr_in6 *i6a = (const sockaddr_in6 *)a;
+	const sockaddr_in6 *i6b = (const sockaddr_in6 *)b;
+	return !memcmp(&i6a->sin6_addr, &i6b->sin6_addr, sizeof(in6_addr));
+}
+
+
+/*!	Compares the ports of the two given address structures \a a and \a b.
+	\return true if ports of \a a and \a b are equal, false if not
+*/
+static bool
+ipv6_equal_ports(const sockaddr *a, const sockaddr *b)
+{
+	uint16 portA = a ? ((sockaddr_in6 *)a)->sin6_port : 0;
+	uint16 portB = b ? ((sockaddr_in6 *)b)->sin6_port : 0;
+	return portA == portB;
+}
+
+
+/*!	Compares the IP-addresses and ports of the two given address structures
+	\a a and \a b.
+	\return true if IP-addresses and ports of \a a and \a b are equal, false if
+			not
+*/
+static bool
+ipv6_equal_addresses_and_ports(const sockaddr *a, const sockaddr *b)
+{
+	if (a == NULL && b == NULL)
+		return true;
+	if (a != NULL && b == NULL)
+		return ipv6_is_empty_address(a, true);
+	if (a == NULL && b != NULL)
+		return ipv6_is_empty_address(b, true);
+
+	const sockaddr_in6 *i6a = (const sockaddr_in6 *)a;
+	const sockaddr_in6 *i6b = (const sockaddr_in6 *)b;
+	return i6a->sin6_port == i6b->sin6_port
+		&& !memcmp(&i6a->sin6_addr, &i6b->sin6_addr, sizeof(in6_addr));
+}
+
+
+/*!	Applies the given \a mask two \a a and \a b and then checks whether
+	the masked addresses match.
+	\return true if \a a matches \a b after masking both, false if not
+*/
+static bool
+ipv6_equal_masked_addresses(const sockaddr *a, const sockaddr *b,
+	const sockaddr *mask)
+{
+	if (a == NULL && b == NULL)
+		return true;
+
+	const in6_addr *i6a;
+	if (a == NULL)
+		i6a = &in6addr_any;
+	else
+		i6a = &((const sockaddr_in6*)a)->sin6_addr;
+
+	const in6_addr *i6b;
+	if (b == NULL)
+		i6b = &in6addr_any;
+	else
+		i6b = &((const sockaddr_in6*)b)->sin6_addr;
+
+ 	if (!mask)
+		return !memcmp(i6a, i6b, sizeof(in6_addr));
+
+	const uint8 *pmask = ((const sockaddr_in6 *)mask)->sin6_addr.s6_addr;
+	for (uint8 i = 0; i < sizeof(in6_addr); ++i) {
+		if (pmask[i] != 0xff) {
+			return (i6a->s6_addr[i] & pmask[i])
+				== (i6b->s6_addr[i] & pmask[i]);
+		}
+
+		if (i6a->s6_addr[i] != i6b->s6_addr[i])
+			return false;
+	}
+
+	return true;
+}
+
+
+/*!	Routing utility function: determines the least significant bit that is set
+	in the given \a mask.
+	\return the number of the first bit that is set (0-32, where 32 means
+		that there's no bit set in the mask).
+*/
+static int32
+ipv6_first_mask_bit(const sockaddr *_mask)
+{
+	if (_mask == NULL)
+		return 0;
+
+	const uint8 *pmask = ((const sockaddr_in6 *)_mask)->sin6_addr.s6_addr;
+	for (uint8 i = 0; i < sizeof(in6_addr); ++i) {
+		if (pmask[i] == 0xff)
+			continue;
+
+		for (uint8 bit = 0; bit < 8; bit++) {
+			if (pmask[i] & (1 << bit))
+				return bit;
+		}
+	}
+
+	return 128;
+}
+
+
+/*!	Routing utility function: checks the given \a mask for correctness (which
+	means that (starting with LSB) consists zero or more unset bits, followed
+	by bits that are all set).
+	\return true if \a mask is ok, false if not
+*/
+static bool
+ipv6_check_mask(const sockaddr *_mask)
+{
+	if (_mask == NULL)
+		return true;
+
+	bool zero = false;
+	const uint8 *pmask = ((const sockaddr_in6 *)_mask)->sin6_addr.s6_addr;
+	for (uint8 i = 0; i < sizeof(in6_addr); ++i) {
+		if (pmask[i] == 0xff) {
+			if (zero)
+				return false;
+		} else if (pmask[i] == 0) {
+			zero = true;
+		} else {
+			for (int8 bit = 7; bit > 0; bit--) {
+				if (pmask[i] & (1 << bit)) {
+					if (zero)
+						return false;
+				} else {
+					zero = true;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+
+/*!	Creates a buffer for the given \a address and prints the address into
+	it (hexadecimal representation in network byte order or '<none>').
+	If \a printPort is set, the port is printed, too.
+	\return B_OK if the address could be printed, \a buffer will point to
+		the resulting string
+	\return B_BAD_VALUE if no buffer has been given
+	\return B_NO_MEMORY if the buffer could not be allocated,
+		or does not have enogh space
+*/
+static status_t
+ipv6_print_address_buffer(const sockaddr *_address, char *buffer,
+	size_t bufferSize, bool printPort)
+{
+	const sockaddr_in6 *address = (const sockaddr_in6 *)_address;
+
+	if (buffer == NULL)
+		return B_BAD_VALUE;
+
+	if (address == NULL) {
+		if (bufferSize < sizeof("<none>"))
+			return B_NO_MEMORY;
+		strcpy(buffer, "<none>");
+	} else {
+		if (printPort && bufferSize > 0) {
+			*buffer = '[';
+			buffer++;
+			bufferSize--;
+		}
+
+		if (!ip6_sprintf(&address->sin6_addr, buffer, bufferSize))
+			return B_NO_MEMORY;
+
+		if (printPort) {
+			char port[7];
+			sprintf(port, "]:%d", ntohs(address->sin6_port));
+			if (bufferSize - strlen(buffer) < strlen(port) + 1)
+				return B_NO_MEMORY;
+			strcat(buffer, port);
+		}
+	}
+
+	return B_OK;
+}
+
+
+static status_t
+ipv6_print_address(const sockaddr *_address, char **_buffer, bool printPort)
+{
+	if (_buffer == NULL)
+		return B_BAD_VALUE;
+
+	char tmp[64];
+	ipv6_print_address_buffer(_address, tmp, sizeof(tmp), printPort);
+
+	*_buffer = strdup(tmp);
+	if (*_buffer == NULL)
+		return B_NO_MEMORY;
+
+	return B_OK;
+}
+
+
+/*!	Determines the port of the given \a address.
+	\return uint16 representing the port-nr
+*/
+static uint16
+ipv6_get_port(const sockaddr *address)
+{
+	if (address == NULL || address->sa_len == 0)
+		return 0;
+
+	return ((sockaddr_in6 *)address)->sin6_port;
+}
+
+
+/*!	Sets the port of the given \a address to \a port.
+	\return B_OK if the port has been set
+	\return B_BAD_VALUE if \a address is NULL or has not been initialized
+*/
+static status_t
+ipv6_set_port(sockaddr *address, uint16 port)
+{
+	if (address == NULL || address->sa_len == 0)
+		return B_BAD_VALUE;
+
+	((sockaddr_in6 *)address)->sin6_port = port;
+	return B_OK;
+}
+
+
+/*!	Sets \a address to \a from.
+	\return B_OK if \a from has been copied into \a address
+	\return B_BAD_VALUE if either \a address or \a from is NULL or if the
+			address given in from has not been initialized
+	\return B_MISMATCHED_VALUES if from is not of family AF_INET6
+*/
+static status_t
+ipv6_set_to(sockaddr *address, const sockaddr *from)
+{
+	if (address == NULL || from == NULL || from->sa_len == 0)
+		return B_BAD_VALUE;
+
+	if (from->sa_family != AF_INET6)
+		return B_MISMATCHED_VALUES;
+
+	memcpy(address, from, sizeof(sockaddr_in6));
+	address->sa_len = sizeof(sockaddr_in6);
+	return B_OK;
+}
+
+
+/*!	Updates missing parts in \a address with the values in \a from.
+	\return B_OK if \a address has been updated from \a from
+	\return B_BAD_VALUE if either \a address or \a from is NULL or if the
+			address given in from has not been initialized
+	\return B_MISMATCHED_VALUES if from is not of family AF_INET6
+*/
+static status_t
+ipv6_update_to(sockaddr *_address, const sockaddr *_from)
+{
+	sockaddr_in6 *address = (sockaddr_in6 *)_address;
+	const sockaddr_in6 *from = (const sockaddr_in6 *)_from;
+
+	if (address == NULL || from == NULL || from->sin6_len == 0)
+		return B_BAD_VALUE;
+
+	if (from->sin6_family != AF_INET6)
+		return B_BAD_VALUE;
+
+	address->sin6_family = AF_INET6;
+	address->sin6_len = sizeof(sockaddr_in6);
+
+	if (address->sin6_port == 0)
+		address->sin6_port = from->sin6_port;
+
+	if (IN6_IS_ADDR_UNSPECIFIED(&address->sin6_addr)) {
+		memcpy(address->sin6_addr.s6_addr, from->sin6_addr.s6_addr,
+			sizeof(in6_addr));
+	}
+
+	return B_OK;
+}
+
+
+/*!	Sets \a address to the empty address (0.0.0.0).
+	\return B_OK if \a address has been set
+	\return B_BAD_VALUE if \a address is NULL
+*/
+static status_t
+ipv6_set_to_empty_address(sockaddr *address)
+{
+	if (address == NULL)
+		return B_BAD_VALUE;
+
+	memset(address, 0, sizeof(sockaddr_in6));
+	address->sa_len = sizeof(sockaddr_in6);
+	address->sa_family = AF_INET6;
+	return B_OK;
+}
+
+
+static status_t
+ipv6_set_to_defaults(sockaddr *_defaultMask, sockaddr *_defaultBroadcast,
+	sockaddr *_address, sockaddr *_mask)
+{
+	sockaddr_in6 *defaultMask = (sockaddr_in6 *)_defaultMask;
+	sockaddr_in6 *address = (sockaddr_in6 *)_address;
+	sockaddr_in6 *mask = (sockaddr_in6 *)_mask;
+
+	if (address == NULL || defaultMask == NULL)
+		return B_BAD_VALUE;
+
+	defaultMask->sin6_len = sizeof(sockaddr_in);
+	defaultMask->sin6_family = AF_INET6;
+	defaultMask->sin6_port = 0;
+	if (mask != NULL) {
+		memcpy(defaultMask->sin6_addr.s6_addr,
+			mask->sin6_addr.s6_addr, sizeof(in6_addr));
+	} else {
+		// use /128 as the default mask
+		memset(defaultMask->sin6_addr.s6_addr, 0xff, sizeof(in6_addr));
+	}
+
+	return B_OK;
+}
+
+
+/*!	Computes a hash-value of the given addresses \a ourAddress
+	and \a peerAddress.
+	\return uint32 representing the hash-value
+*/
+static uint32
+ipv6_hash_address_pair(const sockaddr *ourAddress, const sockaddr *peerAddress)
+{
+	uint32 result = 0;
+	if (ourAddress) {
+		const sockaddr_in6 *our = (const sockaddr_in6 *)ourAddress;
+		uint32 port = our->sin6_port;
+
+		result = jenkins_hashword((const uint32*)&our->sin6_addr,
+			sizeof(in6_addr) / sizeof(uint32), result);
+		result = jenkins_hashword(&port, 1, result);
+	}
+	if (peerAddress) {
+		const sockaddr_in6 *peer = (const sockaddr_in6 *)peerAddress;
+		uint32 port = peer->sin6_port;
+
+		result = jenkins_hashword((const uint32*)&peer->sin6_addr,
+			sizeof(in6_addr) / sizeof(uint32), result);
+		result = jenkins_hashword(&port, 1, result);
+	}
+
+	// TODO: also use sin6_flowinfo and sin6_scope_id?
+	return result;
+}
+
+
+/*!	Adds the given \a address to the IP-checksum \a checksum.
+	\return B_OK if \a address has been added to the checksum
+	\return B_BAD_VALUE if either \a address or \a checksum is NULL or if
+	        the given address is not initialized
+*/
+static status_t
+ipv6_checksum_address(struct Checksum *checksum, const sockaddr *address)
+{
+	if (checksum == NULL || address == NULL || address->sa_len == 0)
+		return B_BAD_VALUE;
+
+	in6_addr &a = ((sockaddr_in6 *)address)->sin6_addr;
+	for (uint32 i = 0; i < sizeof(in6_addr); i++)
+		(*checksum) << a.s6_addr[i];
+
+	return B_OK;
+}
+
+
+static void
+ipv6_get_loopback_address(sockaddr *_address)
+{
+	sockaddr_in6 *address = (sockaddr_in6 *)_address;
+	memset(address, 0, sizeof(sockaddr_in6));
+	address->sin6_len = sizeof(sockaddr_in6);
+	address->sin6_family = AF_INET6;
+	memcpy(&address->sin6_addr, &in6addr_loopback, sizeof(in6_addr));
+}
+
+
+net_address_module_info gIPv6AddressModule = {
+	{
+		NULL,
+		0,
+		NULL
+	},
+	false, // has_broadcast_address
+	ipv6_copy_address,
+	ipv6_mask_address,
+	ipv6_equal_addresses,
+	ipv6_equal_ports,
+	ipv6_equal_addresses_and_ports,
+	ipv6_equal_masked_addresses,
+	ipv6_is_empty_address,
+	ipv6_is_same_family,
+	ipv6_first_mask_bit,
+	ipv6_check_mask,
+	ipv6_print_address,
+	ipv6_print_address_buffer,
+	ipv6_get_port,
+	ipv6_set_port,
+	ipv6_set_to,
+	ipv6_set_to_empty_address,
+	ipv6_set_to_defaults,
+	ipv6_update_to,
+	ipv6_hash_address_pair,
+	ipv6_checksum_address,
+	ipv6_get_loopback_address
+};
Index: src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.h
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.h	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/ipv6_utils.h	(revision 0)
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef IPV6_UTILS_H
+#define IPV6_UTILS_H
+
+#include <netinet6/in6.h>
+#include <netinet/in.h>
+#include <net_stack.h>
+
+
+const char *ip6_sprintf(const in6_addr *addr, char *dst,
+	size_t size = INET6_ADDRSTRLEN);
+
+
+static inline uint16
+compute_checksum(uint8* _buffer, size_t length)
+{
+	uint16* buffer = (uint16*)_buffer;
+	uint32 sum = 0;
+
+	while (length >= 2) {
+		sum += *buffer++;
+		length -= 2;
+	}
+
+	return sum;
+}
+
+
+static inline uint16
+ipv6_checksum(const struct in6_addr* source,
+	const struct in6_addr* destination,
+	uint16 length, uint16 protocol,
+	uint16 checksum)
+{
+	uint32 sum = checksum;
+
+	length = htons(length);
+	protocol = htons(protocol);
+
+	sum += compute_checksum((uint8*)source, sizeof(in6_addr));
+	sum += compute_checksum((uint8*)destination, sizeof(in6_addr));
+	sum += compute_checksum((uint8*)&length, sizeof(uint16));
+	sum += compute_checksum((uint8*)&protocol, sizeof(uint16));
+
+	while (sum >> 16)
+		sum = (sum & 0xffff) + (sum >> 16);
+
+	return ~(uint16)sum;
+}
+
+#endif	// IPV6_UTILS_H
Index: src/add-ons/kernel/network/protocols/ipv6/multicast.h
===================================================================
--- src/add-ons/kernel/network/protocols/ipv6/multicast.h	(revision 0)
+++ src/add-ons/kernel/network/protocols/ipv6/multicast.h	(revision 0)
@@ -0,0 +1,229 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _IPV6_MULTICAST_H_
+#define _IPV6_MULTICAST_H_
+
+
+#include <util/DoublyLinkedList.h>
+#include <util/OpenHashTable.h>
+
+#include <net_datalink.h>
+
+//#include <netinet/in.h>
+#include <netinet6/in6.h>
+
+#include <utility>
+
+#include "jenkins.h"
+
+
+struct net_buffer;
+struct net_protocol;
+
+
+template<typename Addressing> class MulticastFilter;
+template<typename Addressing> class MulticastGroupInterface;
+
+
+struct IPv6Multicast {
+	typedef struct in6_addr AddressType;
+	typedef struct ipv6_protocol ProtocolType;
+	typedef MulticastGroupInterface<IPv6Multicast> GroupInterface;
+
+	static status_t JoinGroup(GroupInterface *);
+	static status_t LeaveGroup(GroupInterface *);
+
+	static const in6_addr &AddressFromSockAddr(const sockaddr *sockaddr)
+		{ return ((const sockaddr_in6 *)sockaddr)->sin6_addr; }
+	static size_t HashAddress(const in6_addr &address)
+		{ return jenkins_hashword((const uint32*)&address,
+				sizeof(in6_addr) / sizeof(uint32), 0); }
+};
+
+
+template<typename AddressType>
+class AddressSet {
+	struct ContainedAddress : DoublyLinkedListLinkImpl<ContainedAddress> {
+		AddressType address;
+	};
+
+	typedef DoublyLinkedList<ContainedAddress> AddressList;
+
+public:
+	AddressSet()
+		: fCount(0) {}
+
+	~AddressSet() { Clear(); }
+
+	status_t Add(const AddressType &address)
+	{
+		if (Has(address))
+			return B_OK;
+
+		ContainedAddress *container = new ContainedAddress();
+		if (container == NULL)
+			return B_NO_MEMORY;
+
+		container->address = address;
+		fAddresses.Add(container);
+
+		return B_OK;
+	}
+
+	void Remove(const AddressType &address)
+	{
+		ContainedAddress *container = _Get(address);
+		if (container == NULL)
+			return;
+
+		fAddresses.Remove(container);
+		delete container;
+	}
+
+	bool Has(const AddressType &address) const
+	{
+		return _Get(address) != NULL;
+	}
+
+	bool IsEmpty() const { return fAddresses.IsEmpty(); }
+
+	void Clear()
+	{
+		while (!fAddresses.IsEmpty())
+			Remove(fAddresses.Head()->address);
+	}
+
+	class Iterator {
+	public:
+		Iterator(const AddressList &addresses)
+			: fBaseIterator(addresses.GetIterator()) {}
+
+		bool HasNext() const { return fBaseIterator.HasNext(); }
+		AddressType &Next() { return fBaseIterator.Next()->address; }
+
+	private:
+		typename AddressList::ConstIterator fBaseIterator;
+	};
+
+	Iterator GetIterator() const { return Iterator(fAddresses); }
+
+private:
+	ContainedAddress *_Get(const AddressType &address) const
+	{
+		typename AddressList::ConstIterator it = fAddresses.GetIterator();
+		while (it.HasNext()) {
+			ContainedAddress *container = it.Next();
+			if (container->address == address)
+				return container;
+		}
+		return NULL;
+	}
+
+	AddressList fAddresses;
+	int fCount;
+};
+
+
+template<typename Addressing>
+class MulticastGroupInterface {
+public:
+	typedef MulticastGroupInterface<Addressing> ThisType;
+	typedef typename Addressing::AddressType AddressType;
+	typedef MulticastFilter<Addressing> Filter;
+	typedef ::AddressSet<AddressType> AddressSet;
+
+	enum FilterMode {
+		kInclude,
+		kExclude
+	};
+
+	MulticastGroupInterface(Filter *parent, const AddressType &address,
+		net_interface *interface);
+	~MulticastGroupInterface();
+
+	Filter *Parent() const { return fParent; }
+
+	const AddressType &Address() const { return fMulticastAddress; }
+	net_interface *Interface() const { return fInterface; }
+
+	status_t Add();
+	status_t Drop();
+	status_t BlockSource(const AddressType &sourceAddress);
+	status_t UnblockSource(const AddressType &sourceAddress);
+	status_t AddSSM(const AddressType &sourceAddress);
+	status_t DropSSM(const AddressType &sourceAddress);
+
+	bool IsEmpty() const;
+	void Clear();
+
+	FilterMode Mode() const { return fFilterMode; }
+	const AddressSet &Sources() const { return fAddresses; }
+
+	bool FilterAccepts(net_buffer *buffer) const;
+
+	struct HashDefinition {
+		typedef std::pair<const AddressType *, uint32> KeyType;
+		typedef ThisType ValueType;
+
+		size_t HashKey(const KeyType &key) const
+			{
+				size_t result = 0;
+				result = jenkins_hashword((const uint32*)&key.first, 
+					sizeof(in6_addr) / sizeof(uint32), result);
+				result = jenkins_hashword(&key.second, 1, result);
+				return result;
+			}
+		size_t Hash(ValueType *value) const
+			{ return HashKey(std::make_pair(&value->Address(),
+				value->Interface()->index)); }
+		bool Compare(const KeyType &key, ValueType *value) const
+			{ return value->Interface()->index == key.second
+				&& value->Address() == *key.first; }
+		MulticastGroupInterface*& GetLink(ValueType *value) const
+			{ return value->HashLink(); }
+	};
+
+	MulticastGroupInterface*& HashLink() { return fLink; }
+
+private:
+	// for g++ 2.95
+	friend class HashDefinition;
+
+	Filter *fParent;
+	AddressType fMulticastAddress;
+	net_interface *fInterface;
+	FilterMode fFilterMode;
+	AddressSet fAddresses;
+	MulticastGroupInterface* fLink;
+};
+
+
+template<typename Addressing>
+class MulticastFilter {
+public:
+	typedef typename Addressing::AddressType AddressType;
+	typedef typename Addressing::ProtocolType ProtocolType;
+	typedef MulticastGroupInterface<Addressing> GroupInterface;
+
+	MulticastFilter(ProtocolType *parent);
+	~MulticastFilter();
+
+	ProtocolType *Socket() const { return fParent; }
+
+	status_t GetState(const AddressType &groupAddress,
+		net_interface *interface, GroupInterface* &state, bool create);
+	void ReturnState(GroupInterface *state);
+
+private:
+	typedef typename GroupInterface::HashDefinition HashDefinition;
+	typedef BOpenHashTable<HashDefinition> States;
+
+	void _ReturnState(GroupInterface *state);
+
+	ProtocolType *fParent;
+	States fStates;
+};
+
+#endif
Index: src/add-ons/kernel/network/protocols/Jamfile
===================================================================
--- src/add-ons/kernel/network/protocols/Jamfile	(revision 37465)
+++ src/add-ons/kernel/network/protocols/Jamfile	(working copy)
@@ -1,7 +1,9 @@
 SubDir HAIKU_TOP src add-ons kernel network protocols ;
 
 SubInclude HAIKU_TOP src add-ons kernel network protocols icmp ;
+SubInclude HAIKU_TOP src add-ons kernel network protocols icmp6 ;
 SubInclude HAIKU_TOP src add-ons kernel network protocols ipv4 ;
+SubInclude HAIKU_TOP src add-ons kernel network protocols ipv6 ;
 SubInclude HAIKU_TOP src add-ons kernel network protocols l2cap ;
 SubInclude HAIKU_TOP src add-ons kernel network protocols tcp ;
 SubInclude HAIKU_TOP src add-ons kernel network protocols udp ;
Index: src/add-ons/kernel/network/protocols/udp/udp.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/udp/udp.cpp	(revision 37465)
+++ src/add-ons/kernel/network/protocols/udp/udp.cpp	(working copy)
@@ -1207,17 +1207,34 @@
 		NULL);
 	if (status < B_OK)
 		goto err1;
+	status = gStackModule->register_domain_protocols(AF_INET6, SOCK_DGRAM, IPPROTO_IP,
+		"network/protocols/udp/v1",
+		"network/protocols/ipv6/v1",
+		NULL);
+	if (status < B_OK)
+		goto err1;
+
 	status = gStackModule->register_domain_protocols(AF_INET, SOCK_DGRAM, IPPROTO_UDP,
 		"network/protocols/udp/v1",
 		"network/protocols/ipv4/v1",
 		NULL);
 	if (status < B_OK)
 		goto err1;
+	status = gStackModule->register_domain_protocols(AF_INET6, SOCK_DGRAM, IPPROTO_UDP,
+		"network/protocols/udp/v1",
+		"network/protocols/ipv6/v1",
+		NULL);
+	if (status < B_OK)
+		goto err1;
 
 	status = gStackModule->register_domain_receiving_protocol(AF_INET, IPPROTO_UDP,
 		"network/protocols/udp/v1");
 	if (status < B_OK)
 		goto err1;
+	status = gStackModule->register_domain_receiving_protocol(AF_INET6, IPPROTO_UDP,
+		"network/protocols/udp/v1");
+	if (status < B_OK)
+		goto err1;
 
 	add_debugger_command("udp_endpoints", UdpEndpointManager::DumpEndpoints,
 		"lists all open UDP endpoints");
@@ -1225,6 +1242,7 @@
 	return B_OK;
 
 err1:
+	// TODO: shouldn't unregister the protocols here?
 	delete sUdpEndpointManager;
 
 	TRACE_EPM("init_udp() fails with %lx (%s)", status, strerror(status));
Index: src/add-ons/kernel/network/protocols/icmp6/icmp6.cpp
===================================================================
--- src/add-ons/kernel/network/protocols/icmp6/icmp6.cpp	(revision 0)
+++ src/add-ons/kernel/network/protocols/icmp6/icmp6.cpp	(revision 0)
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <net_datalink.h>
+#include <net_protocol.h>
+#include <net_stack.h>
+#include <net_datalink_protocol.h>
+#include <NetBufferUtilities.h>
+
+#include <KernelExport.h>
+#include <util/list.h>
+
+#include <netinet/icmp6.h>
+#include <netinet/in.h>
+#include <new>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../ipv6/ipv6_utils.h" // ipv6_checksum()
+
+
+#define TRACE_ICMP6
+#ifdef TRACE_ICMP6
+#	define TRACE(x) dprintf x
+#else
+#	define TRACE(x) ;
+#endif
+
+
+typedef NetBufferField<uint16, offsetof(icmp6_hdr, icmp6_cksum)> ICMP6ChecksumField;
+
+
+net_buffer_module_info *gBufferModule;
+static net_stack_module_info *sStackModule;
+static net_datalink_protocol_module_info *sIPv6DatalinkModule;
+
+
+net_protocol *
+icmp6_init_protocol(net_socket *socket)
+{
+	net_protocol *protocol = new (std::nothrow) net_protocol;
+	if (protocol == NULL)
+		return NULL;
+
+	return protocol;
+}
+
+
+status_t
+icmp6_uninit_protocol(net_protocol *protocol)
+{
+	delete protocol;
+	return B_OK;
+}
+
+
+status_t
+icmp6_open(net_protocol *protocol)
+{
+	return B_OK;
+}
+
+
+status_t
+icmp6_close(net_protocol *protocol)
+{
+	return B_OK;
+}
+
+
+status_t
+icmp6_free(net_protocol *protocol)
+{
+	return B_OK;
+}
+
+
+status_t
+icmp6_connect(net_protocol *protocol, const struct sockaddr *address)
+{
+	return B_ERROR;
+}
+
+
+status_t
+icmp6_accept(net_protocol *protocol, struct net_socket **_acceptedSocket)
+{
+	return EOPNOTSUPP;
+}
+
+
+status_t
+icmp6_control(net_protocol *protocol, int level, int option, void *value,
+	size_t *_length)
+{
+	return protocol->next->module->control(protocol->next, level, option,
+		value, _length);
+}
+
+
+status_t
+icmp6_getsockopt(net_protocol *protocol, int level, int option,
+	void *value, int *length)
+{
+	return protocol->next->module->getsockopt(protocol->next, level, option,
+		value, length);
+}
+
+
+status_t
+icmp6_setsockopt(net_protocol *protocol, int level, int option,
+	const void *value, int length)
+{
+	return protocol->next->module->setsockopt(protocol->next, level, option,
+		value, length);
+}
+
+
+status_t
+icmp6_bind(net_protocol *protocol, const struct sockaddr *address)
+{
+	return B_ERROR;
+}
+
+
+status_t
+icmp6_unbind(net_protocol *protocol, struct sockaddr *address)
+{
+	return B_ERROR;
+}
+
+
+status_t
+icmp6_listen(net_protocol *protocol, int count)
+{
+	return EOPNOTSUPP;
+}
+
+
+status_t
+icmp6_shutdown(net_protocol *protocol, int direction)
+{
+	return EOPNOTSUPP;
+}
+
+
+status_t
+icmp6_send_data(net_protocol *protocol, net_buffer *buffer)
+{
+	return protocol->next->module->send_data(protocol->next, buffer);
+}
+
+
+status_t
+icmp6_send_routed_data(net_protocol *protocol, struct net_route *route,
+	net_buffer *buffer)
+{
+	return protocol->next->module->send_routed_data(protocol->next, route, buffer);
+}
+
+
+ssize_t
+icmp6_send_avail(net_protocol *protocol)
+{
+	return B_ERROR;
+}
+
+
+status_t
+icmp6_read_data(net_protocol *protocol, size_t numBytes, uint32 flags,
+	net_buffer **_buffer)
+{
+	return B_ERROR;
+}
+
+
+ssize_t
+icmp6_read_avail(net_protocol *protocol)
+{
+	return B_ERROR;
+}
+
+
+struct net_domain *
+icmp6_get_domain(net_protocol *protocol)
+{
+	return protocol->next->module->get_domain(protocol->next);
+}
+
+
+size_t
+icmp6_get_mtu(net_protocol *protocol, const struct sockaddr *address)
+{
+	return protocol->next->module->get_mtu(protocol->next, address);
+}
+
+
+status_t
+icmp6_receive_data(net_buffer *buffer)
+{
+	TRACE(("ICMPv6 received some data, buffer length %lu\n", buffer->size));
+
+	NetBufferHeaderReader<icmp6_hdr> bufferHeader(buffer);
+	if (bufferHeader.Status() < B_OK)
+		return bufferHeader.Status();
+
+	icmp6_hdr &header = bufferHeader.Data();
+
+	TRACE(("  got type %u, code %u, checksum 0x%x\n", header.icmp6_type,
+			header.icmp6_code, header.icmp6_cksum));
+
+	// compute and check the checksum
+	uint16 checksum;
+	checksum = gBufferModule->checksum(buffer, 0, buffer->size, false);
+	checksum = ipv6_checksum(&((sockaddr_in6*)buffer->source)->sin6_addr,
+		&((sockaddr_in6*)buffer->destination)->sin6_addr,
+		buffer->size, IPPROTO_ICMPV6, checksum);
+
+	TRACE(("  computed checksum: %ld\n", checksum));
+
+	if (checksum != 0)
+		return B_BAD_DATA;
+
+	switch (header.icmp6_type) {
+		case ICMP6_ECHO_REPLY:
+			break;
+
+		case ICMP6_ECHO_REQUEST:
+		{
+			net_domain *domain;
+			if (buffer->interface != NULL) {
+				domain = buffer->interface->domain;
+
+				// We only reply to echo requests of our local interface; we
+				// don't reply to broadcast requests
+				if (!domain->address_module->equal_addresses(
+						buffer->interface->address, buffer->destination))
+					break;
+			} else
+				domain = sStackModule->get_domain(buffer->source->sa_family);
+
+			if (domain == NULL || domain->module == NULL)
+				break;
+
+			net_buffer *reply = gBufferModule->duplicate(buffer);
+			if (reply == NULL)
+				return B_NO_MEMORY;
+
+			gBufferModule->swap_addresses(reply);
+
+			// There already is an ICMP header, and we'll reuse it
+			NetBufferHeaderReader<icmp6_hdr> header(reply);
+
+			header->icmp6_type = ICMP6_ECHO_REPLY;
+			header->icmp6_code = 0;
+			header->icmp6_cksum = 0;
+
+			header.Sync();
+
+			checksum = gBufferModule->checksum(buffer, 0, buffer->size, false);
+			*ICMP6ChecksumField(reply) = 
+				ipv6_checksum(&((sockaddr_in6*)buffer->source)->sin6_addr,
+					&((sockaddr_in6*)buffer->destination)->sin6_addr,
+					buffer->size, IPPROTO_ICMPV6, checksum);
+
+			status_t status = domain->module->send_data(NULL, reply);
+			if (status < B_OK) {
+				gBufferModule->free(reply);
+				return status;
+			}
+		}
+
+		default:
+			// forward unrecognized messages to datalink layer
+			return sIPv6DatalinkModule->receive_data(buffer);
+	}
+
+	gBufferModule->free(buffer);
+	return B_OK;
+}
+
+
+status_t
+icmp6_deliver_data(net_protocol *protocol, net_buffer *buffer)
+{
+	// TODO: does this look OK?
+	return icmp6_receive_data(buffer);
+}
+
+
+status_t
+icmp6_error(uint32 code, net_buffer *data)
+{
+	return B_ERROR;
+}
+
+
+status_t
+icmp6_error_reply(net_protocol *protocol, net_buffer *causedError, uint32 code,
+	void *errorData)
+{
+	return B_ERROR;
+}
+
+
+//	#pragma mark -
+
+
+static status_t
+icmp6_init()
+{
+	sStackModule->register_domain_protocols(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6,
+		"network/protocols/icmp6/v1",
+		"network/protocols/ipv6/v1",
+		NULL);
+
+	sStackModule->register_domain_receiving_protocol(AF_INET6, IPPROTO_ICMPV6,
+		"network/protocols/icmp6/v1");
+
+	return B_OK;
+}
+
+
+static status_t
+icmp6_std_ops(int32 op, ...)
+{
+	switch (op) {
+		case B_MODULE_INIT:
+			return icmp6_init();
+
+		case B_MODULE_UNINIT:
+			return B_OK;
+
+		default:
+			return B_ERROR;
+	}
+}
+
+
+net_protocol_module_info sICMP6Module = {
+	{
+		"network/protocols/icmp6/v1",
+		0,
+		icmp6_std_ops
+	},
+	NET_PROTOCOL_ATOMIC_MESSAGES,
+
+	icmp6_init_protocol,
+	icmp6_uninit_protocol,
+	icmp6_open,
+	icmp6_close,
+	icmp6_free,
+	icmp6_connect,
+	icmp6_accept,
+	icmp6_control,
+	icmp6_getsockopt,
+	icmp6_setsockopt,
+	icmp6_bind,
+	icmp6_unbind,
+	icmp6_listen,
+	icmp6_shutdown,
+	icmp6_send_data,
+	icmp6_send_routed_data,
+	icmp6_send_avail,
+	icmp6_read_data,
+	icmp6_read_avail,
+	icmp6_get_domain,
+	icmp6_get_mtu,
+	icmp6_receive_data,
+	icmp6_deliver_data,
+	icmp6_error,
+	icmp6_error_reply,
+	NULL,		// add_ancillary_data()
+	NULL,		// process_ancillary_data()
+	NULL,		// process_ancillary_data_no_container()
+	NULL,		// send_data_no_buffer()
+	NULL		// read_data_no_buffer()
+};
+
+module_dependency module_dependencies[] = {
+	{NET_STACK_MODULE_NAME, (module_info **)&sStackModule},
+	{NET_BUFFER_MODULE_NAME, (module_info **)&gBufferModule},
+	{"network/datalink_protocols/ipv6_datagram/v1",
+		(module_info **)&sIPv6DatalinkModule},
+	{}
+};
+
+module_info *modules[] = {
+	(module_info *)&sICMP6Module,
+	NULL
+};
Index: src/add-ons/kernel/network/protocols/icmp6/Jamfile
===================================================================
--- src/add-ons/kernel/network/protocols/icmp6/Jamfile	(revision 0)
+++ src/add-ons/kernel/network/protocols/icmp6/Jamfile	(revision 0)
@@ -0,0 +1,25 @@
+SubDir HAIKU_TOP src add-ons kernel network protocols icmp6 ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+if $(TARGET_PLATFORM) != haiku {
+	UseHeaders [ FStandardOSHeaders ] : true ;
+		# Needed for <support/Errors.h> and maybe other stuff.
+	UseHeaders [ FDirName $(HAIKU_TOP) headers posix ] : true ;
+		# We need the public network headers also when not compiling for Haiku.
+		# Unfortunately we get more than we want, namely all POSIX headers.
+}
+
+UsePrivateHeaders kernel net ;
+
+KernelAddon icmp6 :
+	icmp6.cpp
+;
+
+# Installation
+HaikuInstall install-networking : /boot/home/config/add-ons/kernel/haiku_network/protocols
+	: icmp6 ;
+
+Package haiku-networkingkit-cvs :
+	haiku :
+	boot home config add-ons kernel haiku_network protocols ;
Index: src/add-ons/kernel/network/stack/stack.cpp
===================================================================
--- src/add-ons/kernel/network/stack/stack.cpp	(revision 37465)
+++ src/add-ons/kernel/network/stack/stack.cpp	(working copy)
@@ -813,11 +813,17 @@
 	// TODO: for now!
 	register_domain_datalink_protocols(AF_INET, IFT_LOOP,
 		"network/datalink_protocols/loopback_frame/v1", NULL);
+	register_domain_datalink_protocols(AF_INET6, IFT_LOOP,
+		"network/datalink_protocols/loopback_frame/v1", NULL);
 	register_domain_datalink_protocols(AF_INET, IFT_ETHER,
 		"network/datalink_protocols/ipv4_datagram/v1",
 		"network/datalink_protocols/arp/v1",
 		"network/datalink_protocols/ethernet_frame/v1",
 		NULL);
+	register_domain_datalink_protocols(AF_INET6, IFT_ETHER,
+		"network/datalink_protocols/ipv6_datagram/v1",
+		"network/datalink_protocols/ethernet_frame/v1",
+		NULL);
 
 	return B_OK;
 
Index: src/add-ons/kernel/network/stack/net_buffer.cpp
===================================================================
--- src/add-ons/kernel/network/stack/net_buffer.cpp	(revision 37465)
+++ src/add-ons/kernel/network/stack/net_buffer.cpp	(working copy)
@@ -1038,6 +1038,7 @@
 	destination->interface = source->interface;
 	destination->offset = source->offset;
 	destination->protocol = source->protocol;
+	destination->hoplimit = source->hoplimit;
 	destination->type = source->type;
 }
 
Index: src/add-ons/kernel/network/stack/datalink.cpp
===================================================================
--- src/add-ons/kernel/network/stack/datalink.cpp	(revision 37465)
+++ src/add-ons/kernel/network/stack/datalink.cpp	(working copy)
@@ -30,7 +30,9 @@
 #include <stdio.h>
 #include <string.h>
 
+#include <netinet6/in6.h> // TODO
 
+
 struct datalink_protocol : net_protocol {
 	struct net_domain_private* domain;
 };
@@ -134,6 +136,21 @@
 		route.flags = RTF_LOCAL | RTF_HOST;
 		remove_route(interface->domain, &route);
 	}
+
+	// for IPv6 remove multicast route (ff00::/8)
+	// TODO: move this code
+	if (interface->address->sa_family == AF_INET6) {
+		sockaddr_in6 address;
+		memset(&address, 0, sizeof(sockaddr_in6));
+		address.sin6_family = AF_INET6;
+		address.sin6_len = sizeof(sockaddr_in6);
+		address.sin6_addr.s6_addr[0] = 0xff;
+
+		route.destination = (sockaddr*)&address;
+		route.mask = (sockaddr*)&address;
+		route.flags = 0;
+		remove_route(interface->domain, &route);
+	}
 }
 
 
@@ -160,6 +177,21 @@
 		route.flags = RTF_LOCAL | RTF_HOST;
 		add_route(interface->domain, &route);
 	}
+
+	// for IPv6 add multicast route (ff00::/8)
+	// TODO: move this code
+	if (interface->address->sa_family == AF_INET6) {
+		sockaddr_in6 address;
+		memset(&address, 0, sizeof(sockaddr_in6));
+		address.sin6_family = AF_INET6;
+		address.sin6_len = sizeof(sockaddr_in6);
+		address.sin6_addr.s6_addr[0] = 0xff;
+
+		route.destination = (sockaddr*)&address;
+		route.mask = (sockaddr*)&address;
+		route.flags = 0;
+		add_route(interface->domain, &route);
+	}
 }
 
 
@@ -183,6 +215,14 @@
 }
 
 
+static void
+free_address(sockaddr** _address)
+{
+	free(*_address);
+	*_address = NULL;
+}
+
+
 static status_t
 datalink_control_interface(net_domain_private* domain, int32 option,
 	void* value, size_t* _length, size_t expected, bool getByName)
@@ -386,7 +426,8 @@
 
 	net_route* route = NULL;
 	status_t status;
-	if (protocol != NULL && protocol->socket->bound_to_device > 0) {
+	if (protocol != NULL && protocol->socket != NULL
+		&& protocol->socket->bound_to_device > 0) {
 		status = get_device_route(domain, protocol->socket->bound_to_device,
 			&route);
 	} else
@@ -709,8 +750,15 @@
 					} else
 						oldNetmask = address;
 
-					sockaddr* broadcast = reallocate_address(
-						&interface->destination, request.ifr_addr.sa_len);
+					// reset the broadcast address if the address family has such
+					sockaddr* broadcast;
+					if (interface->domain->address_module->has_broadcast_address) {
+						broadcast = reallocate_address(&interface->destination,
+							request.ifr_addr.sa_len);
+					} else {
+						broadcast = NULL;
+						free_address(&interface->destination);
+					}
 
 					interface->domain->address_module->set_to_defaults(
 						netmask, broadcast, interface->address, oldNetmask);
@@ -920,6 +968,7 @@
 	interface_protocol_init,
 	interface_protocol_uninit,
 	interface_protocol_send_data,
+	NULL, // receive_data
 	interface_protocol_up,
 	interface_protocol_down,
 	interface_protocol_control,
Index: src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp	(revision 37465)
+++ src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp	(working copy)
@@ -1095,6 +1095,7 @@
 	arp_init_protocol,
 	arp_uninit_protocol,
 	arp_send_data,
+	NULL, // receive_data
 	arp_up,
 	arp_down,
 	arp_control,
Index: src/add-ons/kernel/network/datalink_protocols/ipv4_datagram/ipv4_datagram.cpp
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/ipv4_datagram/ipv4_datagram.cpp	(revision 37465)
+++ src/add-ons/kernel/network/datalink_protocols/ipv4_datagram/ipv4_datagram.cpp	(working copy)
@@ -136,6 +136,7 @@
 	ipv4_datalink_init,
 	ipv4_datalink_uninit,
 	ipv4_datalink_send_data,
+	NULL, // receive_data
 	ipv4_datalink_up,
 	ipv4_datalink_down,
 	ipv4_datalink_control,
Index: src/add-ons/kernel/network/datalink_protocols/loopback_frame/loopback_frame.cpp
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/loopback_frame/loopback_frame.cpp	(revision 37465)
+++ src/add-ons/kernel/network/datalink_protocols/loopback_frame/loopback_frame.cpp	(working copy)
@@ -171,6 +171,7 @@
 	loopback_frame_init,
 	loopback_frame_uninit,
 	loopback_frame_send_data,
+	NULL, // receive_data
 	loopback_frame_up,
 	loopback_frame_down,
 	loopback_frame_control,
Index: src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/ipv6_datagram.cpp
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/ipv6_datagram.cpp	(revision 0)
+++ src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/ipv6_datagram.cpp	(revision 0)
@@ -0,0 +1,1085 @@
+/*
+ * Copyright 2010, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <net_datalink.h>
+#include <net_datalink_protocol.h>
+#include <net_device.h>
+#include <net_stack.h>
+#include <net_protocol.h>
+#include <NetBufferUtilities.h>
+
+#include <generic_syscall.h>
+#include <util/atomic.h>
+#include <util/AutoLock.h>
+#include <util/DoublyLinkedList.h>
+#include <util/khash.h>
+#include <KernelExport.h>
+
+#include <netinet/in.h>
+#include <netinet6/in6.h>
+#include <netinet/icmp6.h>
+#include <net/ethernet.h> // for ETHER_TYPE_IPV6
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/if_dl.h>
+
+#include <new>
+
+#include "../../protocols/ipv6/jenkins.h" // TODO: move this file
+#include "../../protocols/ipv6/ipv6_address.h"
+
+
+#define TRACE_NDP
+#ifdef TRACE_NDP
+#	define TRACE(x) dprintf x
+#else
+#	define TRACE(x) ;
+#endif
+
+
+struct ipv6_datalink_protocol : net_datalink_protocol {
+	sockaddr_dl	hardware_address;
+};
+
+
+static void ndp_timer(struct net_timer *timer, void *data);
+
+
+net_buffer_module_info *gBufferModule;
+static net_stack_module_info *sStackModule;
+static net_protocol_module_info *sIPv6Module;
+net_protocol* sIPv6Protocol;
+static hash_table *sCache;
+static mutex sCacheLock;
+// TODO ETHER_FRAME_TYPE doesn't belong there, we need Layer 2
+//      independence.
+static const int32 kIPv6FrameType = ETHER_FRAME_TYPE | ETHER_TYPE_IPV6;
+static const net_buffer* kDeletedBuffer = (net_buffer*)~0;
+
+// needed for IN6_IS_ADDR_UNSPECIFIED() macro
+const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
+
+
+//	#pragma mark -
+
+
+struct neighbor_discovery_header {
+	uint8		icmp6_type;
+	uint8		icmp6_code;
+	uint16		icmp6_checksum;
+	uint32		flags;
+	in6_addr	target_address;
+
+	// This part is specific for Ethernet;
+	// also, the could be more than one option in theory.
+	uint8		option_type;
+	uint8		option_length;
+	uint8		link_address[ETHER_ADDRESS_LENGTH];
+} _PACKED;
+
+
+struct ndp_entry {
+	ndp_entry	*next;
+	in6_addr	protocol_address;
+	sockaddr_dl	hardware_address;
+	uint32		flags;
+	net_buffer	*request_buffer;
+	net_timer	timer;
+	uint32		timer_state;
+	bigtime_t	timestamp;
+	net_datalink_protocol *protocol;
+
+	typedef DoublyLinkedListCLink<net_buffer> NetBufferLink;
+	typedef DoublyLinkedList<net_buffer, NetBufferLink> BufferList;
+
+	BufferList  queue;
+
+	static int Compare(void *_entry, const void *_key);
+	static uint32 Hash(void *_entry, const void *_key, uint32 range);
+	static ndp_entry *Lookup(const in6_addr& protocolAddress);
+	static ndp_entry *Add(const in6_addr& protocolAddress,
+		sockaddr_dl *hardwareAddress, uint32 flags);
+
+	~ndp_entry();
+
+	void ClearQueue();
+	void MarkFailed();
+	void MarkValid();
+	void ScheduleRemoval();
+};
+
+#define NDP_FLAG_LOCAL		0x01
+#define NDP_FLAG_REJECT		0x02
+#define NDP_FLAG_PERMANENT	0x04
+#define NDP_FLAG_PUBLISH	0x08
+#define NDP_FLAG_VALID		0x10
+
+#define NDP_FLAG_REMOVED			0x00010000
+#define NDP_PUBLIC_FLAG_MASK		0x0000ffff
+
+#define NDP_NO_STATE				0
+#define NDP_STATE_REQUEST			1
+#define NDP_STATE_LAST_REQUEST		5
+#define NDP_STATE_REQUEST_FAILED	6
+#define NDP_STATE_REMOVE_FAILED		7
+#define NDP_STATE_STALE				8
+
+#define NDP_STALE_TIMEOUT	30 * 60000000LL		// 30 minutes
+#define NDP_REJECT_TIMEOUT	20000000LL			// 20 seconds
+#define NDP_REQUEST_TIMEOUT	1000000LL			// 1 second
+
+
+//	#pragma mark -
+
+
+static void
+ipv6_to_ether_multicast(sockaddr_dl *destination, const sockaddr_in6 *source)
+{
+	// To send an IPv6 multicast packet over Ethernet,
+	// take the last 32 bits of the destination IPv6 address,
+	// prepend 33-33- and use that as the destination Ethernet address.
+
+	destination->sdl_len = sizeof(sockaddr_dl);
+	destination->sdl_family = AF_LINK;
+	destination->sdl_index = 0;
+	destination->sdl_type = IFT_ETHER;
+	destination->sdl_e_type = ETHER_TYPE_IPV6;
+	destination->sdl_nlen = destination->sdl_slen = 0;
+	destination->sdl_alen = ETHER_ADDRESS_LENGTH;
+
+	destination->sdl_data[0] = 0x33;
+	destination->sdl_data[1] = 0x33;
+	memcpy(&destination->sdl_data[2], &source->sin6_addr.s6_addr[12], 4);
+}
+
+
+static inline sockaddr*
+ipv6_to_sockaddr(sockaddr_in6* target, const in6_addr &address)
+{
+	target->sin6_family = AF_INET6;
+	target->sin6_len = sizeof(sockaddr_in6);
+	target->sin6_port = 0;
+	target->sin6_flowinfo = 0;
+	target->sin6_scope_id = 0;
+	memcpy(target->sin6_addr.s6_addr, address.s6_addr, sizeof(in6_addr));
+	return (sockaddr*)target;
+}
+
+
+static inline sockaddr*
+ipv6_to_solicited_multicast(sockaddr_in6* target, const in6_addr &address)
+{
+	// The solicited-node multicast address for a given unicast address
+	// is constructed by taking the last three octets of the unicast address
+	// and prepending FF02::1:FF00:0000/104.
+
+	target->sin6_family = AF_INET6;
+	target->sin6_len = sizeof(sockaddr_in6);
+	target->sin6_port = 0;
+	target->sin6_flowinfo = 0;
+	target->sin6_scope_id = 0;
+
+	uint8 *targetIPv6 = target->sin6_addr.s6_addr;
+	memset(targetIPv6, 0, sizeof(in6_addr));
+	targetIPv6[0] = 0xff;
+	targetIPv6[1] = 0x02;
+	targetIPv6[11] = 0x01;
+	targetIPv6[12] = 0xff;
+ 	memcpy(&targetIPv6[13], &address.s6_addr[13], 3);
+
+	return (sockaddr*)target;
+}
+
+
+static inline uint32
+hash_ipv6_address(const in6_addr &address, uint32 range)
+{
+	return jenkins_hashword((const uint32*)&address,
+		sizeof(in6_addr) / sizeof(uint32), 0) % range;
+}
+
+
+//	#pragma mark -
+
+
+static net_buffer*
+get_request_buffer(ndp_entry* entry)
+{
+	net_buffer* buffer = entry->request_buffer;
+	if (buffer == NULL || buffer == kDeletedBuffer)
+		return NULL;
+
+	buffer = atomic_pointer_test_and_set(&entry->request_buffer,
+		(net_buffer*)NULL, buffer);
+	if (buffer == kDeletedBuffer)
+		return NULL;
+
+	return buffer;
+}
+
+
+static void
+put_request_buffer(ndp_entry* entry, net_buffer* buffer)
+{
+	net_buffer* requestBuffer = atomic_pointer_test_and_set(
+		&entry->request_buffer, buffer, (net_buffer*)NULL);
+	if (requestBuffer != NULL) {
+		// someone else took over ownership of the request buffer
+		gBufferModule->free(buffer);
+	}
+}
+
+
+static void
+delete_request_buffer(ndp_entry* entry)
+{
+	net_buffer* buffer = atomic_pointer_set(&entry->request_buffer,
+		kDeletedBuffer);
+	if (buffer != NULL && buffer != kDeletedBuffer)
+		gBufferModule->free(buffer);
+}
+
+
+int
+ndp_entry::Compare(void *_entry, const void *_key)
+{
+	ndp_entry *entry = (ndp_entry *)_entry;
+	in6_addr *key = (in6_addr *)_key;
+
+	if (entry->protocol_address == *key)
+		return 0;
+
+	return 1;
+}
+
+
+uint32
+ndp_entry::Hash(void *_entry, const void *_key, uint32 range)
+{
+	ndp_entry *entry = (ndp_entry *)_entry;
+	const in6_addr *key = (const in6_addr *)_key;
+
+	if (entry != NULL)
+		return hash_ipv6_address(entry->protocol_address, range);
+
+	return hash_ipv6_address(*key, range);
+}
+
+
+ndp_entry *
+ndp_entry::Lookup(const in6_addr& address)
+{
+	return (ndp_entry *)hash_lookup(sCache, &address);
+}
+
+
+ndp_entry *
+ndp_entry::Add(const in6_addr& protocolAddress, sockaddr_dl *hardwareAddress,
+	uint32 flags)
+{
+	ASSERT_LOCKED_MUTEX(&sCacheLock);
+
+	ndp_entry *entry = new (std::nothrow) ndp_entry;
+	if (entry == NULL)
+		return NULL;
+
+	entry->protocol_address = protocolAddress;
+	entry->flags = flags;
+	entry->timestamp = system_time();
+	entry->protocol = NULL;
+	entry->request_buffer = NULL;
+	entry->timer_state = NDP_NO_STATE;
+	sStackModule->init_timer(&entry->timer, ndp_timer, entry);
+
+	if (hardwareAddress != NULL) {
+		// this entry is already resolved
+		entry->hardware_address = *hardwareAddress;
+		entry->hardware_address.sdl_e_type = ETHER_TYPE_IPV6;
+	} else {
+		// this entry still needs to be resolved
+		entry->hardware_address.sdl_alen = 0;
+	}
+	if (entry->hardware_address.sdl_len != sizeof(sockaddr_dl)) {
+		// explicitly set correct length in case our caller hasn't...
+		entry->hardware_address.sdl_len = sizeof(sockaddr_dl);
+	}
+
+	if (hash_insert(sCache, entry) != B_OK) {
+		// We can delete the entry here with the sCacheLock held, since it's
+		// guaranteed there are no timers pending.
+		delete entry;
+		return NULL;
+	}
+
+	return entry;
+}
+
+
+ndp_entry::~ndp_entry()
+{
+	// make sure there is no active timer left for us
+	sStackModule->cancel_timer(&timer);
+	sStackModule->wait_for_timer(&timer);
+
+	ClearQueue();
+}
+
+
+void
+ndp_entry::ClearQueue()
+{
+	BufferList::Iterator iterator = queue.GetIterator();
+	while (iterator.HasNext()) {
+		net_buffer *buffer = iterator.Next();
+		iterator.Remove();
+		gBufferModule->free(buffer);
+	}
+}
+
+
+void
+ndp_entry::MarkFailed()
+{
+	TRACE(("NDP entry %p Marked as FAILED\n", this));
+
+	flags = (flags & ~NDP_FLAG_VALID) | NDP_FLAG_REJECT;
+	ClearQueue();
+}
+
+
+void
+ndp_entry::MarkValid()
+{
+	TRACE(("NDP entry %p Marked as VALID\n", this));
+
+	flags = (flags & ~NDP_FLAG_REJECT) | NDP_FLAG_VALID;
+
+	BufferList::Iterator iterator = queue.GetIterator();
+	while (iterator.HasNext()) {
+		net_buffer *buffer = iterator.Next();
+		iterator.Remove();
+
+		TRACE(("  NDP Dequeing packet %p...\n", buffer));
+
+		memcpy(buffer->destination, &hardware_address,
+			hardware_address.sdl_len);
+		protocol->next->module->send_data(protocol->next, buffer);
+	}
+}
+
+
+void
+ndp_entry::ScheduleRemoval()
+{
+	// schedule a timer to remove this entry
+	timer_state = NDP_STATE_REMOVE_FAILED;
+	sStackModule->set_timer(&timer, 0);
+}
+
+
+//	#pragma mark -
+
+
+static status_t
+ndp_init()
+{
+	sIPv6Protocol = sIPv6Module->init_protocol(NULL);
+	if (sIPv6Protocol == NULL)
+		return B_NO_MEMORY;
+	sIPv6Protocol->module = sIPv6Module;
+	sIPv6Protocol->socket = NULL;
+	sIPv6Protocol->next = NULL;
+
+	int value = 255;
+	sIPv6Module->setsockopt(sIPv6Protocol, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+		&value, sizeof(value));
+
+	mutex_init(&sCacheLock, "ndp cache");
+
+	sCache = hash_init(64, offsetof(struct ndp_entry, next),
+		&ndp_entry::Compare, &ndp_entry::Hash);
+	if (sCache == NULL) {
+		mutex_destroy(&sCacheLock);
+		return B_NO_MEMORY;
+	}
+
+	return B_OK;
+}
+
+
+static status_t
+ndp_uninit()
+{
+	if (sIPv6Protocol)
+		sIPv6Module->uninit_protocol(sIPv6Protocol);
+
+	return B_OK;
+}
+
+
+//	#pragma mark -
+
+
+/*!	Updates the entry determined by \a protocolAddress with the specified
+	\a hardwareAddress.
+	If such an entry does not exist yet, a new entry is added. If you try
+	to update a local existing entry but didn't ask for it (by setting
+	\a flags to NDP_FLAG_LOCAL), an error is returned.
+
+	This function does not lock the cache - you have to do it yourself
+	before calling it.
+*/
+status_t
+ndp_update_entry(const in6_addr& protocolAddress, sockaddr_dl *hardwareAddress,
+	uint32 flags, ndp_entry **_entry = NULL)
+{
+	ASSERT_LOCKED_MUTEX(&sCacheLock);
+
+	ndp_entry *entry = ndp_entry::Lookup(protocolAddress);
+	if (entry != NULL) {
+		// We disallow updating of entries that had been resolved before,
+		// but to a different address (only for those that belong to a
+		// specific address - redefining INADDR_ANY is always allowed).
+		// Right now, you have to manually purge the NDP entries (or wait some
+		// time) to let us switch to the new address.
+		if (!IN6_IS_ADDR_UNSPECIFIED(&protocolAddress)
+			&& entry->hardware_address.sdl_alen != 0
+			&& memcmp(LLADDR(&entry->hardware_address),
+				LLADDR(hardwareAddress), ETHER_ADDRESS_LENGTH)) {
+			// TODO: also printf the address
+			dprintf("NDP host updated with different hardware address "
+				"%02x:%02x:%02x:%02x:%02x:%02x.\n",
+				hardwareAddress->sdl_data[0], hardwareAddress->sdl_data[1],
+				hardwareAddress->sdl_data[2], hardwareAddress->sdl_data[3],
+				hardwareAddress->sdl_data[4], hardwareAddress->sdl_data[5]);
+			return B_ERROR;
+		}
+
+		entry->hardware_address = *hardwareAddress;
+		entry->timestamp = system_time();
+	} else {
+		entry = ndp_entry::Add(protocolAddress, hardwareAddress, flags);
+		if (entry == NULL)
+			return B_NO_MEMORY;
+	}
+
+	delete_request_buffer(entry);
+
+	if ((entry->flags & NDP_FLAG_PERMANENT) == 0) {
+		// (re)start the stale timer
+		entry->timer_state = NDP_STATE_STALE;
+		sStackModule->set_timer(&entry->timer, NDP_STALE_TIMEOUT);
+	}
+
+	if (entry->flags & NDP_FLAG_REJECT)
+		entry->MarkFailed();
+	else
+		entry->MarkValid();
+
+	if (_entry)
+		*_entry = entry;
+
+	return B_OK;
+}
+
+
+/*!	Creates a permanent local entry for the interface belonging to this protocol.
+	You need to hold the cache lock when calling this function.
+*/
+static status_t
+ndp_update_local(ipv6_datalink_protocol *protocol)
+{
+	ASSERT_LOCKED_MUTEX(&sCacheLock);
+
+	net_interface *interface = protocol->interface;
+	in6_addr inet6Address;
+
+	if (interface->address == NULL) {
+		// interface has not yet been set
+		memset(&inet6Address, 0, sizeof(in6_addr));
+	} else {
+		memcpy(&inet6Address,
+			&((sockaddr_in6 *)interface->address)->sin6_addr, sizeof(in6_addr));
+	}
+
+	sockaddr_dl address;
+	address.sdl_len = sizeof(sockaddr_dl);
+	address.sdl_family = AF_LINK;
+	address.sdl_type = IFT_ETHER;
+	address.sdl_e_type = ETHER_TYPE_IPV6;
+	address.sdl_nlen = 0;
+	address.sdl_slen = 0;
+	address.sdl_alen = interface->device->address.length;
+	memcpy(LLADDR(&address), interface->device->address.data, address.sdl_alen);
+
+	memcpy(&protocol->hardware_address, &address, sizeof(sockaddr_dl));
+		// cache the address in our protocol
+
+	ndp_entry *entry;
+	status_t status = ndp_update_entry(inet6Address, &address,
+		NDP_FLAG_LOCAL | NDP_FLAG_PERMANENT, &entry);
+	if (status == B_OK)
+		entry->protocol = protocol;
+
+	return status;
+}
+
+
+static status_t
+handle_neighbor_solicitation(net_buffer *buffer)
+{
+	NetBufferHeaderReader<neighbor_discovery_header> bufferHeader(buffer);
+	if (bufferHeader.Status() < B_OK)
+		return bufferHeader.Status();
+
+	neighbor_discovery_header &header = bufferHeader.Data();
+	if (header.option_type != ND_OPT_SOURCE_LINKADDR
+		|| header.option_length != 1)
+		return B_OK;
+
+	{
+		MutexLocker locker(sCacheLock);
+
+		// remember the address of the sender as we might need it later
+		sockaddr_dl hardwareAddress;
+		hardwareAddress.sdl_len = sizeof(sockaddr_dl);
+		hardwareAddress.sdl_family = AF_LINK;
+		hardwareAddress.sdl_index = 0;
+		hardwareAddress.sdl_type = IFT_ETHER;
+		hardwareAddress.sdl_e_type = ETHER_TYPE_IPV6;
+		hardwareAddress.sdl_nlen = hardwareAddress.sdl_slen = 0;
+		hardwareAddress.sdl_alen = ETHER_ADDRESS_LENGTH;
+		memcpy(LLADDR(&hardwareAddress), header.link_address,
+			ETHER_ADDRESS_LENGTH);
+
+		ndp_update_entry(header.target_address, &hardwareAddress, 0);
+
+		// check if this request is for us
+
+		ndp_entry *entry = ndp_entry::Lookup(header.target_address);
+		if (entry == NULL
+			|| (entry->flags & (NDP_FLAG_LOCAL | NDP_FLAG_PUBLISH)) == 0) {
+			// We're not the one to answer this request
+			// TODO: instead of letting the other's request time-out, can we
+			//	reply failure somehow?
+			TRACE(("  not for us\n"));
+			return B_ERROR;
+		}
+
+		// send a reply (by reusing the buffer we got)
+		gBufferModule->trim(buffer, sizeof(neighbor_discovery_header));
+
+		header.icmp6_type = ND_NEIGHBOR_SOLICIT;
+		header.icmp6_code = 0;
+		header.icmp6_checksum = 0;
+		header.flags = ND_NA_FLAG_SOLICITED;
+		header.option_type = ND_OPT_TARGET_LINKADDR;
+		memcpy(&header.link_address, LLADDR(&entry->hardware_address),
+			ETHER_ADDRESS_LENGTH);
+		bufferHeader.Sync();
+	}
+
+	// fix source and destination address
+	sockaddr_in6 *source = (sockaddr_in6*)buffer->source;
+	sockaddr_in6 *destination = (sockaddr_in6*)buffer->destination;
+	memcpy(&destination->sin6_addr, &source->sin6_addr, sizeof(in6_addr));
+	memcpy(&source->sin6_addr, &header.target_address, sizeof(in6_addr));
+
+	buffer->flags = 0;
+		// make sure this won't be a broadcast message
+
+	// TODO: there is not need to clone, could reuse old buffer
+	net_buffer* clone = gBufferModule->clone(buffer, true);
+	if (clone == NULL)
+		return B_NO_MEMORY;
+
+	if (sIPv6Protocol == NULL)
+		return B_ERROR;
+
+	// send the ICMPv6 packet out
+	TRACE(("Sending Neighbor Advertisement\n"));
+	return sIPv6Module->send_data(sIPv6Protocol, clone);
+}
+
+
+static void
+handle_neighbor_advertisement(net_buffer *buffer)
+{
+	// TODO: also process unsolicited advertisments?
+	if ((buffer->flags & MSG_MCAST) != 0)
+		return;
+
+	NetBufferHeaderReader<neighbor_discovery_header> bufferHeader(buffer);
+	if (bufferHeader.Status() < B_OK)
+		return;
+
+	neighbor_discovery_header &header = bufferHeader.Data();
+	if (header.option_type != ND_OPT_TARGET_LINKADDR
+		|| header.option_length != 1) {
+		return;
+	}
+
+	sockaddr_dl hardwareAddress;
+	hardwareAddress.sdl_len = sizeof(sockaddr_dl);
+	hardwareAddress.sdl_family = AF_LINK;
+	hardwareAddress.sdl_index = 0;
+	hardwareAddress.sdl_type = IFT_ETHER;
+	hardwareAddress.sdl_e_type = ETHER_TYPE_IPV6;
+	hardwareAddress.sdl_nlen = hardwareAddress.sdl_slen = 0;
+	hardwareAddress.sdl_alen = ETHER_ADDRESS_LENGTH;
+	memcpy(LLADDR(&hardwareAddress), header.link_address, ETHER_ADDRESS_LENGTH);
+
+	MutexLocker locker(sCacheLock);
+	// TODO: take in account ND_NA_FLAGs
+	ndp_update_entry(header.target_address, &hardwareAddress, 0);
+}
+
+
+static void
+ndp_timer(struct net_timer *timer, void *data)
+{
+	ndp_entry *entry = (ndp_entry *)data;
+	TRACE(("NDP timer %ld, entry %p!\n", entry->timer_state, entry));
+
+	switch (entry->timer_state) {
+		case NDP_NO_STATE:
+			// who are you kidding?
+			break;
+
+		case NDP_STATE_REQUEST_FAILED:
+			// Requesting the NDP entry failed, we keep it around for a while,
+			// though, so that we won't try to request the same address again
+			// too soon.
+			TRACE(("  requesting NDP entry %p failed!\n", entry));
+			entry->timer_state = NDP_STATE_REMOVE_FAILED;
+			entry->MarkFailed();
+			sStackModule->set_timer(&entry->timer, NDP_REJECT_TIMEOUT);
+			break;
+
+		case NDP_STATE_REMOVE_FAILED:
+		case NDP_STATE_STALE:
+			// the entry has aged so much that we're going to remove it
+			TRACE(("  remove NDP entry %p!\n", entry));
+
+			mutex_lock(&sCacheLock);
+			if ((entry->flags & NDP_FLAG_REMOVED) != 0) {
+				// The entry has already been removed, and is about to be deleted
+				mutex_unlock(&sCacheLock);
+				break;
+			}
+
+			hash_remove(sCache, entry);
+			mutex_unlock(&sCacheLock);
+
+			delete entry;
+			break;
+
+		default:
+		{
+			if (entry->timer_state > NDP_STATE_LAST_REQUEST)
+				break;
+
+			TRACE(("  send request for NDP entry %p!\n", entry));
+
+			net_buffer *request = get_request_buffer(entry);
+			if (request == NULL)
+				break;
+
+			if (entry->timer_state < NDP_STATE_LAST_REQUEST) {
+				// we'll still need our buffer, so in order to prevent it being
+				// freed by a successful send, we need to clone it
+				net_buffer* clone = gBufferModule->clone(request, true);
+				if (clone == NULL) {
+					// cloning failed - that means we won't be able to send as
+					// many requests as originally planned
+					entry->timer_state = NDP_STATE_LAST_REQUEST;
+				} else {
+					put_request_buffer(entry, request);
+					request = clone;
+				}
+			}
+
+			if (sIPv6Protocol == NULL)
+				break;
+
+			// we're trying to resolve the address, so keep sending requests
+			status_t status = sIPv6Module->send_data(sIPv6Protocol, request);
+			if (status < B_OK)
+				gBufferModule->free(request);
+
+			entry->timer_state++;
+			sStackModule->set_timer(&entry->timer, NDP_REQUEST_TIMEOUT);
+			break;
+		}
+	}
+}
+
+
+static status_t
+ndp_start_resolve(net_datalink_protocol *protocol, const in6_addr& address,
+	ndp_entry **_entry)
+{
+	ASSERT_LOCKED_MUTEX(&sCacheLock);
+
+	// create an unresolved entry as a placeholder
+	ndp_entry *entry = ndp_entry::Add(address, NULL, 0);
+	if (entry == NULL)
+		return B_NO_MEMORY;
+
+	// prepare NDP request
+
+	net_buffer *buffer = entry->request_buffer = gBufferModule->create(256);
+	if (entry->request_buffer == NULL) {
+		entry->ScheduleRemoval();
+		return B_NO_MEMORY;
+	}
+
+	NetBufferPrepend<neighbor_discovery_header> header(buffer);
+	status_t status = header.Status();
+	if (status < B_OK) {
+		entry->ScheduleRemoval();
+		return status;
+	}
+
+	net_interface *interface = protocol->interface;
+	net_device *device = interface->device;
+
+	// prepare source and target addresses
+
+ 	sockaddr_in6 *source = (sockaddr_in6 *)buffer->source;
+	ipv6_to_sockaddr(source, ((sockaddr_in6 *)interface->address)->sin6_addr);
+
+	sockaddr_in6 *destination = (sockaddr_in6 *)buffer->destination;
+	ipv6_to_solicited_multicast(destination, address);
+
+	buffer->protocol = IPPROTO_ICMPV6;
+
+	// prepare Neighbor Solicitation header
+
+	header->icmp6_type = ND_NEIGHBOR_SOLICIT;
+	header->icmp6_code = 0;
+	header->icmp6_checksum = 0;
+	header->flags = 0;
+	memcpy(&header->target_address, &address, sizeof(in6_addr));
+	header->option_type = ND_OPT_SOURCE_LINKADDR;
+	header->option_length = (sizeof(nd_opt_hdr) + ETHER_ADDRESS_LENGTH) >> 3;
+	memcpy(&header->link_address, device->address.data, ETHER_ADDRESS_LENGTH);
+	header.Sync();
+
+	if (sIPv6Protocol == NULL) {
+		entry->ScheduleRemoval();
+		return B_NO_MEMORY;
+	}
+
+	// this does not work, because multicast for now is only looped back!
+#if FIXME
+	// hack: set to use the correct interface by setting socket option
+	sIPv6Module->setsockopt(sIPv6Protocol, IPPROTO_IPV6, IPV6_MULTICAST_IF,
+		&source->sin6_addr, sizeof(in6_addr));
+#endif
+
+	net_buffer* clone = gBufferModule->clone(buffer, true);
+	if (clone == NULL) {
+		entry->ScheduleRemoval();
+		return B_NO_MEMORY;
+	}
+
+	// send the ICMPv6 packet out
+	TRACE(("Sending Neighbor Solicitation\n"));
+	status = sIPv6Module->send_data(sIPv6Protocol, clone);
+	if (status < B_OK) {
+		entry->ScheduleRemoval();
+		return status;
+	}
+
+	entry->protocol = protocol;
+	entry->timer_state = NDP_STATE_REQUEST;
+	sStackModule->set_timer(&entry->timer, 0);
+		// start request timer
+
+	*_entry = entry;
+	return B_OK;
+}
+
+
+//	#pragma mark -
+
+
+static status_t
+ipv6_datalink_init(net_interface *interface, net_datalink_protocol **_protocol)
+{
+	if (interface->domain->family != AF_INET6)
+		return B_BAD_TYPE;
+
+	// While the loopback doesn't get a header to mux protocols,
+	// we let it do all of the registration work.
+	if (interface->device->type == IFT_LOOP)
+		return B_BAD_TYPE;
+
+	ipv6_datalink_protocol *protocol = new (std::nothrow) ipv6_datalink_protocol;
+	if (protocol == NULL)
+		return B_NO_MEMORY;
+
+	memset(&protocol->hardware_address, 0, sizeof(sockaddr_dl));
+
+	// We register ETHER_TYPE_IPV6 as most datalink protocols use it
+	// to identify IPv6 datagrams. In the future we may limit this.
+
+	status_t status = sStackModule->register_domain_device_handler(
+		interface->device, kIPv6FrameType, interface->domain);
+	if (status < B_OK)
+		delete protocol;
+	else
+		*_protocol = protocol;
+
+	return status;
+}
+
+
+static status_t
+ipv6_datalink_uninit(net_datalink_protocol *protocol)
+{
+	sStackModule->unregister_device_handler(protocol->interface->device,
+		kIPv6FrameType);
+	delete protocol;
+	return B_OK;
+}
+
+
+static status_t
+ipv6_datalink_send_data(net_datalink_protocol *_protocol, net_buffer *buffer)
+{
+	ipv6_datalink_protocol *protocol = (ipv6_datalink_protocol*)_protocol;
+
+	memcpy(buffer->source, &protocol->hardware_address,
+		protocol->hardware_address.sdl_len);
+
+	if (buffer->flags & MSG_MCAST) {
+		sockaddr_dl multicastDestination;
+		ipv6_to_ether_multicast(&multicastDestination,
+			(sockaddr_in6 *)buffer->destination);
+		memcpy(buffer->destination, &multicastDestination,
+			sizeof(sockaddr_dl));
+	} else {
+		MutexLocker locker(sCacheLock);
+
+		// Lookup destination (we may need to wait for this)
+		ndp_entry *entry = ndp_entry::Lookup(
+			((struct sockaddr_in6 *)buffer->destination)->sin6_addr);
+		if (entry == NULL) {
+			status_t status = ndp_start_resolve(protocol,
+				((struct sockaddr_in6 *)buffer->destination)->sin6_addr,
+				&entry);
+			if (status < B_OK)
+				return status;
+		}
+			
+		if (entry->flags & NDP_FLAG_REJECT)
+			return EHOSTUNREACH;
+		else if (!(entry->flags & NDP_FLAG_VALID)) {
+			// entry is still being resolved.
+			TRACE(("NDP Queuing packet %p, entry still being resolved.\n",
+					buffer));
+			entry->queue.Add(buffer);
+			return B_OK;
+		}
+
+		memcpy(buffer->destination, &entry->hardware_address,
+			entry->hardware_address.sdl_len);
+	}
+
+	return protocol->next->module->send_data(protocol->next, buffer);
+}
+
+
+static status_t
+ipv6_datalink_receive_data(net_buffer *buffer)
+{
+	NetBufferHeaderReader<icmp6_hdr> bufferHeader(buffer);
+	if (bufferHeader.Status() < B_OK)
+		return bufferHeader.Status();
+
+	switch (bufferHeader->icmp6_type) {
+		case ND_NEIGHBOR_SOLICIT:
+			TRACE(("  received Neighbor Solicitation\n"));
+			handle_neighbor_solicitation(buffer);
+			break;
+
+		case ND_NEIGHBOR_ADVERT:
+			TRACE(("  received Neighbor Advertisement\n"));
+			handle_neighbor_advertisement(buffer);
+			break;
+	}
+
+	gBufferModule->free(buffer);
+	return B_OK;
+}
+
+static status_t
+ipv6_datalink_up(net_datalink_protocol *_protocol)
+{
+	ipv6_datalink_protocol *protocol = (ipv6_datalink_protocol *)_protocol;
+	status_t status = protocol->next->module->interface_up(protocol->next);
+	if (status < B_OK)
+		return status;
+
+	// join multicast address for listening to NS packets
+
+	// REVIEWME: can I rely on this function being called every time
+	// when interfae address changes?
+
+	if (protocol->interface->address != NULL) {
+		sockaddr_in6 &address = *(sockaddr_in6 *)protocol->interface->address;
+		sockaddr_in6 multicast;
+		ipv6_to_solicited_multicast(&multicast, address.sin6_addr);
+
+		struct ipv6_mreq mreq;
+		memcpy(&mreq.ipv6mr_multiaddr, &multicast.sin6_addr, sizeof(in6_addr));
+		mreq.ipv6mr_interface = protocol->interface->index;
+
+		if (sIPv6Protocol != NULL) {
+			sIPv6Module->setsockopt(sIPv6Protocol, IPPROTO_IPV6,
+				IPV6_JOIN_GROUP, &mreq, sizeof(mreq));
+		}
+	}
+
+	// cache this device's address for later use
+
+	mutex_lock(&sCacheLock);
+	status = ndp_update_local(protocol);
+	mutex_unlock(&sCacheLock);
+
+	if (status < B_OK) {
+		protocol->next->module->interface_down(protocol->next);
+		return status;
+	}
+}
+
+
+static void
+ipv6_datalink_down(net_datalink_protocol *protocol)
+{
+	// leave the NS multicast address
+
+	// REVIEWME: can I rely on this function being called every time
+	// when interface address changes?
+
+	if (protocol->interface->address != NULL) {
+		sockaddr_in6 &address = *(sockaddr_in6 *)protocol->interface->address;
+		sockaddr_in6 multicast;
+		ipv6_to_solicited_multicast(&multicast, address.sin6_addr);
+
+		struct ipv6_mreq mreq;
+		memcpy(&mreq.ipv6mr_multiaddr, &multicast.sin6_addr, sizeof(in6_addr));
+		mreq.ipv6mr_interface = protocol->interface->index;
+
+		if (sIPv6Protocol != NULL) {
+			sIPv6Module->setsockopt(sIPv6Protocol, IPPROTO_IPV6,
+				IPV6_LEAVE_GROUP, &mreq, sizeof(mreq));
+		}
+	}
+
+	// remove local NDP entry from the cache
+
+	if (protocol->interface->address != NULL) {
+		MutexLocker locker(sCacheLock);
+
+		ndp_entry *entry = ndp_entry::Lookup(
+			((sockaddr_in6*)protocol->interface->address)->sin6_addr);
+		if (entry != NULL) {
+			hash_remove(sCache, entry);
+			entry->flags |= NDP_FLAG_REMOVED;
+			locker.Unlock();
+
+			delete entry;
+		}
+	}
+
+	protocol->next->module->interface_down(protocol->next);
+}
+
+
+static status_t
+ipv6_datalink_control(net_datalink_protocol *protocol, int32 op,
+	void *argument, size_t length)
+{
+	return protocol->next->module->control(protocol->next, op, argument, length);
+}
+
+
+static status_t
+ipv6_datalink_join_multicast(net_datalink_protocol *protocol,
+	const sockaddr *address)
+{
+	if (address->sa_family != AF_INET6)
+		return EINVAL;
+
+	sockaddr_dl multicastAddress;
+	ipv6_to_ether_multicast(&multicastAddress, (const sockaddr_in6 *)address);
+
+	return protocol->next->module->join_multicast(protocol->next,
+		(sockaddr *)&multicastAddress);
+}
+
+
+static status_t
+ipv6_datalink_leave_multicast(net_datalink_protocol *protocol,
+	const sockaddr *address)
+{
+	if (address->sa_family != AF_INET6)
+		return EINVAL;
+
+	sockaddr_dl multicastAddress;
+	ipv6_to_ether_multicast(&multicastAddress, (const sockaddr_in6 *)address);
+
+	return protocol->next->module->leave_multicast(protocol->next,
+		(sockaddr *)&multicastAddress);
+}
+
+
+static status_t
+ipv6_datalink_std_ops(int32 op, ...)
+{
+	switch (op) {
+	case B_MODULE_INIT:
+		return ndp_init();
+
+	case B_MODULE_UNINIT:
+		return ndp_uninit();
+	}
+
+	return B_ERROR;
+}
+
+net_datalink_protocol_module_info gIPv6DataLinkModule = {
+	{
+		"network/datalink_protocols/ipv6_datagram/v1",
+		0,
+		ipv6_datalink_std_ops
+	},
+	ipv6_datalink_init,
+	ipv6_datalink_uninit,
+	ipv6_datalink_send_data,
+	ipv6_datalink_receive_data,
+	ipv6_datalink_up,
+	ipv6_datalink_down,
+	ipv6_datalink_control,
+	ipv6_datalink_join_multicast,
+	ipv6_datalink_leave_multicast,
+};
+
+
+module_dependency module_dependencies[] = {
+	{NET_STACK_MODULE_NAME, (module_info **)&sStackModule},
+	{NET_BUFFER_MODULE_NAME, (module_info **)&gBufferModule},
+	{"network/protocols/ipv6/v1", (module_info **)&sIPv6Module},
+	{}
+};
+
+module_info *modules[] = {
+	(module_info *)&gIPv6DataLinkModule,
+	NULL
+};
Index: src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/Jamfile
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/Jamfile	(revision 0)
+++ src/add-ons/kernel/network/datalink_protocols/ipv6_datagram/Jamfile	(revision 0)
@@ -0,0 +1,26 @@
+SubDir HAIKU_TOP src add-ons kernel network datalink_protocols ipv6_datagram ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+if $(TARGET_PLATFORM) != haiku {
+	UseHeaders [ FStandardOSHeaders ] : true ;
+		# Needed for <support/Errors.h> and maybe other stuff.
+	UseHeaders [ FDirName $(HAIKU_TOP) headers posix ] : true ;
+		# We need the public network headers also when not compiling for Haiku.
+		# Unfortunately we get more than we want, namely all POSIX headers.
+}
+
+UsePrivateKernelHeaders ;
+UsePrivateHeaders kernel net ;
+
+KernelAddon ipv6_datagram :
+	ipv6_datagram.cpp
+;
+
+# Installation
+HaikuInstall install-networking : /boot/home/config/add-ons/kernel/haiku_network/datalink_protocols
+	: ipv6_datagram ;
+
+Package haiku-networkingkit-cvs :
+	haiku :
+	boot home config add-ons kernel haiku_network datalink_protocols ;
Index: src/add-ons/kernel/network/datalink_protocols/Jamfile
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/Jamfile	(revision 37465)
+++ src/add-ons/kernel/network/datalink_protocols/Jamfile	(working copy)
@@ -3,4 +3,5 @@
 SubInclude HAIKU_TOP src add-ons kernel network datalink_protocols arp ;
 SubInclude HAIKU_TOP src add-ons kernel network datalink_protocols ethernet_frame ;
 SubInclude HAIKU_TOP src add-ons kernel network datalink_protocols ipv4_datagram ;
+SubInclude HAIKU_TOP src add-ons kernel network datalink_protocols ipv6_datagram ;
 SubInclude HAIKU_TOP src add-ons kernel network datalink_protocols loopback_frame ;
Index: src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp
===================================================================
--- src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp	(revision 37465)
+++ src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp	(working copy)
@@ -210,6 +210,7 @@
 	ethernet_frame_init,
 	ethernet_frame_uninit,
 	ethernet_frame_send_data,
+	NULL, // receive_data
 	ethernet_frame_up,
 	ethernet_frame_down,
 	ethernet_frame_control,
Index: src/bin/network/ping6/ping6.c
===================================================================
--- src/bin/network/ping6/ping6.c	(revision 0)
+++ src/bin/network/ping6/ping6.c	(revision 0)
@@ -0,0 +1,2647 @@
+/*
+ * Using the InterNet Control Message Protocol (ICMP) "ECHO" facility,
+ * measure round-trip-delays and packet loss across network paths.
+ *
+ * Author -
+ *	Mike Muuss
+ *	U. S. Army Ballistic Research Laboratory
+ *	December, 1983
+ *
+ * Status -
+ *	Public Domain.  Distribution Unlimited.
+ * Bugs -
+ *	More statistics could always be gathered.
+ *	This program has to run SUID to ROOT to access the ICMP socket.
+ */
+
+/*
+ * NOTE:
+ * USE_SIN6_SCOPE_ID assumes that sin6_scope_id has the same semantics
+ * as IPV6_PKTINFO.  Some people object it (sin6_scope_id specifies *link*
+ * while IPV6_PKTINFO specifies *interface*.  Link is defined as collection of
+ * network attached to 1 or more interfaces)
+ */
+#define USE_SIN6_SCOPE_ID 1
+
+#define USE_RFC2292BIS 1
+#define HAVE_POLL_H 1
+#define CMSG_SENDING_UNSUPPORTED 1
+#undef IPSEC
+#undef IPV6_OPTIONS
+
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+
+#include <net/if.h>
+#include <net/route.h>
+
+#include <netinet/in.h>
+#include <netinet/ip6.h>
+#include <netinet/icmp6.h>
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+#include <netdb.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <math.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
+
+#ifdef IPSEC
+#include <netipsec/ah.h>
+#include <netipsec/ipsec.h>
+#endif
+
+struct tv32 {
+	u_int32_t tv32_sec;
+	u_int32_t tv32_usec;
+};
+
+#define	IP6LEN			40
+#define MAXPACKETLEN	(IPV6_MAXPACKET - IP6LEN) 
+#define ICMP6ECHOLEN	8	/* icmp echo header len excluding time */
+#define ICMP6ECHOTMLEN	sizeof(struct tv32)
+#define ICMP6_NIQLEN	(ICMP6ECHOLEN + 8)
+# define CONTROLLEN		10240	/* ancillary data buffer size RFC3542 20.1 */
+/* FQDN case, 64 bits of nonce + 32 bits ttl */
+#define ICMP6_NIRLEN	(ICMP6ECHOLEN + 12)
+#define	EXTRA		256	/* for AH and various other headers. weird. */
+#define	DEFDATALEN	ICMP6ECHOTMLEN
+#define MAXDATALEN	MAXPACKETLEN - IP6LEN - ICMP6ECHOLEN
+#define	NROUTES		9		/* number of record route slots */
+
+#define	A(bit)		rcvd_tbl[(bit)>>3]	/* identify byte in array */
+#define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
+#define	SET(bit)	(A(bit) |= B(bit))
+#define	CLR(bit)	(A(bit) &= (~B(bit)))
+#define	TST(bit)	(A(bit) & B(bit))
+
+#define	F_FLOOD		0x0001
+#define	F_INTERVAL	0x0002
+#define	F_PINGFILLED	0x0008
+#define	F_QUIET		0x0010
+#define	F_RROUTE	0x0020
+#define	F_SO_DEBUG	0x0040
+#define	F_VERBOSE	0x0100
+#ifdef IPSEC
+#ifdef IPSEC_POLICY_IPSEC
+#define	F_POLICY	0x0400
+#else
+#define F_AUTHHDR	0x0200
+#define F_ENCRYPT	0x0400
+#endif /*IPSEC_POLICY_IPSEC*/
+#endif /*IPSEC*/
+#define F_NODEADDR	0x0800
+#define F_FQDN		0x1000
+#define F_INTERFACE	0x2000
+#define F_SRCADDR	0x4000
+#define F_HOSTNAME	0x10000
+#define F_FQDNOLD	0x20000
+#define F_NIGROUP	0x40000
+#define F_SUPTYPES	0x80000
+#define F_NOMINMTU	0x100000
+#define F_ONCE		0x200000
+#define F_AUDIBLE	0x400000
+#define F_MISSED	0x800000
+#define F_NOUSERDATA	(F_NODEADDR | F_FQDN | F_FQDNOLD | F_SUPTYPES)
+u_int options;
+
+#define IN6LEN		sizeof(struct in6_addr)
+#define SA6LEN		sizeof(struct sockaddr_in6)
+#define DUMMY_PORT	10101
+
+#define SIN6(s)	((struct sockaddr_in6 *)(s))
+
+/*
+ * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
+ * number of received sequence numbers we can keep track of.  Change 128
+ * to 8192 for complete accuracy...
+ */
+#define	MAX_DUP_CHK	(8 * 8192)
+int mx_dup_ck = MAX_DUP_CHK;
+char rcvd_tbl[MAX_DUP_CHK / 8];
+
+struct addrinfo *res;
+struct sockaddr_in6 dst;	/* who to ping6 */
+struct sockaddr_in6 src;	/* src addr of this packet */
+socklen_t srclen;
+int datalen = DEFDATALEN;
+int s;				/* socket file descriptor */
+u_char outpack[MAXPACKETLEN];
+char BSPACE = '\b';		/* characters written for flood */
+char BBELL = '\a';		/* characters written for AUDIBLE */
+char DOT = '.';
+char *hostname;
+int ident;			/* process id to identify our packets */
+u_int8_t nonce[8];		/* nonce field for node information */
+int hoplimit = -1;		/* hoplimit */
+int pathmtu = 0;		/* path MTU for the destination.  0 = unspec. */
+
+/* counters */
+long nmissedmax;		/* max value of ntransmitted - nreceived - 1 */
+long npackets;			/* max packets to transmit */
+long nreceived;			/* # of packets we got back */
+long nrepeats;			/* number of duplicates */
+long ntransmitted;		/* sequence # for outbound packets = #sent */
+struct timeval interval = {1, 0}; /* interval between packets */
+
+/* timing */
+int timing;			/* flag to do timing */
+double tmin = 999999999.0;	/* minimum round trip time */
+double tmax = 0.0;		/* maximum round trip time */
+double tsum = 0.0;		/* sum of all times, for doing average */
+double tsumsq = 0.0;		/* sum of all times squared, for std. dev. */
+
+/* for node addresses */
+u_short naflags;
+
+/* for ancillary data(advanced API) */
+struct msghdr smsghdr;
+struct iovec smsgiov;
+char *scmsg = 0;
+
+volatile sig_atomic_t seenalrm;
+volatile sig_atomic_t seenint;
+#ifdef SIGINFO
+volatile sig_atomic_t seeninfo;
+#endif
+
+int	 main(int, char *[]);
+void	 fill(char *, char *);
+int	 get_hoplim(struct msghdr *);
+int	 get_pathmtu(struct msghdr *);
+struct in6_pktinfo *get_rcvpktinfo(struct msghdr *);
+void	 onsignal(int);
+void	 retransmit(void);
+void	 onint(int);
+size_t	 pingerlen(void);
+int	 pinger(void);
+const char *pr_addr(struct sockaddr *, int);
+void	 pr_icmph(struct icmp6_hdr *, u_char *);
+void	 pr_iph(struct ip6_hdr *);
+void	 pr_suptypes(struct icmp6_nodeinfo *, size_t);
+void	 pr_nodeaddr(struct icmp6_nodeinfo *, int);
+int	 myechoreply(const struct icmp6_hdr *);
+int	 mynireply(const struct icmp6_nodeinfo *);
+char *dnsdecode(const u_char **, const u_char *, const u_char *,
+	char *, size_t);
+void	 pr_pack(u_char *, int, struct msghdr *);
+void	 pr_exthdrs(struct msghdr *);
+void	 pr_ip6opt(void *, size_t);
+void	 pr_rthdr(void *, size_t);
+int	 pr_bitrange(u_int32_t, int, int);
+void	 pr_retip(struct ip6_hdr *, u_char *);
+void	 summary(void);
+void	 tvsub(struct timeval *, struct timeval *);
+int	 setpolicy(int, char *);
+char	*nigroup(char *);
+void	 usage(void);
+
+
+static void err(int exitval, char *where)
+{
+	printf("error: %s: error %d [%s]\n", where, errno, strerror(errno));
+	exit(exitval);
+}
+
+static void errx(int exitval, char *fmt_string, ...)
+{
+	va_list list;
+	va_start(list, fmt_string);
+	printf("error: ");
+	vprintf(fmt_string, list);
+	printf("\n");
+	va_end(list);
+	exit(exitval);
+}
+
+static void warn(char *where)
+{
+	printf("warning: %s: error %d [%s]\n", where, errno, strerror(errno));
+}
+
+static void warnx(char *fmt_string, ...)
+{
+	va_list list;
+	va_start(list, fmt_string);
+	printf("warning: ");
+	vprintf(fmt_string, list);
+	printf("\n");
+}
+
+
+int
+main(argc, argv)
+	int argc;
+	char *argv[];
+{
+	struct itimerval itimer;
+	struct sockaddr_in6 from;
+#ifndef HAVE_ARC4RANDOM
+	struct timeval seed;
+#endif
+#ifdef HAVE_POLL_H
+	int timeout;
+#else
+	struct timeval timeout, *tv;
+#endif
+	struct addrinfo hints;
+#ifdef HAVE_POLL_H
+	struct pollfd fdmaskp[1];
+#else
+	fd_set *fdmaskp;
+	int fdmasks;
+#endif
+	int cc, i;
+	int ch, hold, packlen, preload, optval, ret_ga;
+	u_char *datap, *packet;
+	char *e, *target, *ifname = NULL;
+	int ip6optlen = 0;
+	struct cmsghdr *scmsgp = NULL;
+	struct cmsghdr *cm;
+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
+	u_long lsockbufsize;
+	int sockbufsize = 0;
+#endif
+	int usepktinfo = 0;
+	struct in6_pktinfo *pktinfo = NULL;
+#ifdef IPSEC_POLICY_IPSEC
+	char *policy_in = NULL;
+	char *policy_out = NULL;
+#endif
+	double intval;
+#ifdef IPV6_USE_MIN_MTU
+	int mflag = 0;
+#endif
+
+	/* just to be sure */
+	memset(&smsghdr, 0, sizeof(smsghdr));
+	memset(&smsgiov, 0, sizeof(smsgiov));
+
+	preload = 0;
+	datap = &outpack[ICMP6ECHOLEN + ICMP6ECHOTMLEN];
+#ifndef IPSEC
+#define ADDOPTS
+#else
+#ifdef IPSEC_POLICY_IPSEC
+#define ADDOPTS	"P:"
+#else
+#define ADDOPTS	"AE"
+#endif /*IPSEC_POLICY_IPSEC*/
+#endif
+	while ((ch = getopt(argc, argv,
+	    "a:b:c:dfHh:I:i:l:mnop:qrRS:s:tvwW" ADDOPTS)) != -1) {
+#undef ADDOPTS
+		switch (ch) {
+		case 'a':
+		{
+			char *cp;
+
+			options &= ~F_NOUSERDATA;
+			options |= F_NODEADDR;
+			for (cp = optarg; *cp != '\0'; cp++) {
+				switch (*cp) {
+				case 'a':
+					naflags |= NI_NODEADDR_FLAG_ALL;
+					break;
+				case 'c':
+				case 'C':
+					naflags |= NI_NODEADDR_FLAG_COMPAT;
+					break;
+				case 'l':
+				case 'L':
+					naflags |= NI_NODEADDR_FLAG_LINKLOCAL;
+					break;
+				case 's':
+				case 'S':
+					naflags |= NI_NODEADDR_FLAG_SITELOCAL;
+					break;
+				case 'g':
+				case 'G':
+					naflags |= NI_NODEADDR_FLAG_GLOBAL;
+					break;
+				case 'A': /* experimental. not in the spec */
+#ifdef NI_NODEADDR_FLAG_ANYCAST
+					naflags |= NI_NODEADDR_FLAG_ANYCAST;
+					break;
+#else
+					errx(1,
+"-a A is not supported on the platform");
+					/*NOTREACHED*/
+#endif
+				default:
+					usage();
+					/*NOTREACHED*/
+				}
+			}
+			break;
+		}
+		case 'b':
+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
+			errno = 0;
+			e = NULL;
+			lsockbufsize = strtoul(optarg, &e, 10);
+			sockbufsize = lsockbufsize;
+			if (errno || !*optarg || *e ||
+			    sockbufsize != lsockbufsize)
+				errx(1, "invalid socket buffer size");
+#else
+			errx(1,
+"-b option ignored: SO_SNDBUF/SO_RCVBUF socket options not supported");
+#endif
+			break;
+		case 'c':
+			npackets = strtol(optarg, &e, 10);
+			if (npackets <= 0 || *optarg == '\0' || *e != '\0')
+				errx(1,
+				    "illegal number of packets -- %s", optarg);
+			break;
+		case 'd':
+			options |= F_SO_DEBUG;
+			break;
+		case 'f':
+			if (getuid()) {
+				errno = EPERM;
+				errx(1, "Must be superuser to flood ping");
+			}
+			options |= F_FLOOD;
+			setbuf(stdout, (char *)NULL);
+			break;
+#ifdef undefined
+		case 'g':
+			gateway = optarg;
+			break;
+#endif
+		case 'H':
+			options |= F_HOSTNAME;
+			break;
+		case 'h':		/* hoplimit */
+			hoplimit = strtol(optarg, &e, 10);
+			if (*optarg == '\0' || *e != '\0')
+				errx(1, "illegal hoplimit %s", optarg);
+			if (255 < hoplimit || hoplimit < -1)
+				errx(1,
+				    "illegal hoplimit -- %s", optarg);
+			break;
+		case 'I':
+			ifname = optarg;
+			options |= F_INTERFACE;
+#ifndef USE_SIN6_SCOPE_ID
+			usepktinfo++;
+#endif
+			break;
+		case 'i':		/* wait between sending packets */
+			intval = strtod(optarg, &e);
+			if (*optarg == '\0' || *e != '\0')
+				errx(1, "illegal timing interval %s", optarg);
+			if (intval < 1 && getuid()) {
+				errx(1, "%s: only root may use interval < 1s",
+				    strerror(EPERM));
+			}
+			interval.tv_sec = (long)intval;
+			interval.tv_usec =
+			    (long)((intval - interval.tv_sec) * 1000000);
+			if (interval.tv_sec < 0)
+				errx(1, "illegal timing interval %s", optarg);
+			/* less than 1/hz does not make sense */
+			if (interval.tv_sec == 0 && interval.tv_usec < 1) {
+				warnx("too small interval, raised to .000001");
+				interval.tv_usec = 1;
+			}
+			options |= F_INTERVAL;
+			break;
+		case 'l':
+			if (getuid()) {
+				errno = EPERM;
+				errx(1, "Must be superuser to preload");
+			}
+			preload = strtol(optarg, &e, 10);
+			if (preload < 0 || *optarg == '\0' || *e != '\0')
+				errx(1, "illegal preload value -- %s", optarg);
+			break;
+		case 'm':
+#ifdef IPV6_USE_MIN_MTU
+			mflag++;
+			break;
+#else
+			errx(1, "-%c is not supported on this platform", ch);
+			/*NOTREACHED*/
+#endif
+		case 'n':
+			options &= ~F_HOSTNAME;
+			break;
+#ifdef undefined
+		case 'N':
+			options |= F_NIGROUP;
+			break;
+#endif
+		case 'o':
+			options |= F_ONCE;
+			break;
+		case 'p':		/* fill buffer with user pattern */
+			options |= F_PINGFILLED;
+			fill((char *)datap, optarg);
+				break;
+		case 'q':
+			options |= F_QUIET;
+			break;
+		case 'r':
+			options |= F_AUDIBLE;
+			break;
+		case 'R':
+			options |= F_MISSED;
+			break;
+		case 'S':
+			memset(&hints, 0, sizeof(struct addrinfo));
+			hints.ai_flags = AI_NUMERICHOST; /* allow hostname? */
+			hints.ai_family = AF_INET6;
+			hints.ai_socktype = SOCK_RAW;
+			hints.ai_protocol = IPPROTO_ICMPV6;
+
+			ret_ga = getaddrinfo(optarg, NULL, &hints, &res);
+			if (ret_ga) {
+				errx(1, "invalid source address: %s",
+				     gai_strerror(ret_ga));
+			}
+			/*
+			 * res->ai_family must be AF_INET6 and res->ai_addrlen
+			 * must be sizeof(src).
+			 */
+			memcpy(&src, res->ai_addr, res->ai_addrlen);
+			srclen = res->ai_addrlen;
+			freeaddrinfo(res);
+			options |= F_SRCADDR;
+			break;
+		case 's':		/* size of packet to send */
+			datalen = strtol(optarg, &e, 10);
+			if (datalen <= 0 || *optarg == '\0' || *e != '\0')
+				errx(1, "illegal datalen value -- %s", optarg);
+			if (datalen > MAXDATALEN) {
+				errx(1,
+				    "datalen value too large, maximum is %d",
+				    MAXDATALEN);
+			}
+			break;
+		case 't':
+			options &= ~F_NOUSERDATA;
+			options |= F_SUPTYPES;
+			break;
+		case 'v':
+			options |= F_VERBOSE;
+			break;
+		case 'w':
+			options &= ~F_NOUSERDATA;
+			options |= F_FQDN;
+			break;
+		case 'W':
+			options &= ~F_NOUSERDATA;
+			options |= F_FQDNOLD;
+			break;
+#ifdef IPSEC
+#ifdef IPSEC_POLICY_IPSEC
+		case 'P':
+			options |= F_POLICY;
+			if (!strncmp("in", optarg, 2)) {
+				if ((policy_in = strdup(optarg)) == NULL)
+					errx(1, "strdup");
+			} else if (!strncmp("out", optarg, 3)) {
+				if ((policy_out = strdup(optarg)) == NULL)
+					errx(1, "strdup");
+			} else
+				errx(1, "invalid security policy");
+			break;
+#else
+		case 'A':
+			options |= F_AUTHHDR;
+			break;
+		case 'E':
+			options |= F_ENCRYPT;
+			break;
+#endif /*IPSEC_POLICY_IPSEC*/
+#endif /*IPSEC*/
+		default:
+			usage();
+			/*NOTREACHED*/
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+
+	if (argc < 1) {
+		usage();
+		/*NOTREACHED*/
+	}
+
+#ifdef undefined
+	if (options & F_NIGROUP) {
+		target = nigroup(argv[argc - 1]);
+		if (target == NULL) {
+			usage();
+			/*NOTREACHED*/
+		}
+	} else
+#endif
+		target = argv[argc - 1];
+
+	/* getaddrinfo */
+	memset(&hints, 0, sizeof(struct addrinfo));
+	hints.ai_flags = AI_CANONNAME;
+	hints.ai_family = AF_INET6;
+	hints.ai_socktype = SOCK_RAW;
+	hints.ai_protocol = IPPROTO_ICMPV6;
+
+	ret_ga = getaddrinfo(target, NULL, &hints, &res);
+	if (ret_ga)
+		errx(1, "%s", gai_strerror(ret_ga));
+	if (res->ai_canonname)
+		hostname = res->ai_canonname;
+	else
+		hostname = target;
+
+	if (!res->ai_addr)
+		errx(1, "getaddrinfo failed");
+
+	(void)memcpy(&dst, res->ai_addr, res->ai_addrlen);
+
+	if ((s = socket(res->ai_family, res->ai_socktype,
+	    res->ai_protocol)) < 0)
+		err(1, "socket");
+
+	/* set the source address if specified. */
+	if ((options & F_SRCADDR) &&
+	    bind(s, (struct sockaddr *)&src, srclen) != 0) {
+		err(1, "bind");
+	}
+
+#ifdef undefined
+	/* set the gateway (next hop) if specified */
+	if (gateway) {
+		struct addrinfo ghints, *gres;
+		int error;
+
+		memset(&ghints, 0, sizeof(ghints));
+		ghints.ai_family = AF_INET6;
+		ghints.ai_socktype = SOCK_RAW;
+		ghints.ai_protocol = IPPROTO_ICMPV6;
+
+		error = getaddrinfo(gateway, NULL, &hints, &gres);
+		if (error) {
+			errx(1, "getaddrinfo for the gateway %s: %s",
+			     gateway, gai_strerror(error));
+		}
+		if (gres->ai_next && (options & F_VERBOSE))
+			warnx("gateway resolves to multiple addresses");
+
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_NEXTHOP,
+			       gres->ai_addr, gres->ai_addrlen)) {
+			err(1, "setsockopt(IPV6_NEXTHOP)");
+		}
+
+		freeaddrinfo(gres);
+	}
+#endif
+
+	/*
+	 * let the kerel pass extension headers of incoming packets,
+	 * for privileged socket options
+	 */
+	if ((options & F_VERBOSE) != 0) {
+		int opton = 1;
+
+#ifdef IPV6_RECVHOPOPTS
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &opton,
+		    sizeof(opton)))
+			err(1, "setsockopt(IPV6_RECVHOPOPTS)");
+#endif
+#ifdef IPV6_RECVDSTOPTS
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &opton,
+		    sizeof(opton)))
+			err(1, "setsockopt(IPV6_RECVDSTOPTS)");
+#endif
+#ifdef IPV6_RECVRTHDRDSTOPTS
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDRDSTOPTS, &opton,
+		    sizeof(opton)))
+			err(1, "setsockopt(IPV6_RECVRTHDRDSTOPTS)");
+#endif
+	}
+
+	if ((options & F_FLOOD) && (options & F_INTERVAL))
+		errx(1, "-f and -i incompatible options");
+
+	if ((options & F_NOUSERDATA) == 0) {
+		if (datalen >= sizeof(struct tv32)) {
+			/* we can time transfer */
+			timing = 1;
+		} else
+			timing = 0;
+		/* in F_VERBOSE case, we may get non-echoreply packets*/
+		if (options & F_VERBOSE)
+			packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;
+		else
+			packlen = datalen + IP6LEN + ICMP6ECHOLEN + EXTRA;
+	} else {
+		/* suppress timing for node information query */
+		timing = 0;
+		datalen = 2048;
+		packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;
+	}
+
+	if (!(packet = (u_char *)malloc((u_int)packlen)))
+		err(1, "Unable to allocate packet");
+	if (!(options & F_PINGFILLED))
+		for (i = ICMP6ECHOLEN; i < packlen; ++i)
+			*datap++ = i;
+
+	ident = getpid() & 0xFFFF;
+#ifndef HAVE_ARC4RANDOM
+	gettimeofday(&seed, NULL);
+	srand((unsigned int)(seed.tv_sec ^ seed.tv_usec ^ (long)ident));
+	memset(nonce, 0, sizeof(nonce));
+	for (i = 0; i < sizeof(nonce); i += sizeof(int))
+		*((int *)&nonce[i]) = rand();
+#else
+	memset(nonce, 0, sizeof(nonce));
+	for (i = 0; i < sizeof(nonce); i += sizeof(u_int32_t))
+		*((u_int32_t *)&nonce[i]) = arc4random();
+#endif
+
+	hold = 1;
+
+	if (options & F_SO_DEBUG)
+		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&hold,
+		    sizeof(hold));
+	optval = IPV6_DEFHLIM;
+	if (IN6_IS_ADDR_MULTICAST(&dst.sin6_addr))
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "IPV6_MULTICAST_HOPS");
+#ifdef IPV6_USE_MIN_MTU
+	if (mflag != 1) {
+		optval = mflag > 1 ? 0 : 1;
+
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "setsockopt(IPV6_USE_MIN_MTU)");
+	}
+#ifdef IPV6_RECVPATHMTU
+	else {
+		optval = 1;
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPATHMTU,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "setsockopt(IPV6_RECVPATHMTU)");
+	}
+#endif /* IPV6_RECVPATHMTU */
+#endif /* IPV6_USE_MIN_MTU */
+
+#ifdef IPSEC
+#ifdef IPSEC_POLICY_IPSEC
+	if (options & F_POLICY) {
+		if (setpolicy(s, policy_in) < 0)
+			errx(1, "%s", ipsec_strerror());
+		if (setpolicy(s, policy_out) < 0)
+			errx(1, "%s", ipsec_strerror());
+	}
+#else
+	if (options & F_AUTHHDR) {
+		optval = IPSEC_LEVEL_REQUIRE;
+#ifdef IPV6_AUTH_TRANS_LEVEL
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_TRANS_LEVEL,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "setsockopt(IPV6_AUTH_TRANS_LEVEL)");
+#else /* old def */
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_LEVEL,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "setsockopt(IPV6_AUTH_LEVEL)");
+#endif
+	}
+	if (options & F_ENCRYPT) {
+		optval = IPSEC_LEVEL_REQUIRE;
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_ESP_TRANS_LEVEL,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "setsockopt(IPV6_ESP_TRANS_LEVEL)");
+	}
+#endif /*IPSEC_POLICY_IPSEC*/
+#endif
+
+#ifdef ICMP6_FILTER
+    {
+	struct icmp6_filter filt;
+	if (!(options & F_VERBOSE)) {
+		ICMP6_FILTER_SETBLOCKALL(&filt);
+		if ((options & F_FQDN) || (options & F_FQDNOLD) ||
+		    (options & F_NODEADDR) || (options & F_SUPTYPES))
+			ICMP6_FILTER_SETPASS(ICMP6_NI_REPLY, &filt);
+		else
+			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filt);
+	} else {
+		ICMP6_FILTER_SETPASSALL(&filt);
+	}
+	if (setsockopt(s, IPPROTO_ICMPV6, ICMP6_FILTER, &filt,
+	    sizeof(filt)) < 0)
+		err(1, "setsockopt(ICMP6_FILTER)");
+    }
+#endif /*ICMP6_FILTER*/
+
+	/* let the kerel pass extension headers of incoming packets */
+	if ((options & F_VERBOSE) != 0) {
+		int opton = 1;
+
+#ifdef IPV6_RECVRTHDR
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDR, &opton,
+		    sizeof(opton)))
+			err(1, "setsockopt(IPV6_RECVRTHDR)");
+#endif
+	}
+
+/*
+	optval = 1;
+	if (IN6_IS_ADDR_MULTICAST(&dst.sin6_addr))
+		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
+		    &optval, sizeof(optval)) == -1)
+			err(1, "IPV6_MULTICAST_LOOP");
+*/
+
+	/* Specify the outgoing interface and/or the source address */
+	if (usepktinfo)
+		ip6optlen += CMSG_SPACE(sizeof(struct in6_pktinfo));
+
+	if (hoplimit != -1)
+		ip6optlen += CMSG_SPACE(sizeof(int));
+
+	/* set IP6 packet options */
+	if (ip6optlen) {
+		if ((scmsg = (char *)malloc(ip6optlen)) == 0)
+			errx(1, "can't allocate enough memory");
+		smsghdr.msg_control = (caddr_t)scmsg;
+		smsghdr.msg_controllen = ip6optlen;
+		scmsgp = (struct cmsghdr *)scmsg;
+	}
+	if (usepktinfo) {
+		pktinfo = (struct in6_pktinfo *)(CMSG_DATA(scmsgp));
+		memset(pktinfo, 0, sizeof(*pktinfo));
+		scmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+		scmsgp->cmsg_level = IPPROTO_IPV6;
+		scmsgp->cmsg_type = IPV6_PKTINFO;
+		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
+	}
+
+	/* set the outgoing interface */
+	if (ifname) {
+#ifndef USE_SIN6_SCOPE_ID
+		/* pktinfo must have already been allocated */
+		if ((pktinfo->ipi6_ifindex = if_nametoindex(ifname)) == 0)
+			errx(1, "%s: invalid interface name", ifname);
+#else
+		if ((dst.sin6_scope_id = if_nametoindex(ifname)) == 0)
+			errx(1, "%s: invalid interface name", ifname);
+#endif
+	}
+	if (hoplimit != -1) {
+		scmsgp->cmsg_len = CMSG_LEN(sizeof(int));
+		scmsgp->cmsg_level = IPPROTO_IPV6;
+		scmsgp->cmsg_type = IPV6_HOPLIMIT;
+		*(int *)(CMSG_DATA(scmsgp)) = hoplimit;
+
+		scmsgp = CMSG_NXTHDR(&smsghdr, scmsgp);
+	}
+
+	if (!(options & F_SRCADDR)) {
+		/*
+		 * get the source address. XXX since we revoked the root
+		 * privilege, we cannot use a raw socket for this.
+		 */
+		int dummy;
+		socklen_t len = sizeof(src);
+
+		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
+			err(1, "UDP socket");
+
+		src.sin6_family = AF_INET6;
+		src.sin6_addr = dst.sin6_addr;
+		src.sin6_port = ntohs(DUMMY_PORT);
+		src.sin6_scope_id = dst.sin6_scope_id;
+
+#ifdef USE_RFC2292BIS
+		if (pktinfo &&
+		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTINFO,
+		    (void *)pktinfo, sizeof(*pktinfo)))
+			err(1, "UDP setsockopt(IPV6_PKTINFO)");
+
+		if (hoplimit != -1 &&
+		    setsockopt(dummy, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
+		    (void *)&hoplimit, sizeof(hoplimit)))
+			err(1, "UDP setsockopt(IPV6_UNICAST_HOPS)");
+
+		if (hoplimit != -1 &&
+		    setsockopt(dummy, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+		    (void *)&hoplimit, sizeof(hoplimit)))
+			err(1, "UDP setsockopt(IPV6_MULTICAST_HOPS)");
+
+#else  /* old advanced API */
+		if (smsghdr.msg_control &&
+		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTOPTIONS,
+		    (void *)smsghdr.msg_control, smsghdr.msg_controllen))
+			err(1, "UDP setsockopt(IPV6_PKTOPTIONS)");
+#endif
+
+		if (connect(dummy, (struct sockaddr *)&src, len) < 0)
+			err(1, "UDP connect");
+
+		if (getsockname(dummy, (struct sockaddr *)&src, &len) < 0)
+			err(1, "getsockname");
+
+		close(dummy);
+	}
+
+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
+	if (sockbufsize) {
+		if (datalen > sockbufsize)
+			warnx("you need -b to increase socket buffer size");
+		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &sockbufsize,
+		    sizeof(sockbufsize)) < 0)
+			err(1, "setsockopt(SO_SNDBUF)");
+		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &sockbufsize,
+		    sizeof(sockbufsize)) < 0)
+			err(1, "setsockopt(SO_RCVBUF)");
+	}
+	else {
+		if (datalen > 8 * 1024)	/*XXX*/
+			warnx("you need -b to increase socket buffer size");
+		/*
+		 * When pinging the broadcast address, you can get a lot of
+		 * answers. Doing something so evil is useful if you are trying
+		 * to stress the ethernet, or just want to fill the arp cache
+		 * to get some stuff for /etc/ethers.
+		 */
+		hold = 48 * 1024;
+		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&hold,
+		    sizeof(hold));
+	}
+#endif
+
+	optval = 1;
+//#ifndef USE_SIN6_SCOPE_ID
+#ifdef IPV6_RECVPKTINFO
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &optval,
+	    sizeof(optval)) < 0)
+		warn("setsockopt(IPV6_RECVPKTINFO)"); /* XXX err? */
+#else  /* old adv. API */
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &optval,
+	    sizeof(optval)) < 0)
+		warn("setsockopt(IPV6_PKTINFO)"); /* XXX err? */
+#endif
+//#endif /* USE_SIN6_SCOPE_ID */
+#ifdef IPV6_RECVHOPLIMIT
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &optval,
+	    sizeof(optval)) < 0)
+		warn("setsockopt(IPV6_RECVHOPLIMIT)"); /* XXX err? */
+#else  /* old adv. API */
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &optval,
+	    sizeof(optval)) < 0)
+		warn("setsockopt(IPV6_HOPLIMIT)"); /* XXX err? */
+#endif
+
+	if (hoplimit != -1 &&
+		setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
+			(void *)&hoplimit, sizeof(hoplimit)))
+		err(1, "setsockopt(IPV6_UNICAST_HOPS)");
+
+	if (hoplimit != -1 &&
+		setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+			(void *)&hoplimit, sizeof(hoplimit)))
+		err(1, "setsockopt(IPV6_MULTICAST_HOPS)");
+
+
+	printf("PING6(%lu=40+8+%lu bytes) ", (unsigned long)(40 + pingerlen()),
+	    (unsigned long)(pingerlen() - 8));
+	printf("%s --> ", pr_addr((struct sockaddr *)&src, sizeof(src)));
+	printf("%s\n", pr_addr((struct sockaddr *)&dst, sizeof(dst)));
+
+	while (preload--)		/* Fire off them quickies. */
+		(void)pinger();
+
+	(void)signal(SIGINT, onsignal);
+#ifdef SIGINFO
+	(void)signal(SIGINFO, onsignal);
+#endif
+
+	if ((options & F_FLOOD) == 0) {
+		(void)signal(SIGALRM, onsignal);
+		itimer.it_interval = interval;
+		itimer.it_value = interval;
+		(void)setitimer(ITIMER_REAL, &itimer, NULL);
+		if (ntransmitted == 0)
+			retransmit();
+	}
+
+#ifndef HAVE_POLL_H
+	fdmasks = howmany(s + 1, NFDBITS) * sizeof(fd_mask);
+	if ((fdmaskp = malloc(fdmasks)) == NULL)
+		err(1, "malloc");
+#endif
+
+	seenalrm = seenint = 0;
+#ifdef SIGINFO
+	seeninfo = 0;
+#endif
+
+	/* For control (ancillary) data received from recvmsg() */
+	cm = (struct cmsghdr *)malloc(CONTROLLEN);
+	if (cm == NULL)
+		err(1, "malloc");
+
+	for (;;) {
+		struct msghdr m;
+		struct iovec iov[2];
+
+		/* signal handling */
+		if (seenalrm) {
+			/* last packet sent, timeout reached? */
+			if (npackets && ntransmitted >= npackets)
+				break;
+			retransmit();
+			seenalrm = 0;
+			continue;
+		}
+		if (seenint) {
+			onint(SIGINT);
+			seenint = 0;
+			continue;
+		}
+#ifdef SIGINFO
+		if (seeninfo) {
+			summary();
+			seeninfo = 0;
+			continue;
+		}
+#endif
+
+		if (options & F_FLOOD) {
+			(void)pinger();
+#ifdef HAVE_POLL_H
+			timeout = 10;
+#else
+			timeout.tv_sec = 0;
+			timeout.tv_usec = 10000;
+			tv = &timeout;
+#endif
+		} else {
+#ifdef HAVE_POLL_H
+			timeout = -1;
+#else
+			tv = NULL;
+#endif
+		}
+#ifdef HAVE_POLL_H
+		fdmaskp[0].fd = s;
+		fdmaskp[0].events = POLLIN;
+		cc = poll(fdmaskp, 1, timeout);
+#else
+		memset(fdmaskp, 0, fdmasks);
+		FD_SET(s, fdmaskp);
+		cc = select(s + 1, fdmaskp, NULL, NULL, tv);
+#endif
+		if (cc < 0) {
+			if (errno != EINTR) {
+#ifdef HAVE_POLL_H
+				warn("poll");
+#else
+				warn("select");
+#endif
+				sleep(1);
+			}
+			continue;
+		} else if (cc == 0)
+			continue;
+
+		m.msg_name = (caddr_t)&from;
+		m.msg_namelen = sizeof(from);
+		memset(&iov, 0, sizeof(iov));
+		iov[0].iov_base = (caddr_t)packet;
+		iov[0].iov_len = packlen;
+		m.msg_iov = iov;
+		m.msg_iovlen = 1;
+		memset(cm, 0, CONTROLLEN);
+		m.msg_control = (void *)cm;
+		m.msg_controllen = CONTROLLEN;
+
+		cc = recvmsg(s, &m, 0);
+		if (cc < 0) {
+			if (errno != EINTR) {
+				warn("recvmsg");
+				sleep(1);
+			}
+			continue;
+		} else if (cc == 0) {
+			int mtu;
+
+			/*
+			 * receive control messages only. Process the
+			 * exceptions (currently the only possiblity is
+			 * a path MTU notification.)
+			 */
+			if ((mtu = get_pathmtu(&m)) > 0) {
+				if ((options & F_VERBOSE) != 0) {
+					printf("new path MTU (%d) is "
+					    "notified\n", mtu);
+				}
+			}
+			continue;
+		} else {
+			/*
+			 * an ICMPv6 message (probably an echoreply) arrived.
+			 */
+			pr_pack(packet, cc, &m);
+		}
+		if (((options & F_ONCE) != 0 && nreceived > 0) ||
+		    (npackets > 0 && nreceived >= npackets))
+			break;
+		if (ntransmitted - nreceived - 1 > nmissedmax) {
+			nmissedmax = ntransmitted - nreceived - 1;
+			if (options & F_MISSED)
+				(void)write(STDOUT_FILENO, &BBELL, 1);
+		}
+	}
+	summary();
+	exit(nreceived == 0 ? 2 : 0);
+}
+
+void
+onsignal(sig)
+	int sig;
+{
+
+	switch (sig) {
+	case SIGALRM:
+		seenalrm++;
+		break;
+	case SIGINT:
+		seenint++;
+		break;
+#ifdef SIGINFO
+	case SIGINFO:
+		seeninfo++;
+		break;
+#endif
+	}
+}
+
+/*
+ * retransmit --
+ *	This routine transmits another ping6.
+ */
+void
+retransmit()
+{
+	struct itimerval itimer;
+
+	if (pinger() == 0)
+		return;
+
+	/*
+	 * If we're not transmitting any more packets, change the timer
+	 * to wait two round-trip times if we've received any packets or
+	 * ten seconds if we haven't.
+	 */
+#define	MAXWAIT		10
+	if (nreceived) {
+		itimer.it_value.tv_sec =  2 * tmax / 1000;
+		if (itimer.it_value.tv_sec == 0)
+			itimer.it_value.tv_sec = 1;
+	} else
+		itimer.it_value.tv_sec = MAXWAIT;
+	itimer.it_interval.tv_sec = 0;
+	itimer.it_interval.tv_usec = 0;
+	itimer.it_value.tv_usec = 0;
+
+	(void)signal(SIGALRM, onsignal);
+	(void)setitimer(ITIMER_REAL, &itimer, NULL);
+}
+
+/*
+ * pinger --
+ *	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
+ * will be added on by the kernel.  The ID field is our UNIX process ID,
+ * and the sequence number is an ascending integer.  The first 8 bytes
+ * of the data portion are used to hold a UNIX "timeval" struct in VAX
+ * byte-order, to compute the round-trip time.
+ */
+size_t
+pingerlen()
+{
+	size_t l;
+
+	if (options & F_FQDN)
+		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
+	else if (options & F_FQDNOLD)
+		l = ICMP6_NIQLEN;
+	else if (options & F_NODEADDR)
+		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
+	else if (options & F_SUPTYPES)
+		l = ICMP6_NIQLEN;
+	else
+		l = ICMP6ECHOLEN + datalen;
+
+	return l;
+}
+
+int
+pinger()
+{
+	struct icmp6_hdr *icp;
+	struct iovec iov[2];
+	int i, cc;
+	struct icmp6_nodeinfo *nip;
+	int seq;
+
+	if (npackets && ntransmitted >= npackets)
+		return(-1);	/* no more transmission */
+
+	icp = (struct icmp6_hdr *)outpack;
+	nip = (struct icmp6_nodeinfo *)outpack;
+	memset(icp, 0, sizeof(*icp));
+	icp->icmp6_cksum = 0;
+	seq = ntransmitted++;
+	CLR(seq % mx_dup_ck);
+
+	if (options & F_FQDN) {
+		icp->icmp6_type = ICMP6_NI_QUERY;
+		icp->icmp6_code = ICMP6_NI_SUBJ_IPV6;
+		nip->ni_qtype = htons(NI_QTYPE_FQDN);
+		nip->ni_flags = htons(0);
+
+		memcpy(nip->icmp6_ni_nonce, nonce,
+		    sizeof(nip->icmp6_ni_nonce));
+		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);
+
+		memcpy(&outpack[ICMP6_NIQLEN], &dst.sin6_addr,
+		    sizeof(dst.sin6_addr));
+		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
+		datalen = 0;
+	} else if (options & F_FQDNOLD) {
+		/* packet format in 03 draft - no Subject data on queries */
+		icp->icmp6_type = ICMP6_NI_QUERY;
+		icp->icmp6_code = 0;	/* code field is always 0 */
+		nip->ni_qtype = htons(NI_QTYPE_FQDN);
+		nip->ni_flags = htons(0);
+
+		memcpy(nip->icmp6_ni_nonce, nonce,
+		    sizeof(nip->icmp6_ni_nonce));
+		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);
+
+		cc = ICMP6_NIQLEN;
+		datalen = 0;
+	} else if (options & F_NODEADDR) {
+		icp->icmp6_type = ICMP6_NI_QUERY;
+		icp->icmp6_code = ICMP6_NI_SUBJ_IPV6;
+		nip->ni_qtype = htons(NI_QTYPE_NODEADDR);
+		nip->ni_flags = naflags;
+
+		memcpy(nip->icmp6_ni_nonce, nonce,
+		    sizeof(nip->icmp6_ni_nonce));
+		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);
+
+		memcpy(&outpack[ICMP6_NIQLEN], &dst.sin6_addr,
+		    sizeof(dst.sin6_addr));
+		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);
+		datalen = 0;
+	} else if (options & F_SUPTYPES) {
+		icp->icmp6_type = ICMP6_NI_QUERY;
+		icp->icmp6_code = ICMP6_NI_SUBJ_FQDN;	/*empty*/
+		nip->ni_qtype = htons(NI_QTYPE_SUPTYPES);
+		/* we support compressed bitmap */
+		nip->ni_flags = NI_SUPTYPE_FLAG_COMPRESS;
+
+		memcpy(nip->icmp6_ni_nonce, nonce,
+		    sizeof(nip->icmp6_ni_nonce));
+		*(u_int16_t *)nip->icmp6_ni_nonce = ntohs(seq);
+		cc = ICMP6_NIQLEN;
+		datalen = 0;
+	} else {
+		icp->icmp6_type = ICMP6_ECHO_REQUEST;
+		icp->icmp6_code = 0;
+		icp->icmp6_id = htons(ident);
+		icp->icmp6_seq = ntohs(seq);
+		if (timing) {
+			struct timeval tv;
+			struct tv32 *tv32;
+			(void)gettimeofday(&tv, NULL);
+			tv32 = (struct tv32 *)&outpack[ICMP6ECHOLEN];
+			tv32->tv32_sec = htonl(tv.tv_sec);
+			tv32->tv32_usec = htonl(tv.tv_usec);
+		}
+		cc = ICMP6ECHOLEN + datalen;
+	}
+
+#ifdef DIAGNOSTIC
+	if (pingerlen() != cc)
+		errx(1, "internal error; length mismatch");
+#endif
+
+	smsghdr.msg_name = (caddr_t)&dst;
+	smsghdr.msg_namelen = sizeof(dst);
+	memset(&iov, 0, sizeof(iov));
+	iov[0].iov_base = (caddr_t)outpack;
+	iov[0].iov_len = cc;
+	smsghdr.msg_iov = iov;
+	smsghdr.msg_iovlen = 1;
+
+#ifdef CMSG_SENDING_UNSUPPORTED
+	smsghdr.msg_control = NULL;
+	smsghdr.msg_controllen = 0;
+#endif
+
+	i = sendmsg(s, &smsghdr, 0);
+
+	if (i < 0 || i != cc)  {
+		if (i < 0)
+			warn("sendmsg");
+		(void)printf("ping6: wrote %s %d chars, ret=%d\n",
+		    hostname, cc, i);
+	}
+	if (!(options & F_QUIET) && options & F_FLOOD)
+		(void)write(STDOUT_FILENO, &DOT, 1);
+
+	return(0);
+}
+
+int
+myechoreply(icp)
+	const struct icmp6_hdr *icp;
+{
+	if (ntohs(icp->icmp6_id) == ident)
+		return 1;
+	else
+		return 0;
+}
+
+int
+mynireply(nip)
+	const struct icmp6_nodeinfo *nip;
+{
+	if (memcmp(nip->icmp6_ni_nonce + sizeof(u_int16_t),
+	    nonce + sizeof(u_int16_t),
+	    sizeof(nonce) - sizeof(u_int16_t)) == 0)
+		return 1;
+	else
+		return 0;
+}
+
+char *
+dnsdecode(sp, ep, base, buf, bufsiz)
+	const u_char **sp;
+	const u_char *ep;
+	const u_char *base;	/*base for compressed name*/
+	char *buf;
+	size_t bufsiz;
+{
+	int i;
+	const u_char *cp;
+	char cresult[MAXDNAME + 1];
+	const u_char *comp;
+	int l;
+
+	cp = *sp;
+	*buf = '\0';
+
+	if (cp >= ep)
+		return NULL;
+	while (cp < ep) {
+		i = *cp;
+		if (i == 0 || cp != *sp) {
+			if (strlcat((char *)buf, ".", bufsiz) >= bufsiz)
+				return NULL;	/*result overrun*/
+		}
+		if (i == 0)
+			break;
+		cp++;
+
+		if ((i & 0xc0) == 0xc0 && cp - base > (i & 0x3f)) {
+			/* DNS compression */
+			if (!base)
+				return NULL;
+
+			comp = base + (i & 0x3f);
+			if (dnsdecode(&comp, cp, base, cresult,
+			    sizeof(cresult)) == NULL)
+				return NULL;
+			if (strlcat(buf, cresult, bufsiz) >= bufsiz)
+				return NULL;	/*result overrun*/
+			break;
+		} else if ((i & 0x3f) == i) {
+			if (i > ep - cp)
+				return NULL;	/*source overrun*/
+			while (i-- > 0 && cp < ep) {
+				l = snprintf(cresult, sizeof(cresult),
+				    isprint(*cp) ? "%c" : "\\%03o", *cp & 0xff);
+				if (l >= sizeof(cresult) || l < 0)
+					return NULL;
+				if (strlcat(buf, cresult, bufsiz) >= bufsiz)
+					return NULL;	/*result overrun*/
+				cp++;
+			}
+		} else
+			return NULL;	/*invalid label*/
+	}
+	if (i != 0)
+		return NULL;	/*not terminated*/
+	cp++;
+	*sp = cp;
+	return buf;
+}
+
+/*
+ * pr_pack --
+ *	Print out the packet, if it came from us.  This logic is necessary
+ * because ALL readers of the ICMP socket get a copy of ALL ICMP packets
+ * which arrive ('tis only fair).  This permits multiple copies of this
+ * program to be run without having intermingled output (or statistics!).
+ */
+void
+pr_pack(buf, cc, mhdr)
+	u_char *buf;
+	int cc;
+	struct msghdr *mhdr;
+{
+#define safeputc(c)	printf((isprint((c)) ? "%c" : "\\%03o"), c)
+	struct icmp6_hdr *icp;
+	struct icmp6_nodeinfo *ni;
+	int i;
+	int hoplim;
+	struct sockaddr *from;
+	int fromlen;
+	u_char *cp = NULL, *dp, *end = buf + cc;
+	struct in6_pktinfo *pktinfo = NULL;
+	struct timeval tv, tp;
+	struct tv32 *tpp;
+	double triptime = 0;
+	int dupflag;
+	size_t off;
+	int oldfqdn;
+	u_int16_t seq;
+	char dnsname[MAXDNAME + 1];
+
+	(void)gettimeofday(&tv, NULL);
+
+	if (!mhdr || !mhdr->msg_name ||
+	    mhdr->msg_namelen != sizeof(struct sockaddr_in6) ||
+	    ((struct sockaddr *)mhdr->msg_name)->sa_family != AF_INET6) {
+		if (options & F_VERBOSE)
+			warnx("invalid peername");
+		return;
+	}
+	from = (struct sockaddr *)mhdr->msg_name;
+	fromlen = mhdr->msg_namelen;
+	if (cc < sizeof(struct icmp6_hdr)) {
+		if (options & F_VERBOSE)
+			warnx("packet too short (%d bytes) from %s", cc,
+			    pr_addr(from, fromlen));
+		return;
+	}
+	if (((mhdr->msg_flags & MSG_CTRUNC) != 0) &&
+	    (options & F_VERBOSE) != 0)
+		warnx("some control data discarded, insufficient buffer size");
+	icp = (struct icmp6_hdr *)buf;
+	ni = (struct icmp6_nodeinfo *)buf;
+	off = 0;
+
+	if ((hoplim = get_hoplim(mhdr)) == -1) {
+		warnx("failed to get receiving hop limit");
+		return;
+	}
+	if ((pktinfo = get_rcvpktinfo(mhdr)) == NULL) {
+		warnx("failed to get receiving packet information");
+		return;
+	}
+
+	if (icp->icmp6_type == ICMP6_ECHO_REPLY && myechoreply(icp)) {
+		seq = ntohs(icp->icmp6_seq);
+		++nreceived;
+		if (timing) {
+			tpp = (struct tv32 *)(icp + 1);
+			tp.tv_sec = ntohl(tpp->tv32_sec);
+			tp.tv_usec = ntohl(tpp->tv32_usec);
+			tvsub(&tv, &tp);
+			triptime = ((double)tv.tv_sec) * 1000.0 +
+			    ((double)tv.tv_usec) / 1000.0;
+			tsum += triptime;
+			tsumsq += triptime * triptime;
+			if (triptime < tmin)
+				tmin = triptime;
+			if (triptime > tmax)
+				tmax = triptime;
+		}
+
+		if (TST(seq % mx_dup_ck)) {
+			++nrepeats;
+			--nreceived;
+			dupflag = 1;
+		} else {
+			SET(seq % mx_dup_ck);
+			dupflag = 0;
+		}
+
+		if (options & F_QUIET)
+			return;
+
+		if (options & F_FLOOD)
+			(void)write(STDOUT_FILENO, &BSPACE, 1);
+		else {
+			if (options & F_AUDIBLE)
+				(void)write(STDOUT_FILENO, &BBELL, 1);
+			(void)printf("%d bytes from %s, icmp_seq=%u", cc,
+			    pr_addr(from, fromlen), seq);
+			(void)printf(" hlim=%d", hoplim);
+			if ((options & F_VERBOSE) != 0) {
+				struct sockaddr_in6 dstsa;
+
+				memset(&dstsa, 0, sizeof(dstsa));
+				dstsa.sin6_family = AF_INET6;
+				dstsa.sin6_len = sizeof(dstsa);
+				dstsa.sin6_scope_id = pktinfo->ipi6_ifindex;
+				dstsa.sin6_addr = pktinfo->ipi6_addr;
+				(void)printf(" dst=%s",
+				    pr_addr((struct sockaddr *)&dstsa,
+				    sizeof(dstsa)));
+			}
+			if (timing)
+				(void)printf(" time=%.3f ms", triptime);
+			if (dupflag)
+				(void)printf("(DUP!)");
+			/* check the data */
+			cp = buf + off + ICMP6ECHOLEN + ICMP6ECHOTMLEN;
+			dp = outpack + ICMP6ECHOLEN + ICMP6ECHOTMLEN;
+			for (i = 8; cp < end; ++i, ++cp, ++dp) {
+				if (*cp != *dp) {
+					(void)printf("\nwrong data byte #%d should be 0x%x but was 0x%x", i, *dp, *cp);
+					break;
+				}
+			}
+		}
+	} else if (icp->icmp6_type == ICMP6_NI_REPLY && mynireply(ni)) {
+		seq = ntohs(*(u_int16_t *)ni->icmp6_ni_nonce);
+		++nreceived;
+		if (TST(seq % mx_dup_ck)) {
+			++nrepeats;
+			--nreceived;
+			dupflag = 1;
+		} else {
+			SET(seq % mx_dup_ck);
+			dupflag = 0;
+		}
+
+		if (options & F_QUIET)
+			return;
+
+		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
+
+		switch (ntohs(ni->ni_code)) {
+		case ICMP6_NI_SUCCESS:
+			break;
+		case ICMP6_NI_REFUSED:
+			printf("refused, type 0x%x", ntohs(ni->ni_type));
+			goto fqdnend;
+		case ICMP6_NI_UNKNOWN:
+			printf("unknown, type 0x%x", ntohs(ni->ni_type));
+			goto fqdnend;
+		default:
+			printf("unknown code 0x%x, type 0x%x",
+			    ntohs(ni->ni_code), ntohs(ni->ni_type));
+			goto fqdnend;
+		}
+
+		switch (ntohs(ni->ni_qtype)) {
+		case NI_QTYPE_NOOP:
+			printf("NodeInfo NOOP");
+			break;
+		case NI_QTYPE_SUPTYPES:
+			pr_suptypes(ni, end - (u_char *)ni);
+			break;
+		case NI_QTYPE_NODEADDR:
+			pr_nodeaddr(ni, end - (u_char *)ni);
+			break;
+		case NI_QTYPE_FQDN:
+		default:	/* XXX: for backward compatibility */
+			cp = (u_char *)ni + ICMP6_NIRLEN;
+			if (buf[off + ICMP6_NIRLEN] ==
+			    cc - off - ICMP6_NIRLEN - 1)
+				oldfqdn = 1;
+			else
+				oldfqdn = 0;
+			if (oldfqdn) {
+				cp++;	/* skip length */
+				while (cp < end) {
+					safeputc(*cp & 0xff);
+					cp++;
+				}
+			} else {
+				i = 0;
+				while (cp < end) {
+					if (dnsdecode((const u_char **)&cp, end,
+					    (const u_char *)(ni + 1), dnsname,
+					    sizeof(dnsname)) == NULL) {
+						printf("???");
+						break;
+					}
+					/*
+					 * name-lookup special handling for
+					 * truncated name
+					 */
+					if (cp + 1 <= end && !*cp &&
+					    strlen(dnsname) > 0) {
+						dnsname[strlen(dnsname) - 1] = '\0';
+						cp++;
+					}
+					printf("%s%s", i > 0 ? "," : "",
+					    dnsname);
+				}
+			}
+			if (options & F_VERBOSE) {
+				int32_t ttl;
+				int comma = 0;
+
+				(void)printf(" (");	/*)*/
+
+				switch (ni->ni_code) {
+				case ICMP6_NI_REFUSED:
+					(void)printf("refused");
+					comma++;
+					break;
+				case ICMP6_NI_UNKNOWN:
+					(void)printf("unknown qtype");
+					comma++;
+					break;
+				}
+
+				if ((end - (u_char *)ni) < ICMP6_NIRLEN) {
+					/* case of refusion, unknown */
+					/*(*/
+					putchar(')');
+					goto fqdnend;
+				}
+				ttl = (int32_t)ntohl(*(u_long *)&buf[off+ICMP6ECHOLEN+8]);
+				if (comma)
+					printf(",");
+				if (!(ni->ni_flags & NI_FQDN_FLAG_VALIDTTL)) {
+					(void)printf("TTL=%d:meaningless",
+					    (int)ttl);
+				} else {
+					if (ttl < 0) {
+						(void)printf("TTL=%d:invalid",
+						   ttl);
+					} else
+						(void)printf("TTL=%d", ttl);
+				}
+				comma++;
+
+				if (oldfqdn) {
+					if (comma)
+						printf(",");
+					printf("03 draft");
+					comma++;
+				} else {
+					cp = (u_char *)ni + ICMP6_NIRLEN;
+					if (cp == end) {
+						if (comma)
+							printf(",");
+						printf("no name");
+						comma++;
+					}
+				}
+
+				if (buf[off + ICMP6_NIRLEN] !=
+				    cc - off - ICMP6_NIRLEN - 1 && oldfqdn) {
+					if (comma)
+						printf(",");
+					(void)printf("invalid namelen:%d/%lu",
+					    buf[off + ICMP6_NIRLEN],
+					    (u_long)cc - off - ICMP6_NIRLEN - 1);
+					comma++;
+				}
+				/*(*/
+				putchar(')');
+			}
+		fqdnend:
+			;
+		}
+	} else {
+		/* We've got something other than an ECHOREPLY */
+		if (!(options & F_VERBOSE))
+			return;
+		(void)printf("%d bytes from %s: ", cc, pr_addr(from, fromlen));
+		pr_icmph(icp, end);
+	}
+
+	if (!(options & F_FLOOD)) {
+		(void)putchar('\n');
+		if (options & F_VERBOSE)
+			pr_exthdrs(mhdr);
+		(void)fflush(stdout);
+	}
+#undef safeputc
+}
+
+void
+pr_exthdrs(mhdr)
+	struct msghdr *mhdr;
+{
+	ssize_t	bufsize;
+	void	*bufp;
+	struct cmsghdr *cm;
+
+	bufsize = 0;
+	bufp = mhdr->msg_control;
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
+		if (cm->cmsg_level != IPPROTO_IPV6)
+			continue;
+
+		bufsize = CONTROLLEN - ((caddr_t)CMSG_DATA(cm) - (caddr_t)bufp);
+		if (bufsize <= 0)
+			continue; 
+		switch (cm->cmsg_type) {
+		case IPV6_HOPOPTS:
+			printf("  HbH Options: ");
+			pr_ip6opt(CMSG_DATA(cm), (size_t)bufsize);
+			break;
+		case IPV6_DSTOPTS:
+#ifdef IPV6_RTHDRDSTOPTS
+		case IPV6_RTHDRDSTOPTS:
+#endif
+			printf("  Dst Options: ");
+			pr_ip6opt(CMSG_DATA(cm), (size_t)bufsize);
+			break;
+		case IPV6_RTHDR:
+			printf("  Routing: ");
+			pr_rthdr(CMSG_DATA(cm), (size_t)bufsize);
+			break;
+		}
+	}
+}
+
+#if defined USE_RFC2292BIS && defined IPV6_OPTIONS
+void
+pr_ip6opt(void *extbuf, size_t bufsize)
+{
+	struct ip6_hbh *ext;
+	int currentlen;
+	u_int8_t type;
+	socklen_t extlen, len, origextlen;
+	void *databuf;
+	size_t offset;
+	u_int16_t value2;
+	u_int32_t value4;
+
+	ext = (struct ip6_hbh *)extbuf;
+	extlen = (ext->ip6h_len + 1) * 8;
+	printf("nxt %u, len %u (%lu bytes)\n", ext->ip6h_nxt,
+	    (unsigned int)ext->ip6h_len, (unsigned long)extlen);
+
+	/*
+	 * Bounds checking on the ancillary data buffer:
+	 *     subtract the size of a cmsg structure from the buffer size.
+	 */
+	if (bufsize < (extlen  + CMSG_SPACE(0))) {
+		origextlen = extlen;
+		extlen = bufsize - CMSG_SPACE(0);
+		warnx("options truncated, showing only %u (total=%u)",
+		    (unsigned int)(extlen / 8 - 1),
+		    (unsigned int)(ext->ip6h_len));
+	}
+
+	currentlen = 0;
+	while (1) {
+		currentlen = inet6_opt_next(extbuf, extlen, currentlen,
+		    &type, &len, &databuf);
+		if (currentlen == -1)
+			break;
+		switch (type) {
+		/*
+		 * Note that inet6_opt_next automatically skips any padding
+		 * optins.
+		 */
+		case IP6OPT_JUMBO:
+			offset = 0;
+			offset = inet6_opt_get_val(databuf, offset,
+			    &value4, sizeof(value4));
+			printf("    Jumbo Payload Opt: Length %u\n",
+			    (u_int32_t)ntohl(value4));
+			break;
+		case IP6OPT_ROUTER_ALERT:
+			offset = 0;
+			offset = inet6_opt_get_val(databuf, offset,
+						   &value2, sizeof(value2));
+			printf("    Router Alert Opt: Type %u\n",
+			    ntohs(value2));
+			break;
+		default:
+			printf("    Received Opt %u len %lu\n",
+			    type, (unsigned long)len);
+			break;
+		}
+	}
+	return;
+}
+#else  /* !USE_RFC2292BIS */
+/* ARGSUSED */
+void
+pr_ip6opt(void *extbuf, size_t bufsize)
+{
+	(void)extbuf;
+	(void)bufsize;
+	putchar('\n');
+	return;
+}
+#endif /* USE_RFC2292BIS */
+
+#if defined USE_RFC2292BIS && defined IPV6_OPTIONS
+void
+pr_rthdr(void *extbuf, size_t bufsize)
+{
+	struct in6_addr *in6;
+	char ntopbuf[INET6_ADDRSTRLEN];
+	struct ip6_rthdr *rh = (struct ip6_rthdr *)extbuf;
+	int i, segments, origsegs, rthsize, size0, size1;
+
+	/* print fixed part of the header */
+	printf("nxt %u, len %u (%d bytes), type %u, ", rh->ip6r_nxt,
+	    rh->ip6r_len, (rh->ip6r_len + 1) << 3, rh->ip6r_type);
+	if ((segments = inet6_rth_segments(extbuf)) >= 0) {
+		printf("%d segments, ", segments);
+		printf("%d left\n", rh->ip6r_segleft);
+	} else {
+		printf("segments unknown, ");
+		printf("%d left\n", rh->ip6r_segleft);
+		return;
+	}
+
+	/*
+	 * Bounds checking on the ancillary data buffer. When calculating
+	 * the number of items to show keep in mind:
+	 *	- The size of the cmsg structure
+	 *	- The size of one segment (the size of a Type 0 routing header)
+	 *	- When dividing add a fudge factor of one in case the
+	 *	  dividend is not evenly divisible by the divisor
+	 */
+	rthsize = (rh->ip6r_len + 1) * 8;
+	if (bufsize < (rthsize + CMSG_SPACE(0))) {
+		origsegs = segments;
+		size0 = inet6_rth_space(IPV6_RTHDR_TYPE_0, 0);
+		size1 = inet6_rth_space(IPV6_RTHDR_TYPE_0, 1);
+		segments -= (rthsize - (bufsize - CMSG_SPACE(0))) /
+		    (size1 - size0) + 1;
+		warnx("segments truncated, showing only %d (total=%d)",
+		    segments, origsegs);
+	}
+
+	for (i = 0; i < segments; i++) {
+		in6 = inet6_rth_getaddr(extbuf, i);
+		if (in6 == NULL)
+			printf("   [%d]<NULL>\n", i);
+		else {
+			if (!inet_ntop(AF_INET6, in6, ntopbuf,
+			    sizeof(ntopbuf)))
+				strlcpy(ntopbuf, "?", sizeof(ntopbuf));
+			printf("   [%d]%s\n", i, ntopbuf);
+		}
+	}
+
+	return;
+
+}
+
+#else  /* !USE_RFC2292BIS */
+/* ARGSUSED */
+void
+pr_rthdr(void *extbuf, size_t bufsize)
+{
+	(void)extbuf;
+	(void)bufsize;
+	putchar('\n');
+	return;
+}
+#endif /* USE_RFC2292BIS */
+
+int
+pr_bitrange(v, soff, ii)
+	u_int32_t v;
+	int soff;
+	int ii;
+{
+	int off;
+	int i;
+
+	off = 0;
+	while (off < 32) {
+		/* shift till we have 0x01 */
+		if ((v & 0x01) == 0) {
+			if (ii > 1)
+				printf("-%u", soff + off - 1);
+			ii = 0;
+			switch (v & 0x0f) {
+			case 0x00:
+				v >>= 4;
+				off += 4;
+				continue;
+			case 0x08:
+				v >>= 3;
+				off += 3;
+				continue;
+			case 0x04: case 0x0c:
+				v >>= 2;
+				off += 2;
+				continue;
+			default:
+				v >>= 1;
+				off += 1;
+				continue;
+			}
+		}
+
+		/* we have 0x01 with us */
+		for (i = 0; i < 32 - off; i++) {
+			if ((v & (0x01 << i)) == 0)
+				break;
+		}
+		if (!ii)
+			printf(" %u", soff + off);
+		ii += i;
+		v >>= i; off += i;
+	}
+	return ii;
+}
+
+void
+pr_suptypes(ni, nilen)
+	struct icmp6_nodeinfo *ni; /* ni->qtype must be SUPTYPES */
+	size_t nilen;
+{
+	size_t clen;
+	u_int32_t v;
+	const u_char *cp, *end;
+	u_int16_t cur;
+	struct cbit {
+		u_int16_t words;	/*32bit count*/
+		u_int16_t skip;
+	} cbit;
+#define MAXQTYPES	(1 << 16)
+	size_t off;
+	int b;
+
+	cp = (u_char *)(ni + 1);
+	end = ((u_char *)ni) + nilen;
+	cur = 0;
+	b = 0;
+
+	printf("NodeInfo Supported Qtypes");
+	if (options & F_VERBOSE) {
+		if (ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS)
+			printf(", compressed bitmap");
+		else
+			printf(", raw bitmap");
+	}
+
+	while (cp < end) {
+		clen = (size_t)(end - cp);
+		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) == 0) {
+			if (clen == 0 || clen > MAXQTYPES / 8 ||
+			    clen % sizeof(v)) {
+				printf("???");
+				return;
+			}
+		} else {
+			if (clen < sizeof(cbit) || clen % sizeof(v))
+				return;
+			memcpy(&cbit, cp, sizeof(cbit));
+			if (sizeof(cbit) + ntohs(cbit.words) * sizeof(v) >
+			    clen)
+				return;
+			cp += sizeof(cbit);
+			clen = ntohs(cbit.words) * sizeof(v);
+			if (cur + clen * 8 + (u_long)ntohs(cbit.skip) * 32 >
+			    MAXQTYPES)
+				return;
+		}
+
+		for (off = 0; off < clen; off += sizeof(v)) {
+			memcpy(&v, cp + off, sizeof(v));
+			v = (u_int32_t)ntohl(v);
+			b = pr_bitrange(v, (int)(cur + off * 8), b);
+		}
+		/* flush the remaining bits */
+		b = pr_bitrange(0, (int)(cur + off * 8), b);
+
+		cp += clen;
+		cur += clen * 8;
+		if ((ni->ni_flags & NI_SUPTYPE_FLAG_COMPRESS) != 0)
+			cur += ntohs(cbit.skip) * 32;
+	}
+}
+
+void
+pr_nodeaddr(ni, nilen)
+	struct icmp6_nodeinfo *ni; /* ni->qtype must be NODEADDR */
+	int nilen;
+{
+	u_char *cp = (u_char *)(ni + 1);
+	char ntop_buf[INET6_ADDRSTRLEN];
+	int withttl = 0;
+
+	nilen -= sizeof(struct icmp6_nodeinfo);
+
+	if (options & F_VERBOSE) {
+		switch (ni->ni_code) {
+		case ICMP6_NI_REFUSED:
+			(void)printf("refused");
+			break;
+		case ICMP6_NI_UNKNOWN:
+			(void)printf("unknown qtype");
+			break;
+		}
+		if (ni->ni_flags & NI_NODEADDR_FLAG_TRUNCATE)
+			(void)printf(" truncated");
+	}
+	putchar('\n');
+	if (nilen <= 0)
+		printf("  no address\n");
+
+	/*
+	 * In icmp-name-lookups 05 and later, TTL of each returned address
+	 * is contained in the resposne. We try to detect the version
+	 * by the length of the data, but note that the detection algorithm
+	 * is incomplete. We assume the latest draft by default.
+	 */
+	if (nilen % (sizeof(u_int32_t) + sizeof(struct in6_addr)) == 0)
+		withttl = 1;
+	while (nilen > 0) {
+		u_int32_t ttl;
+
+		if (withttl) {
+			/* XXX: alignment? */
+			ttl = (u_int32_t)ntohl(*(u_int32_t *)cp);
+			cp += sizeof(u_int32_t);
+			nilen -= sizeof(u_int32_t);
+		}
+
+		if (inet_ntop(AF_INET6, cp, ntop_buf, sizeof(ntop_buf)) ==
+		    NULL)
+			strlcpy(ntop_buf, "?", sizeof(ntop_buf));
+		printf("  %s", ntop_buf);
+		if (withttl) {
+			if (ttl == 0xffffffff) {
+				/*
+				 * XXX: can this convention be applied to all
+				 * type of TTL (i.e. non-ND TTL)?
+				 */
+				printf("(TTL=infty)");
+			}
+			else
+				printf("(TTL=%u)", ttl);
+		}
+		putchar('\n');
+
+		nilen -= sizeof(struct in6_addr);
+		cp += sizeof(struct in6_addr);
+	}
+}
+
+int
+get_hoplim(mhdr)
+	struct msghdr *mhdr;
+{
+	struct cmsghdr *cm;
+
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
+		if (cm->cmsg_len == 0)
+			return(-1);
+
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_HOPLIMIT &&
+		    cm->cmsg_len == CMSG_LEN(sizeof(int)))
+			return(*(int *)CMSG_DATA(cm));
+	}
+
+	return(-1);
+}
+
+struct in6_pktinfo *
+get_rcvpktinfo(mhdr)
+	struct msghdr *mhdr;
+{
+	struct cmsghdr *cm;
+
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
+		if (cm->cmsg_len == 0)
+			return(NULL);
+
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PKTINFO &&
+		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo)))
+			return((struct in6_pktinfo *)CMSG_DATA(cm));
+	}
+
+	return(NULL);
+}
+
+int
+get_pathmtu(mhdr)
+	struct msghdr *mhdr;
+{
+#ifdef IPV6_RECVPATHMTU
+	struct cmsghdr *cm;
+	struct ip6_mtuinfo *mtuctl = NULL;
+
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {
+		if (cm->cmsg_len == 0)
+			return(0);
+
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PATHMTU &&
+		    cm->cmsg_len == CMSG_LEN(sizeof(struct ip6_mtuinfo))) {
+			mtuctl = (struct ip6_mtuinfo *)CMSG_DATA(cm);
+
+			/*
+			 * If the notified destination is different from
+			 * the one we are pinging, just ignore the info.
+			 * We check the scope ID only when both notified value
+			 * and our own value have non-0 values, because we may
+			 * have used the default scope zone ID for sending,
+			 * in which case the scope ID value is 0.
+			 */
+			if (!IN6_ARE_ADDR_EQUAL(&mtuctl->ip6m_addr.sin6_addr,
+						&dst.sin6_addr) ||
+			    (mtuctl->ip6m_addr.sin6_scope_id &&
+			     dst.sin6_scope_id &&
+			     mtuctl->ip6m_addr.sin6_scope_id !=
+			     dst.sin6_scope_id)) {
+				if ((options & F_VERBOSE) != 0) {
+					printf("path MTU for %s is notified. "
+					       "(ignored)\n",
+					   pr_addr((struct sockaddr *)&mtuctl->ip6m_addr,
+					   sizeof(mtuctl->ip6m_addr)));
+				}
+				return(0);
+			}
+
+			/*
+			 * Ignore an invalid MTU. XXX: can we just believe
+			 * the kernel check?
+			 */
+			if (mtuctl->ip6m_mtu < IPV6_MMTU)
+				return(0);
+
+			/* notification for our destination. return the MTU. */
+			return((int)mtuctl->ip6m_mtu);
+		}
+	}
+#endif
+	return(0);
+}
+
+/*
+ * tvsub --
+ *	Subtract 2 timeval structs:  out = out - in.  Out is assumed to
+ * be >= in.
+ */
+void
+tvsub(out, in)
+	struct timeval *out, *in;
+{
+	if ((out->tv_usec -= in->tv_usec) < 0) {
+		--out->tv_sec;
+		out->tv_usec += 1000000;
+	}
+	out->tv_sec -= in->tv_sec;
+}
+
+/*
+ * onint --
+ *	SIGINT handler.
+ */
+/* ARGSUSED */
+void
+onint(notused)
+	int notused;
+{
+	summary();
+
+	(void)signal(SIGINT, SIG_DFL);
+	(void)kill(getpid(), SIGINT);
+
+	/* NOTREACHED */
+	exit(1);
+}
+
+/*
+ * summary --
+ *	Print out statistics.
+ */
+void
+summary()
+{
+	(void)printf("\n--- %s ping6 statistics ---\n", hostname);
+	(void)printf("%ld packets transmitted, ", ntransmitted);
+	(void)printf("%ld packets received, ", nreceived);
+	if (nrepeats)
+		(void)printf("+%ld duplicates, ", nrepeats);
+	if (ntransmitted) {
+		if (nreceived > ntransmitted)
+			(void)printf("-- somebody's duplicating packets!");
+		else
+			(void)printf("%.1f%% packet loss",
+			    ((((double)ntransmitted - nreceived) * 100.0) /
+			    ntransmitted));
+	}
+	(void)putchar('\n');
+	if (nreceived && timing) {
+		/* Only display average to microseconds */
+		double num = nreceived + nrepeats;
+		double avg = tsum / num;
+		double dev = sqrt(tsumsq / num - avg * avg);
+		(void)printf(
+		    "round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n",
+		    tmin, avg, tmax, dev);
+		(void)fflush(stdout);
+	}
+	(void)fflush(stdout);
+}
+
+/*subject type*/
+static const char *niqcode[] = {
+	"IPv6 address",
+	"DNS label",	/*or empty*/
+	"IPv4 address",
+};
+
+/*result code*/
+static const char *nircode[] = {
+	"Success", "Refused", "Unknown",
+};
+
+
+/*
+ * pr_icmph --
+ *	Print a descriptive string about an ICMP header.
+ */
+void
+pr_icmph(icp, end)
+	struct icmp6_hdr *icp;
+	u_char *end;
+{
+	char ntop_buf[INET6_ADDRSTRLEN];
+	struct nd_redirect *red;
+	struct icmp6_nodeinfo *ni;
+	char dnsname[MAXDNAME + 1];
+	const u_char *cp;
+	size_t l;
+
+	switch (icp->icmp6_type) {
+	case ICMP6_DST_UNREACH:
+		switch (icp->icmp6_code) {
+		case ICMP6_DST_UNREACH_NOROUTE:
+			(void)printf("No Route to Destination\n");
+			break;
+		case ICMP6_DST_UNREACH_ADMIN:
+			(void)printf("Destination Administratively "
+			    "Unreachable\n");
+			break;
+		case ICMP6_DST_UNREACH_BEYONDSCOPE:
+			(void)printf("Destination Unreachable Beyond Scope\n");
+			break;
+		case ICMP6_DST_UNREACH_ADDR:
+			(void)printf("Destination Host Unreachable\n");
+			break;
+		case ICMP6_DST_UNREACH_NOPORT:
+			(void)printf("Destination Port Unreachable\n");
+			break;
+		default:
+			(void)printf("Destination Unreachable, Bad Code: %d\n",
+			    icp->icmp6_code);
+			break;
+		}
+		/* Print returned IP header information */
+		pr_retip((struct ip6_hdr *)(icp + 1), end);
+		break;
+	case ICMP6_PACKET_TOO_BIG:
+		(void)printf("Packet too big mtu = %d\n",
+		    (int)ntohl(icp->icmp6_mtu));
+		pr_retip((struct ip6_hdr *)(icp + 1), end);
+		break;
+	case ICMP6_TIME_EXCEEDED:
+		switch (icp->icmp6_code) {
+		case ICMP6_TIME_EXCEED_TRANSIT:
+			(void)printf("Time to live exceeded\n");
+			break;
+		case ICMP6_TIME_EXCEED_REASSEMBLY:
+			(void)printf("Frag reassembly time exceeded\n");
+			break;
+		default:
+			(void)printf("Time exceeded, Bad Code: %d\n",
+			    icp->icmp6_code);
+			break;
+		}
+		pr_retip((struct ip6_hdr *)(icp + 1), end);
+		break;
+	case ICMP6_PARAM_PROB:
+		(void)printf("Parameter problem: ");
+		switch (icp->icmp6_code) {
+		case ICMP6_PARAMPROB_HEADER:
+			(void)printf("Erroneous Header ");
+			break;
+		case ICMP6_PARAMPROB_NEXTHEADER:
+			(void)printf("Unknown Nextheader ");
+			break;
+		case ICMP6_PARAMPROB_OPTION:
+			(void)printf("Unrecognized Option ");
+			break;
+		default:
+			(void)printf("Bad code(%d) ", icp->icmp6_code);
+			break;
+		}
+		(void)printf("pointer = 0x%02x\n",
+		    (u_int32_t)ntohl(icp->icmp6_pptr));
+		pr_retip((struct ip6_hdr *)(icp + 1), end);
+		break;
+	case ICMP6_ECHO_REQUEST:
+		(void)printf("Echo Request");
+		/* XXX ID + Seq + Data */
+		break;
+	case ICMP6_ECHO_REPLY:
+		(void)printf("Echo Reply");
+		/* XXX ID + Seq + Data */
+		break;
+	case ICMP6_MEMBERSHIP_QUERY:
+		(void)printf("Listener Query");
+		break;
+	case ICMP6_MEMBERSHIP_REPORT:
+		(void)printf("Listener Report");
+		break;
+	case ICMP6_MEMBERSHIP_REDUCTION:
+		(void)printf("Listener Done");
+		break;
+	case ND_ROUTER_SOLICIT:
+		(void)printf("Router Solicitation");
+		break;
+	case ND_ROUTER_ADVERT:
+		(void)printf("Router Advertisement");
+		break;
+	case ND_NEIGHBOR_SOLICIT:
+		(void)printf("Neighbor Solicitation");
+		break;
+	case ND_NEIGHBOR_ADVERT:
+		(void)printf("Neighbor Advertisement");
+		break;
+	case ND_REDIRECT:
+		red = (struct nd_redirect *)icp;
+		(void)printf("Redirect\n");
+		if (!inet_ntop(AF_INET6, &red->nd_rd_dst, ntop_buf,
+		    sizeof(ntop_buf)))
+			strlcpy(ntop_buf, "?", sizeof(ntop_buf));
+		(void)printf("Destination: %s", ntop_buf);
+		if (!inet_ntop(AF_INET6, &red->nd_rd_target, ntop_buf,
+		    sizeof(ntop_buf)))
+			strlcpy(ntop_buf, "?", sizeof(ntop_buf));
+		(void)printf(" New Target: %s", ntop_buf);
+		break;
+	case ICMP6_NI_QUERY:
+		(void)printf("Node Information Query");
+		/* XXX ID + Seq + Data */
+		ni = (struct icmp6_nodeinfo *)icp;
+		l = end - (u_char *)(ni + 1);
+		printf(", ");
+		switch (ntohs(ni->ni_qtype)) {
+		case NI_QTYPE_NOOP:
+			(void)printf("NOOP");
+			break;
+		case NI_QTYPE_SUPTYPES:
+			(void)printf("Supported qtypes");
+			break;
+		case NI_QTYPE_FQDN:
+			(void)printf("DNS name");
+			break;
+		case NI_QTYPE_NODEADDR:
+			(void)printf("nodeaddr");
+			break;
+		case NI_QTYPE_IPV4ADDR:
+			(void)printf("IPv4 nodeaddr");
+			break;
+		default:
+			(void)printf("unknown qtype");
+			break;
+		}
+		if (options & F_VERBOSE) {
+			switch (ni->ni_code) {
+			case ICMP6_NI_SUBJ_IPV6:
+				if (l == sizeof(struct in6_addr) &&
+				    inet_ntop(AF_INET6, ni + 1, ntop_buf,
+				    sizeof(ntop_buf)) != NULL) {
+					(void)printf(", subject=%s(%s)",
+					    niqcode[ni->ni_code], ntop_buf);
+				} else {
+#if 1
+					/* backward compat to -W */
+					(void)printf(", oldfqdn");
+#else
+					(void)printf(", invalid");
+#endif
+				}
+				break;
+			case ICMP6_NI_SUBJ_FQDN:
+				if (end == (u_char *)(ni + 1)) {
+					(void)printf(", no subject");
+					break;
+				}
+				printf(", subject=%s", niqcode[ni->ni_code]);
+				cp = (const u_char *)(ni + 1);
+				if (dnsdecode(&cp, end, NULL, dnsname,
+				    sizeof(dnsname)) != NULL)
+					printf("(%s)", dnsname);
+				else
+					printf("(invalid)");
+				break;
+			case ICMP6_NI_SUBJ_IPV4:
+				if (l == sizeof(struct in_addr) &&
+				    inet_ntop(AF_INET, ni + 1, ntop_buf,
+				    sizeof(ntop_buf)) != NULL) {
+					(void)printf(", subject=%s(%s)",
+					    niqcode[ni->ni_code], ntop_buf);
+				} else
+					(void)printf(", invalid");
+				break;
+			default:
+				(void)printf(", invalid");
+				break;
+			}
+		}
+		break;
+	case ICMP6_NI_REPLY:
+		(void)printf("Node Information Reply");
+		/* XXX ID + Seq + Data */
+		ni = (struct icmp6_nodeinfo *)icp;
+		printf(", ");
+		switch (ntohs(ni->ni_qtype)) {
+		case NI_QTYPE_NOOP:
+			(void)printf("NOOP");
+			break;
+		case NI_QTYPE_SUPTYPES:
+			(void)printf("Supported qtypes");
+			break;
+		case NI_QTYPE_FQDN:
+			(void)printf("DNS name");
+			break;
+		case NI_QTYPE_NODEADDR:
+			(void)printf("nodeaddr");
+			break;
+		case NI_QTYPE_IPV4ADDR:
+			(void)printf("IPv4 nodeaddr");
+			break;
+		default:
+			(void)printf("unknown qtype");
+			break;
+		}
+		if (options & F_VERBOSE) {
+			if (ni->ni_code > sizeof(nircode) / sizeof(nircode[0]))
+				printf(", invalid");
+			else
+				printf(", %s", nircode[ni->ni_code]);
+		}
+		break;
+	default:
+		(void)printf("Bad ICMP type: %d", icp->icmp6_type);
+	}
+}
+
+/*
+ * pr_iph --
+ *	Print an IP6 header.
+ */
+void
+pr_iph(ip6)
+	struct ip6_hdr *ip6;
+{
+	u_int32_t flow = ip6->ip6_flow & IPV6_FLOWLABEL_MASK;
+	u_int8_t tc;
+	char ntop_buf[INET6_ADDRSTRLEN];
+
+	tc = *(&ip6->ip6_vfc + 1); /* XXX */
+	tc = (tc >> 4) & 0x0f;
+	tc |= (ip6->ip6_vfc << 4);
+
+	printf("Vr TC  Flow Plen Nxt Hlim\n");
+	printf(" %1x %02x %05x %04x  %02x   %02x\n",
+	    (ip6->ip6_vfc & IPV6_VERSION_MASK) >> 4, tc, (u_int32_t)ntohl(flow),
+	    ntohs(ip6->ip6_plen), ip6->ip6_nxt, ip6->ip6_hlim);
+	if (!inet_ntop(AF_INET6, &ip6->ip6_src, ntop_buf, sizeof(ntop_buf)))
+		strlcpy(ntop_buf, "?", sizeof(ntop_buf));
+	printf("%s->", ntop_buf);
+	if (!inet_ntop(AF_INET6, &ip6->ip6_dst, ntop_buf, sizeof(ntop_buf)))
+		strlcpy(ntop_buf, "?", sizeof(ntop_buf));
+	printf("%s\n", ntop_buf);
+}
+
+/*
+ * pr_addr --
+ *	Return an ascii host address as a dotted quad and optionally with
+ * a hostname.
+ */
+const char *
+pr_addr(addr, addrlen)
+	struct sockaddr *addr;
+	int addrlen;
+{
+	static char buf[NI_MAXHOST];
+	int flag = 0;
+
+	if ((options & F_HOSTNAME) == 0)
+		flag |= NI_NUMERICHOST;
+
+	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)
+		return (buf);
+	else
+		return "?";
+}
+
+/*
+ * pr_retip --
+ *	Dump some info on a returned (via ICMPv6) IPv6 packet.
+ */
+void
+pr_retip(ip6, end)
+	struct ip6_hdr *ip6;
+	u_char *end;
+{
+	u_char *cp = (u_char *)ip6, nh;
+	int hlen;
+
+	if (end - (u_char *)ip6 < sizeof(*ip6)) {
+		printf("IP6");
+		goto trunc;
+	}
+	pr_iph(ip6);
+	hlen = sizeof(*ip6);
+
+	nh = ip6->ip6_nxt;
+	cp += hlen;
+	while (end - cp >= 8) {
+		switch (nh) {
+		case IPPROTO_HOPOPTS:
+			printf("HBH ");
+			hlen = (((struct ip6_hbh *)cp)->ip6h_len+1) << 3;
+			nh = ((struct ip6_hbh *)cp)->ip6h_nxt;
+			break;
+		case IPPROTO_DSTOPTS:
+			printf("DSTOPT ");
+			hlen = (((struct ip6_dest *)cp)->ip6d_len+1) << 3;
+			nh = ((struct ip6_dest *)cp)->ip6d_nxt;
+			break;
+		case IPPROTO_FRAGMENT:
+			printf("FRAG ");
+			hlen = sizeof(struct ip6_frag);
+			nh = ((struct ip6_frag *)cp)->ip6f_nxt;
+			break;
+		case IPPROTO_ROUTING:
+			printf("RTHDR ");
+			hlen = (((struct ip6_rthdr *)cp)->ip6r_len+1) << 3;
+			nh = ((struct ip6_rthdr *)cp)->ip6r_nxt;
+			break;
+#ifdef IPSEC
+		case IPPROTO_AH:
+			printf("AH ");
+			hlen = (((struct ah *)cp)->ah_len+2) << 2;
+			nh = ((struct ah *)cp)->ah_nxt;
+			break;
+#endif
+		case IPPROTO_ICMPV6:
+			printf("ICMP6: type = %d, code = %d\n",
+			    *cp, *(cp + 1));
+			return;
+		case IPPROTO_ESP:
+			printf("ESP\n");
+			return;
+		case IPPROTO_TCP:
+			printf("TCP: from port %u, to port %u (decimal)\n",
+			    (*cp * 256 + *(cp + 1)),
+			    (*(cp + 2) * 256 + *(cp + 3)));
+			return;
+		case IPPROTO_UDP:
+			printf("UDP: from port %u, to port %u (decimal)\n",
+			    (*cp * 256 + *(cp + 1)),
+			    (*(cp + 2) * 256 + *(cp + 3)));
+			return;
+		default:
+			printf("Unknown Header(%d)\n", nh);
+			return;
+		}
+
+		if ((cp += hlen) >= end)
+			goto trunc;
+	}
+	if (end - cp < 8)
+		goto trunc;
+
+	putchar('\n');
+	return;
+
+  trunc:
+	printf("...\n");
+	return;
+}
+
+void
+fill(bp, patp)
+	char *bp, *patp;
+{
+	int ii, jj, kk;
+	int pat[16];
+	char *cp;
+
+	for (cp = patp; *cp; cp++)
+		if (!isxdigit(*cp))
+			errx(1, "patterns must be specified as hex digits");
+	ii = sscanf(patp,
+	    "%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x",
+	    &pat[0], &pat[1], &pat[2], &pat[3], &pat[4], &pat[5], &pat[6],
+	    &pat[7], &pat[8], &pat[9], &pat[10], &pat[11], &pat[12],
+	    &pat[13], &pat[14], &pat[15]);
+
+/* xxx */
+	if (ii > 0)
+		for (kk = 0;
+		    kk <= MAXDATALEN - (8 + sizeof(struct tv32) + ii);
+		    kk += ii)
+			for (jj = 0; jj < ii; ++jj)
+				bp[jj + kk] = pat[jj];
+	if (!(options & F_QUIET)) {
+		(void)printf("PATTERN: 0x");
+		for (jj = 0; jj < ii; ++jj)
+			(void)printf("%02x", bp[jj] & 0xFF);
+		(void)printf("\n");
+	}
+}
+
+#ifdef IPSEC
+#ifdef IPSEC_POLICY_IPSEC
+int
+setpolicy(so, policy)
+	int so;
+	char *policy;
+{
+	char *buf;
+
+	if (policy == NULL)
+		return 0;	/* ignore */
+
+	buf = ipsec_set_policy(policy, strlen(policy));
+	if (buf == NULL)
+		errx(1, "%s", ipsec_strerror());
+	if (setsockopt(s, IPPROTO_IPV6, IPV6_IPSEC_POLICY, buf,
+	    ipsec_get_policylen(buf)) < 0)
+		warnx("Unable to set IPsec policy");
+	free(buf);
+
+	return 0;
+}
+#endif
+#endif
+
+void
+usage()
+{
+	(void)fprintf(stderr,
+#if defined(IPSEC) && !defined(IPSEC_POLICY_IPSEC)
+	    "A"
+#endif
+	    "usage: ping6 [-"
+	    "d"
+#if defined(IPSEC) && !defined(IPSEC_POLICY_IPSEC)
+	    "E"
+#endif
+	    "fH"
+#ifdef IPV6_USE_MIN_MTU
+	    "m"
+#endif
+	    "noqrRtvwW] "
+	    "[-a addrtype] [-b bufsiz] [-c count]\n"
+	    "             [-h hoplimit] [-I interface] [-i wait] [-l preload]"
+#if defined(IPSEC) && defined(IPSEC_POLICY_IPSEC)
+	    " [-P policy]"
+#endif
+	    "\n"
+	    "             [-p pattern] [-S sourceaddr] [-s packetsize] "
+	    "[hops ...] host\n");
+	exit(1);
+}
Index: src/bin/network/ping6/Jamfile
===================================================================
--- src/bin/network/ping6/Jamfile	(revision 0)
+++ src/bin/network/ping6/Jamfile	(revision 0)
@@ -0,0 +1,29 @@
+SubDir HAIKU_TOP src bin network ping6 ;
+
+SetSubDirSupportedPlatforms $(HAIKU_BONE_COMPATIBLE_PLATFORMS) ;
+
+if ! $(TARGET_PLATFORM_HAIKU_COMPATIBLE) {
+	UseHeaders [ FDirName $(HAIKU_TOP) headers posix ] : true ;
+		# We need the public network headers also when not compiling for Haiku.
+		# Unfortunately we get more than we want, namely all POSIX headers.
+}
+
+BinCommand ping6 :
+	ping6.c
+	: $(TARGET_NETWORK_LIBS) $(TARGET_SELECT_UNAME_ETC_LIB) ;
+
+# Installation -- in the test directory for the time being
+HaikuInstall install-networking
+	: [ FDirName $(HAIKU_TEST_DIR) kits net ]
+	: ping6 ;
+
+HaikuInstall install-userland-networking 
+	: [ FDirName $(HAIKU_TEST_DIR) kits net userland ]
+	: ping6
+	: installed-userland-networking
+;
+
+Package haiku-networkingkit-cvs :
+	ping6 :
+	boot home Desktop haiku-networkingkit ;
+
Index: src/bin/network/ifconfig/ifconfig.cpp
===================================================================
--- src/bin/network/ifconfig/ifconfig.cpp	(revision 37465)
+++ src/bin/network/ifconfig/ifconfig.cpp	(working copy)
@@ -1,10 +1,11 @@
 /*
- * Copyright 2006-2008, Haiku, Inc. All Rights Reserved.
+ * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
  *		Axel Drfler, axeld@pinc-software.de
  *		Oliver Tappe, zooey@hirschkaefer.de
+ *		Atis Elsts, the.kfx@gmail.com
  */
 
 
@@ -33,30 +34,82 @@
 const char* kProgramName = __progname;
 
 
+enum preferred_output_format
+{
+	PREFER_OUTPUT_MASK,
+	PREFER_OUTPUT_PREFIX_LENGTH,
+};
+
+
 struct address_family {
 	int			family;
 	const char*	name;
 	const char*	identifiers[4];
+	preferred_output_format	preferred_format;
 	bool		(*parse_address)(const char* string, sockaddr* _address);
+	bool		(*prefix_length_to_mask)(uint8 prefixLength, sockaddr* mask);
+	uint8		(*mask_to_prefix_length)(sockaddr* mask);
 	void		(*print_address)(sockaddr* address);
 };
 
+bool initialize_address_families();
+
 // AF_INET family
 static bool inet_parse_address(const char* string, sockaddr* address);
+static bool inet_prefix_length_to_mask(uint8 prefixLength, sockaddr* mask);
+static uint8 inet_mask_to_prefix_length(sockaddr* mask);
 static void inet_print_address(sockaddr* address);
 
+// AF_INET6 family
+static bool inet6_parse_address(const char* string, sockaddr* address);
+static bool inet6_prefix_length_to_mask(uint8 prefixLength, sockaddr* mask);
+static uint8 inet6_mask_to_prefix_length(sockaddr* mask);
+static void inet6_print_address(sockaddr* address);
+
 static const address_family kFamilies[] = {
 	{
 		AF_INET,
 		"inet",
 		{"AF_INET", "inet", "ipv4", NULL},
+		PREFER_OUTPUT_MASK,
 		inet_parse_address,
+		inet_prefix_length_to_mask,
+		inet_mask_to_prefix_length,
 		inet_print_address
 	},
-	{ -1, NULL, {NULL}, NULL, NULL }
+	{
+		AF_INET6,
+		"inet6",
+		{"AF_INET6", "inet6", "ipv6", NULL},
+		PREFER_OUTPUT_PREFIX_LENGTH,
+		inet6_parse_address,
+		inet6_prefix_length_to_mask,
+		inet6_mask_to_prefix_length,
+		inet6_print_address
+	},
+	{ -1, NULL, {NULL}, PREFER_OUTPUT_MASK, NULL, NULL, NULL, NULL }
 };
 
 
+static int sAddressFamilySockets[sizeof(kFamilies) / sizeof(kFamilies[0])];
+
+
+bool
+initialize_address_families()
+{
+	bool ok = false;
+	for (int32 i = 0; kFamilies[i].family >= 0; i++) {
+		int fd = socket(kFamilies[i].family, SOCK_DGRAM, 0);
+		if (fd != -1) {
+			sAddressFamilySockets[i] = fd;
+			ok = true;
+		}
+	}
+	return ok;
+}
+
+
+
 static bool
 inet_parse_address(const char* string, sockaddr* _address)
 {
@@ -67,7 +120,7 @@
 
 	sockaddr_in& address = *(sockaddr_in *)_address;
 	address.sin_family = AF_INET;
-	address.sin_len = sizeof(struct sockaddr_in);
+	address.sin_len = sizeof(sockaddr_in);
 	address.sin_port = 0;
 	address.sin_addr = inetAddress;
 	memset(&address.sin_zero[0], 0, sizeof(address.sin_zero));
@@ -76,6 +129,46 @@
 }
 
 
+static bool
+inet_prefix_length_to_mask(uint8 prefixLength, sockaddr* _mask)
+{
+	if (prefixLength > 32)
+		return false;
+
+	sockaddr_in& mask = *(sockaddr_in *)_mask;
+	mask.sin_family = AF_INET;
+	mask.sin_len = sizeof(sockaddr_in);
+	mask.sin_port = 0;
+	memset(&mask.sin_zero[0], 0, sizeof(mask.sin_zero));
+
+	uint32 u32mask = 0;
+	for (uint8 i = 32; i > 32 - prefixLength; i--)
+		u32mask |= 1 << (i - 1);
+	mask.sin_addr.s_addr = htonl(u32mask);
+
+	return true;
+}
+
+
+static uint8
+inet_mask_to_prefix_length(sockaddr* _mask)
+{
+	sockaddr_in& mask = *(sockaddr_in *)_mask;
+	if (mask.sin_family != AF_INET)
+		return (uint8)-1;
+
+	uint8 result = 0;
+	uint32 u32mask = ntohl(mask.sin_addr.s_addr);
+	for (uint8 i = 32; i > 0; i--) {
+		if (u32mask & (1 << (i - 1)) == 0)
+			break;
+		result++;
+	}
+
+	return result;
+}
+
+
 static void
 inet_print_address(sockaddr* _address)
 {
@@ -88,6 +181,90 @@
 }
 
 
+static bool
+inet6_parse_address(const char* string, sockaddr* _address)
+{
+	sockaddr_in6& address = *(sockaddr_in6 *)_address;
+
+	if (inet_pton(AF_INET6, string, &address.sin6_addr) != 1)
+		return false;
+
+	address.sin6_family = AF_INET6;
+	address.sin6_len = sizeof(sockaddr_in6);
+	address.sin6_port = 0;
+	address.sin6_flowinfo = 0;
+	address.sin6_scope_id = 0;
+
+	return true;
+}
+
+
+static bool
+inet6_prefix_length_to_mask(uint8 prefixLength, sockaddr* _mask)
+{
+	if (prefixLength > 128)
+		return false;
+
+	sockaddr_in6& mask = *(sockaddr_in6 *)_mask;
+	mask.sin6_family = AF_INET6;
+	mask.sin6_len = sizeof(sockaddr_in6);
+	mask.sin6_port = 0;
+	mask.sin6_flowinfo = 0;
+	mask.sin6_scope_id = 0;
+	memset(mask.sin6_addr.s6_addr, 0, sizeof(in6_addr));
+
+	for (uint8 i = 0; i < sizeof(in6_addr); i++, prefixLength -= 8) {
+		if (prefixLength < 8) {
+			const uint8 masks[] = {
+				0x00, 0x80, 0xc0, 0xe0,
+				0xf0, 0xf8, 0xfc, 0xfe
+			};
+			mask.sin6_addr.s6_addr[i] = masks[prefixLength];
+			break;
+		}
+
+		mask.sin6_addr.s6_addr[i] = 0xff;
+	}
+
+	return true;
+}
+
+
+static uint8
+inet6_mask_to_prefix_length(sockaddr* _mask)
+{
+	sockaddr_in6& mask = *(sockaddr_in6 *)_mask;
+	if (mask.sin6_family != AF_INET6)
+		return (uint8)-1;
+
+	uint8 result = 0;
+	for (uint8 i = 0; i < sizeof(in6_addr); i++) {
+		for (uint8 j = 0; j < 8; j++) {
+			if (!(mask.sin6_addr.s6_addr[i] & (1 << j)))
+				return result;
+			result++;
+		}
+	}
+
+	return 128;
+}
+
+
+static void
+inet6_print_address(sockaddr* _address)
+{
+	sockaddr_in6& address = *(sockaddr_in6 *)_address;
+
+	if (address.sin6_family != AF_INET6)
+		return;
+
+	char buffer[INET6_ADDRSTRLEN];
+
+	printf("%s",
+		inet_ntop(AF_INET6, &address.sin6_addr, buffer, sizeof(buffer)));
+}
+
+
 //	#pragma mark -
 
 
@@ -181,12 +358,13 @@
 			"auto-config] [<option/flags>...]]\n"
 		"\t%s --delete interface [...]\n\n"
 		"Where <option> can be the following:\n"
-		"  netmask <addr>   - networking subnet mask\n"
-		"  broadcast <addr> - set broadcast address\n"
-		"  peer <addr>      - ppp-peer address\n"
-		"  mtu <bytes>      - maximal transfer unit\n"
-		"  metric <number>  - metric number to use (defaults to 0)\n"
-		"  media <media>    - media type to use (defaults to auto)\n",
+		"  netmask <addr>     - networking subnet mask\n"
+		"  prefixlen <number> - subnet mask length in bits\n"
+		"  broadcast <addr>   - set broadcast address\n"
+		"  peer <addr>        - ppp-peer address\n"
+		"  mtu <bytes>        - maximal transfer unit\n"
+		"  metric <number>    - metric number to use (defaults to 0)\n"
+		"  media <media>      - media type to use (defaults to auto)\n",
 		kProgramName, kProgramName);
 	for (int32 i = 0; kMediaTypes[i].type >= 0; i++) {
 		printf("For %s <media> can be one of: ", kMediaTypes[i].pretty);
@@ -210,8 +388,8 @@
 prepare_request(struct ifreq& request, const char* name)
 {
 	if (strlen(name) > IF_NAMESIZE) {
-		fprintf(stderr, "%s: interface name \"%s\" is too long.\n", kProgramName,
-			name);
+		fprintf(stderr, "%s: interface name \"%s\" is too long.\n",
+			kProgramName, name);
 		return false;
 	}
 
@@ -249,22 +427,102 @@
 }
 
 
+bool
+prefix_length_to_mask(int32 familyIndex, const char* argument,
+	struct sockaddr& mask)
+{
+	if (argument == NULL)
+		return false;
+
+	char *end;
+	uint32 prefixLength = strtoul(argument, &end, 10);
+	if (end == argument)
+		return false;
+
+	return kFamilies[familyIndex].prefix_length_to_mask(
+		(uint8)prefixLength, &mask);
+}
+
+
 //	#pragma mark -
 
 
+int
+find_socket(struct ifreq& request, int addressFamily)
+{
+	int socket = -1;
+	bool triedIoctl = false; // true if have tried doing ioctl()
+	bool ok = false;
+
+	for (int32 i = 0; kFamilies[i].family >= 0; i++) {
+		if (addressFamily != -1 && addressFamily != kFamilies[i].family)
+			continue;
+
+		socket = sAddressFamilySockets[i];
+		if (socket == -1)
+			continue;
+
+		triedIoctl = true;
+		if (ioctl(socket, SIOCGIFINDEX, &request, sizeof(request)) >= 0) {
+			ok = true;
+			break;
+		}
+	}
+
+	if (triedIoctl && !ok) {
+		fprintf(stderr, "%s: Interface \"%s\" does not exist.\n",
+			kProgramName, request.ifr_name);
+		return -1;
+	}
+
+	return socket;
+}
+
+
 void
-list_interface(int socket, const char* name)
+list_interface_address(int socket, const address_family *family,
+	uint32 flags, ifreq *request)
 {
-	ifreq request;
-	if (!prepare_request(request, name))
+	if (ioctl(socket, SIOCGIFADDR, request, sizeof(struct ifreq)) < 0)
 		return;
 
-	if (ioctl(socket, SIOCGIFINDEX, &request, sizeof(request)) < 0) {
-		fprintf(stderr, "%s: Interface \"%s\" does not exist.\n", kProgramName,
-			name);
-		return;
+	printf("\t%s addr: ", family->name);
+	family->print_address(&request->ifr_addr);
+
+	if ((flags & IFF_BROADCAST) != 0
+		&& ioctl(socket, SIOCGIFBRDADDR, request, sizeof(struct ifreq)) == 0
+		&& request->ifr_broadaddr.sa_family == family->family) {
+		printf(", Bcast: ");
+		family->print_address(&request->ifr_broadaddr);
 	}
+	if (ioctl(socket, SIOCGIFNETMASK, request, sizeof(struct ifreq)) == 0
+		&& request->ifr_mask.sa_family == family->family) {
+		switch (family->preferred_format) {
+			case PREFER_OUTPUT_MASK:
+				printf(", Mask: ");
+				family->print_address(&request->ifr_mask);
+				break;
+			case PREFER_OUTPUT_PREFIX_LENGTH:
+				printf(", Prefix Length: %u",
+					family->mask_to_prefix_length(&request->ifr_mask));
+				break;
+		}
+	}
+	putchar('\n');
+}
 
+
+bool
+list_interface(const char* name, int addressFamily)
+{
+	ifreq request;
+	if (!prepare_request(request, name))
+		return true;
+
+	int socket = find_socket(request, addressFamily);
+	if (socket == -1)
+		return false;
+
 	printf("%s", name);
 	size_t length = strlen(name);
 	if (length < 8)
@@ -348,29 +606,11 @@
 		flags = request.ifr_flags;
 
 	for (int32 i = 0; kFamilies[i].family >= 0; i++) {
-		int familySocket = ::socket(kFamilies[i].family, SOCK_DGRAM, 0);
-		if (familySocket < 0)
-			continue;
-
-		if (ioctl(familySocket, SIOCGIFADDR, &request, sizeof(struct ifreq)) == 0) {
-			printf("\t%s addr: ", kFamilies[i].name);
-			kFamilies[i].print_address(&request.ifr_addr);
-
-			if ((flags & IFF_BROADCAST) != 0
-				&& ioctl(familySocket, SIOCGIFBRDADDR, &request, sizeof(struct ifreq)) == 0
-				&& request.ifr_broadaddr.sa_family == kFamilies[i].family) {
-				printf(", Bcast: ");
-				kFamilies[i].print_address(&request.ifr_broadaddr);
-			}
-			if (ioctl(familySocket, SIOCGIFNETMASK, &request, sizeof(struct ifreq)) == 0
-				&& request.ifr_mask.sa_family == kFamilies[i].family) {
-				printf(", Mask: ");
-				kFamilies[i].print_address(&request.ifr_mask);
-			}
-			putchar('\n');
+		int familySocket = sAddressFamilySockets[i];
+		if (familySocket != -1) {
+			list_interface_address(familySocket, &kFamilies[i],
+				flags, &request);
 		}
-
-		close(familySocket);
 	}
 
 	// Print MTU, metric, flags
@@ -434,19 +674,22 @@
 	}
 
 	putchar('\n');
+	return true;
 }
 
 
 void
-list_interfaces(int socket, const char* name)
+list_interfaces(const char* name)
 {
 	if (name != NULL) {
-		list_interface(socket, name);
+		list_interface(name, -1);
 		return;
 	}
 
 	// get a list of all interfaces
 
+	int socket = sAddressFamilySockets[0];
+
 	ifconf config;
 	config.ifc_len = sizeof(config.ifc_value);
 	if (ioctl(socket, SIOCGIFCOUNT, &config, sizeof(struct ifconf)) < 0)
@@ -472,7 +715,7 @@
 	ifreq *interface = (ifreq *)buffer;
 
 	for (uint32 i = 0; i < count; i++) {
-		list_interface(socket, interface->ifr_name);
+		list_interface(interface->ifr_name, interface->ifr_addr.sa_family);
 
 		interface = (ifreq *)((addr_t)interface + IF_NAMESIZE + interface->ifr_addr.sa_len);
 	}
@@ -482,12 +725,16 @@
 
 
 void
-delete_interface(int socket, const char* name)
+delete_interface(const char* name)
 {
 	ifreq request;
 	if (!prepare_request(request, name))
 		return;
 
+	int socket = find_socket(request, -1);
+	if (socket == -1)
+		return;
+
 	if (ioctl(socket, SIOCDIFADDR, &request, sizeof(request)) < 0) {
 		fprintf(stderr, "%s: Could not delete interface %s: %s\n",
 			kProgramName, name, strerror(errno));
@@ -496,13 +743,27 @@
 
 
 void
-configure_interface(int socket, const char* name, char* const* args,
+configure_interface(const char* name, char* const* args,
 	int32 argCount)
 {
 	ifreq request;
 	if (!prepare_request(request, name))
 		return;
 
+	// try to parse address family
+
+	int32 familyIndex;
+	int32 i = 0;
+	if (get_address_family(args[i], familyIndex))
+		i++;
+
+	int socket = sAddressFamilySockets[familyIndex];
+	if (socket < 0) {
+		fprintf(stderr, "%s: Address family \"%s\" is not available.\n",
+			kProgramName, kFamilies[familyIndex].name);
+		exit(1);
+	}
+
 	uint32 index = 0;
 	if (ioctl(socket, SIOCGIFINDEX, &request, sizeof(request)) >= 0)
 		index = request.ifr_index;
@@ -513,25 +774,6 @@
 	int mtu = -1, metric = -1, media = -1;
 	int addFlags = 0, currentFlags = 0, removeFlags = 0;
 
-	// try to parse address family
-
-	int32 familyIndex;
-	int32 i = 0;
-	if (get_address_family(args[i], familyIndex))
-		i++;
-
-	if (kFamilies[familyIndex].family != AF_INET) {
-		close(socket);
-
-		// replace socket with one of the correct address family
-		socket = ::socket(kFamilies[familyIndex].family, SOCK_DGRAM, 0);
-		if (socket < 0) {
-			fprintf(stderr, "%s: Address family \"%s\" is not available.\n",
-				kProgramName, kFamilies[familyIndex].name);
-			exit(1);
-		}
-	}
-
 	if (index == 0) {
 		// the interface does not exist yet, we have to add it first
 		request.ifr_parameter.base_name[0] = '\0';
@@ -571,7 +813,7 @@
 			i++;
 		} else if (!strcmp(args[i], "nm") || !strcmp(args[i], "netmask")) {
 			if (hasMask) {
-				fprintf(stderr, "%s: Netmask is specified twice\n",
+				fprintf(stderr, "%s: Netmask or prefix length is specified twice\n",
 					kProgramName);
 				exit(1);
 			}
@@ -582,6 +824,20 @@
 			}
 			hasMask = true;
 			i++;
+		} else if (!strcmp(args[i], "prefixlen") 
+				|| !strcmp(args[i], "plen")) {
+			if (hasMask) {
+				fprintf(stderr, "%s: Netmask or prefix length is specified twice\n",
+					kProgramName);
+				exit(1);
+			}
+			if (!prefix_length_to_mask(familyIndex, args[i + 1], mask)) {
+				fprintf(stderr, "%s: Option 'prefixlen' is invalid for this "
+					"address family\n", kProgramName);
+				exit(1);
+			}
+			hasMask = true;
+			i++;
 		} else if (!strcmp(args[i], "bc") || !strcmp(args[i], "broadcast")) {
 			if (hasBroadcast) {
 				fprintf(stderr, "%s: broadcast address is specified twice\n",
@@ -761,6 +1017,7 @@
 		BMessage message(kMsgConfigureInterface);
 		message.AddString("device", name);
 		BMessage address;
+		// TODO: this is not working for ipv6 yet
 		address.AddString("family", "inet");
 		address.AddBool("auto_config", true);
 		message.AddMessage("address", &address);
@@ -807,9 +1064,7 @@
 		deleteInterfaces = true;
 	}
 
-	// we need a socket to talk to the networking stack
-	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);
-	if (socket < 0) {
+	if (initialize_address_families() == false) {
 		fprintf(stderr, "%s: The networking stack doesn't seem to be "
 			"available.\n", kProgramName);
 		return 1;
@@ -817,7 +1072,7 @@
 
 	if (deleteInterfaces) {
 		for (int i = 2; i < argc; i++) {
-			delete_interface(socket, argv[i]);
+			delete_interface(argv[i]);
 		}
 		return 0;
 	} else if (argc > 1 && !strcmp(argv[1], "-a")) {
@@ -825,7 +1080,7 @@
 		if (argc > 2)
 			usage(1);
 
-		list_interfaces(socket, NULL);
+		list_interfaces(NULL);
 		return 0;
 	}
 
@@ -833,13 +1088,13 @@
 	if (argc > 2) {
 		// add or configure an interface
 
-		configure_interface(socket, name, argv + 2, argc - 2);
+		configure_interface(name, argv + 2, argc - 2);
 		return 0;
 	}
 
 	// list interfaces
 
-	list_interfaces(socket, name);
+	list_interfaces(name);
 	return 0;
 }
 
Index: src/bin/network/route/route.cpp
===================================================================
--- src/bin/network/route/route.cpp	(revision 37465)
+++ src/bin/network/route/route.cpp	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2007, Haiku, Inc. All Rights Reserved.
+ * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
@@ -39,27 +39,57 @@
 	RTM_FLUSH,
 };
 
+enum preferred_output_format
+{
+	PREFER_OUTPUT_MASK,
+	PREFER_OUTPUT_PREFIX_LENGTH,
+};
+
 struct address_family {
 	int			family;
 	const char*	name;
 	const char*	identifiers[4];
+	preferred_output_format	preferred_format;
 	bool		(*parse_address)(const char* string, sockaddr* _address);
+	bool		(*prefix_length_to_mask)(uint8 prefixLength, sockaddr* mask);
+	uint8		(*mask_to_prefix_length)(sockaddr* mask);
 	const char*	(*address_to_string)(sockaddr* address);
 };
 
 // AF_INET family
 static bool inet_parse_address(const char* string, sockaddr* address);
+static bool inet_prefix_length_to_mask(uint8 prefixLength, sockaddr* mask);
+static uint8 inet_mask_to_prefix_length(sockaddr* mask);
 static const char* inet_address_to_string(sockaddr* address);
 
+// AF_INET6 family
+static bool inet6_parse_address(const char* string, sockaddr* address);
+static bool inet6_prefix_length_to_mask(uint8 prefixLength, sockaddr* mask);
+static uint8 inet6_mask_to_prefix_length(sockaddr* mask);
+static const char* inet6_address_to_string(sockaddr* address);
+
 static const address_family kFamilies[] = {
 	{
 		AF_INET,
 		"inet",
 		{"AF_INET", "inet", "ipv4", NULL},
+		PREFER_OUTPUT_MASK,
 		inet_parse_address,
+		inet_prefix_length_to_mask,
+		inet_mask_to_prefix_length,
 		inet_address_to_string,
 	},
-	{ -1, NULL, {NULL}, NULL, NULL }
+	{
+		AF_INET6,
+		"inet6",
+		{"AF_INET6", "inet6", "ipv6", NULL},
+		PREFER_OUTPUT_PREFIX_LENGTH,
+		inet6_parse_address,
+		inet6_prefix_length_to_mask,
+		inet6_mask_to_prefix_length,
+		inet6_address_to_string,
+	},
+	{ -1, NULL, {NULL}, PREFER_OUTPUT_MASK, NULL, NULL, NULL, NULL }
 };
 
 
@@ -82,6 +112,49 @@
 }
 
 
+static bool
+inet_prefix_length_to_mask(uint8 prefixLength, sockaddr* _mask)
+{
+	if (prefixLength > 32)
+		return false;
+
+	sockaddr_in& mask = *(sockaddr_in *)_mask;
+	mask.sin_family = AF_INET;
+        mask.sin_len = sizeof(sockaddr_in);
+	mask.sin_port = 0;
+	memset(&mask.sin_zero[0], 0, sizeof(mask.sin_zero));
+
+	uint32 u32mask = 0;
+	for (uint8 i = 32; i > 32 - prefixLength; i--)
+		u32mask |= 1 << (i - 1);
+	mask.sin_addr.s_addr = htonl(u32mask);
+
+	return true;
+}
+
+
+static uint8
+inet_mask_to_prefix_length(sockaddr* _mask)
+{
+	if (_mask == NULL)
+		return 32;
+
+	sockaddr_in& mask = *(sockaddr_in *)_mask;
+	if (mask.sin_family != AF_INET)
+	    return (uint8)-1;
+
+	uint8 result = 0;
+	uint32 u32mask = ntohl(mask.sin_addr.s_addr);
+	for (uint8 i = 32; i > 0; i--) {
+		if (u32mask & (1 << (i - 1)) == 0)
+			break;
+		result++;
+	}
+
+	return result;
+}
+
+
 static const char *
 inet_address_to_string(sockaddr* address)
 {
@@ -92,6 +165,93 @@
 }
 
 
+static bool
+inet6_parse_address(const char* string, sockaddr* _address)
+{
+	sockaddr_in6& address = *(sockaddr_in6 *)_address;
+
+	if (inet_pton(AF_INET6, string, &address.sin6_addr) != 1)
+		return false;
+
+	address.sin6_family = AF_INET6;
+	address.sin6_len = sizeof(sockaddr_in6);
+	address.sin6_port = 0;
+	address.sin6_flowinfo = 0;
+	address.sin6_scope_id = 0;
+
+	return true;
+}
+
+
+static bool
+inet6_prefix_length_to_mask(uint8 prefixLength, sockaddr* _mask)
+{
+	if (prefixLength > 128)
+		return false;
+
+	sockaddr_in6& mask = *(sockaddr_in6 *)_mask;
+	mask.sin6_family = AF_INET6;
+	mask.sin6_len = sizeof(sockaddr_in6);
+	mask.sin6_port = 0;
+	mask.sin6_flowinfo = 0;
+	mask.sin6_scope_id = 0;
+	memset(mask.sin6_addr.s6_addr, 0, sizeof(in6_addr));
+
+	for (uint8 i = 0; i < sizeof(in6_addr); i++, prefixLength -= 8) {
+		if (prefixLength < 8) {
+			const uint8 masks[] = {
+				0x00, 0x80, 0xc0, 0xe0,
+				0xf0, 0xf8, 0xfc, 0xfe
+			};
+			mask.sin6_addr.s6_addr[i] = masks[prefixLength];
+			break;
+		}
+
+		mask.sin6_addr.s6_addr[i] = 0xff;
+	}
+
+	return true;
+}
+
+
+static uint8
+inet6_mask_to_prefix_length(sockaddr* _mask)
+{
+	if (_mask == NULL)
+		return 128;
+
+	sockaddr_in6& mask = *(sockaddr_in6 *)_mask;
+	if (mask.sin6_family != AF_INET6)
+	    return (uint8)-1;
+
+	uint8 result = 0;
+	for (uint8 i = 0; i < sizeof(in6_addr); i++) {
+		for (uint8 j = 0; j < 8; j++) {
+			if (!(mask.sin6_addr.s6_addr[i] & (1 << j)))
+				return result;
+			result++;
+		}
+	}
+
+	return 128;
+}
+
+
+static const char*
+inet6_address_to_string(sockaddr* address)
+{
+	if (address == NULL || address->sa_family != AF_INET6)
+		return "-";
+
+	static char buffer[INET6_ADDRSTRLEN];
+
+	inet_ntop(AF_INET6, &((sockaddr_in6 *)address)->sin6_addr,
+		buffer, sizeof(buffer));
+
+	return buffer;
+}
+
+
 //	#pragma mark -
 
 
@@ -100,13 +260,14 @@
 {
 	printf("usage: %s [command] [<interface>] [<address family>] <address|default> [<option/flags>...]\n"
 		"Where <command> can be the one of:\n"
-		"  add             - add a route for the specified interface\n"
-		"  delete          - deletes the specified route\n"
-		"  list            - list with filters [default]\n"
+		"  add                - add a route for the specified interface\n"
+		"  delete             - deletes the specified route\n"
+		"  list               - list with filters [default]\n"
 		"<option> can be the following:\n"
-		"  netmask <addr>  - networking subnet mask\n"
-		"  gw <addr>       - gateway address\n"
-		"  mtu <bytes>     - maximal transfer unit\n"
+		"  netmask <addr>     - networking subnet mask\n"
+		"  prefixlen <number> - subnet mask length in bits\n"
+		"  gw <addr>          - gateway address\n"
+		"  mtu <bytes>        - maximal transfer unit\n"
 		"And <flags> can be: reject, local, host\n\n"
 		"Example:\n"
 		"\t%s add /dev/net/ipro1000/0 default gw 192.168.0.254\n",
@@ -158,6 +319,23 @@
 }
 
 
+bool
+prefix_length_to_mask(int32 familyIndex, const char* argument,
+	struct sockaddr_storage& mask)
+{
+	if (argument == NULL)
+		return false;
+
+	char *end;
+	uint32 prefixLength = strtoul(argument, &end, 10);
+	if (end == argument)
+		return false;
+
+	return kFamilies[familyIndex].prefix_length_to_mask(
+		(uint8)prefixLength, (sockaddr *)&mask);
+}
+
+
 //	#pragma mark -
 
 
@@ -172,10 +350,8 @@
 		return;
 
 	uint32 size = (uint32)config.ifc_value;
-	if (size == 0) {
-		fprintf(stderr, "%s: There are no routes!\n", kProgramName);
+	if (size == 0)
 		return;
-	}
 
 	void *buffer = malloc(size);
 	if (buffer == NULL) {
@@ -206,9 +382,18 @@
 			}
 
 			if (family != NULL) {
-				printf("%15s ", family->address_to_string(route.destination));
-				printf("mask %-15s ", family->address_to_string(route.mask));
-	
+				// TODO: is the %15s format OK for IPv6?
+				printf("%15s", family->address_to_string(route.destination));
+				switch (family->preferred_format) {
+					case PREFER_OUTPUT_MASK:
+						printf(" mask %-15s ",
+							family->address_to_string(route.mask));
+						break;
+					case PREFER_OUTPUT_PREFIX_LENGTH:
+						printf("/%u ",
+							family->mask_to_prefix_length(route.mask));
+						break;
+				}
 				if (route.flags & RTF_GATEWAY)
 					printf("gateway %-15s ", family->address_to_string(route.gateway));
 			} else {
@@ -321,8 +506,17 @@
 	}
 
 	if (family != NULL) {
-		printf("%s ", family->address_to_string(request.destination));
-		printf("mask %s ", family->address_to_string(request.mask));
+		printf("%s", family->address_to_string(request.destination));
+		switch (family->preferred_format) {
+			case PREFER_OUTPUT_MASK:
+				printf(" mask %s ",
+					family->address_to_string(request.mask));
+				break;
+			case PREFER_OUTPUT_PREFIX_LENGTH:
+				printf("/%u ",
+					family->mask_to_prefix_length(request.mask));
+				break;
+		}
 
 		if (request.flags & RTF_GATEWAY)
 			printf("gateway %s ", family->address_to_string(request.gateway));
@@ -386,7 +580,8 @@
 
 	while (i < argc && i < 5) {
 		// try to parse address family
-		if (i <= 3 && familyIndex == -1 && get_address_family(argv[i], familyIndex)) {
+		if (i <= 3 && familySpecified == false
+				&& get_address_family(argv[i], familyIndex)) {
 			familySpecified = true;
 			if (i == 2)
 				interfaceIndex = -1;
@@ -432,7 +627,7 @@
 			i++;
 		} else if (!strcmp(argv[i], "nm") || !strcmp(argv[i], "netmask")) {
 			if (hasMask) {
-				fprintf(stderr, "%s: Netmask is specified twice\n",
+				fprintf(stderr, "%s: Netmask or prefix length is specified twice\n",
 					kProgramName);
 				exit(1);
 			}
@@ -443,6 +638,19 @@
 			}
 			hasMask = true;
 			i++;
+		} else if (!strcmp(argv[i], "plen") || !strcmp(argv[i], "prefixlen")) {
+			if (hasMask) {
+				fprintf(stderr, "%s: Netmask or prefix length is specified twice\n",
+					kProgramName);
+				exit(1);
+			}
+			if (!prefix_length_to_mask(familyIndex, argv[i + 1], mask)) {
+				fprintf(stderr, "%s: Option 'prefixlen' is invalid for this "
+					"address family\n", kProgramName);
+				exit(1);
+			}
+			hasMask = true;
+			i++;
 		} else if (!strcmp(argv[i], "mtu")) {
 			route.mtu = argv[i + 1] ? strtol(argv[i + 1], NULL, 0) : 0;
 			if (route.mtu <= 500) {
@@ -505,7 +713,7 @@
 				list_routes(socket, interface, route);
 			else {
 				for (int32 i = 0; kFamilies[i].family >= 0; i++) {
-					int socket = ::socket(kFamilies[familyIndex].family, SOCK_DGRAM, 0);
+					int socket = ::socket(kFamilies[i].family, SOCK_DGRAM, 0);
 					if (socket < 0)
 						continue;
 
Index: src/bin/network/Jamfile
===================================================================
--- src/bin/network/Jamfile	(revision 37465)
+++ src/bin/network/Jamfile	(working copy)
@@ -15,6 +15,7 @@
 #SubInclude HAIKU_TOP src bin network pppconfig ;
 #SubInclude HAIKU_TOP src bin network ppp_up ;
 SubInclude HAIKU_TOP src bin network ping ;
+SubInclude HAIKU_TOP src bin network ping6 ;
 SubInclude HAIKU_TOP src bin network route ;
 SubInclude HAIKU_TOP src bin network setwep ;
 SubInclude HAIKU_TOP src bin network tcpdump ;
Index: src/bin/network/tcpdump/Jamfile
===================================================================
--- src/bin/network/tcpdump/Jamfile	(revision 37465)
+++ src/bin/network/tcpdump/Jamfile	(working copy)
@@ -4,7 +4,7 @@
 UseHeaders [ FDirName $(SUBDIR) ] : true ;
 UseHeaders [ FDirName $(SUBDIR) libpcap ] : true ;
 
-local defines = [ FDefines HAVE_CONFIG_H=1 _U_=\"__attribute__((unused))\" ] ;
+local defines = [ FDefines HAVE_CONFIG_H=1 _U_=\"__attribute__((unused))\" INET6=1 HAVE_SOCKADDR_STORAGE=1 ] ;
 
 SubDirCcFlags $(defines) ;
 SubDirC++Flags $(defines) ;
@@ -39,7 +39,7 @@
 	print-cnfp.c
 	print-dccp.c
 	print-decnet.c
-	#print-dhcp6.c
+	print-dhcp6.c
 	print-domain.c
 	print-dvmrp.c
 	print-eap.c
@@ -50,16 +50,16 @@
 	print-ether.c
 	print-fddi.c
 	print-fr.c
-	#print-frag6.c
+	print-frag6.c
 	print-gre.c
 	print-hsrp.c
 	print-icmp.c
-	#print-icmp6.c
+	print-icmp6.c
 	print-igmp.c
 	print-igrp.c
 	print-ip.c
-	#print-ip6.c
-	#print-ip6opts.c
+	print-ip6.c
+	print-ip6opts.c
 	print-ipcomp.c
 	print-ipfc.c
 	print-ipx.c
@@ -83,7 +83,7 @@
 	print-ntp.c
 	print-null.c
 	print-ospf.c
-	#print-ospf6.c
+	print-ospf6.c
 	print-pflog.c
 	print-pgm.c
 	print-pim.c
@@ -95,7 +95,7 @@
 	print-rip.c
 	print-ripng.c
 	print-rsvp.c
-	#print-rt6.c
+	print-rt6.c
 	print-rx.c
 	print-sctp.c
 	print-sip.c
Index: data/system/boot/Netscript
===================================================================
--- data/system/boot/Netscript	(revision 37465)
+++ data/system/boot/Netscript	(working copy)
@@ -4,3 +4,12 @@
 
 # This adds the default gateway. Edit it for your needs
 #route add /dev/net/ipro1000/0 default gw 192.168.0.1
+
+# configure IPv6 address on loopback interface
+ifconfig loop:0 inet6 ::1
+
+# configure IPv6 address on ethernet interface
+ifconfig /dev/net/etherpci/0:0 inet6 fc00::1 plen 64
+
+# configure IPv6 default route
+route add /dev/net/etherpci/0:0 inet6 :: plen 0 gateway fc00::1
Index: data/etc/profile
===================================================================
--- data/etc/profile	(revision 37465)
+++ data/etc/profile	(working copy)
@@ -29,7 +29,7 @@
 
 #
 # An almost-ksh compatible `whence' command.  This is as hairy as it is
-# because of the desire to exactly mimic ksh.
+# because of the \desire to exactly mimic ksh.
 #
 # This depends somewhat on knowing the format of the output of the bash
 # `builtin type' command.
@@ -103,3 +103,49 @@
     . /etc/bash_completion
 fi
 
+alias dmesg='tail -f /var/log/syslog'
+
+
+ipv6_network_up()
+{
+	# configure IPv6 address on loopback interface
+	#ifconfig loop:0 inet6 ::1 up
+
+	# remove IPv4 interface
+	#ifconfig -d /dev/net/etherpci/0
+
+	# configure IPv6 address on ethernet interface
+	ifconfig /dev/net/etherpci/0 inet6 fc00::1 plen 64 up
+
+	# configure IPv6 default route
+	#route add /dev/net/etherpci/0 inet6 :: plen 0 gateway fc00::2
+}
+
+ip6demo()
+{
+# configure IPv6 address on loopback interface
+ifconfig loop:0 inet6 ::1 up
+
+# remove existing IPv4 interface
+ifconfig -d /dev/net/etherpci/0
+
+# configure IPv6 address on ethernet interface
+ifconfig /dev/net/etherpci/0 inet6 fc00::1 plen 64 up
+
+# configure IPv6 default route
+route add /dev/net/etherpci/0 inet6 :: plen 0 gateway fc00::2
+
+# test ping to local address
+ping6 -c 3 ::1
+
+# test ping to remote address
+ping6 -c 3 fc00::2
+}
+
+ip6ping()
+{
+ping6 -c 3 fc00::2
+}
+
+
+alias ip6up='ipv6_network_up'
Index: headers/posix/netinet/icmp6.h
===================================================================
--- headers/posix/netinet/icmp6.h	(revision 0)
+++ headers/posix/netinet/icmp6.h	(revision 0)
@@ -0,0 +1,538 @@
+/*-
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_ICMP6_H_
+#define _NETINET_ICMP6_H_
+
+#include <endian.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <netinet6/in6.h>
+
+#define ICMPV6_PLD_MAXLEN	1232	/* IPV6_MMTU - sizeof(struct ip6_hdr)
+					   - sizeof(struct icmp6_hdr) */
+
+struct icmp6_hdr {
+	uint8_t	icmp6_type;	/* type field */
+	uint8_t	icmp6_code;	/* code field */
+	uint16_t	icmp6_cksum;	/* checksum field */
+	union {
+		uint32_t	icmp6_un_data32[1]; /* type-specific field */
+		uint16_t	icmp6_un_data16[2]; /* type-specific field */
+		uint8_t		icmp6_un_data8[4];  /* type-specific field */
+	} icmp6_dataun;
+} _PACKED;
+
+#define icmp6_data32	icmp6_dataun.icmp6_un_data32
+#define icmp6_data16	icmp6_dataun.icmp6_un_data16
+#define icmp6_data8	icmp6_dataun.icmp6_un_data8
+#define icmp6_pptr	icmp6_data32[0]		/* parameter prob */
+#define icmp6_mtu	icmp6_data32[0]		/* packet too big */
+#define icmp6_id	icmp6_data16[0]		/* echo request/reply */
+#define icmp6_seq	icmp6_data16[1]		/* echo request/reply */
+#define icmp6_maxdelay	icmp6_data16[0]		/* mcast group membership */
+
+#define ICMP6_DST_UNREACH		1	/* dest unreachable, codes: */
+#define ICMP6_PACKET_TOO_BIG	2	/* packet too big */
+#define ICMP6_TIME_EXCEEDED		3	/* time exceeded, code: */
+#define ICMP6_PARAM_PROB		4	/* ip6 header bad */
+
+#define ICMP6_ECHO_REQUEST		128	/* echo service */
+#define ICMP6_ECHO_REPLY		129	/* echo reply */
+#define MLD_LISTENER_QUERY		130 	/* multicast listener query */
+#define MLD_LISTENER_REPORT		131	/* multicast listener report */
+#define MLD_LISTENER_DONE		132	/* multicast listener done */
+#define MLD_LISTENER_REDUCTION MLD_LISTENER_DONE /* RFC3542 definition */
+
+/* RFC2292 decls */
+#define ICMP6_MEMBERSHIP_QUERY		130	/* group membership query */
+#define ICMP6_MEMBERSHIP_REPORT		131	/* group membership report */
+#define ICMP6_MEMBERSHIP_REDUCTION	132	/* group membership termination */
+
+#ifndef _KERNEL
+/* the followings are for backward compatibility to old KAME apps. */
+#define MLD6_LISTENER_QUERY	MLD_LISTENER_QUERY
+#define MLD6_LISTENER_REPORT	MLD_LISTENER_REPORT
+#define MLD6_LISTENER_DONE	MLD_LISTENER_DONE
+#endif
+
+#define ND_ROUTER_SOLICIT		133	/* router solicitation */
+#define ND_ROUTER_ADVERT		134	/* router advertisement */
+#define ND_NEIGHBOR_SOLICIT		135	/* neighbor solicitation */
+#define ND_NEIGHBOR_ADVERT		136	/* neighbor advertisement */
+#define ND_REDIRECT			137	/* redirect */
+
+#define ICMP6_ROUTER_RENUMBERING	138	/* router renumbering */
+
+#define ICMP6_WRUREQUEST		139	/* who are you request */
+#define ICMP6_WRUREPLY			140	/* who are you reply */
+#define ICMP6_FQDN_QUERY		139	/* FQDN query */
+#define ICMP6_FQDN_REPLY		140	/* FQDN reply */
+#define ICMP6_NI_QUERY			139	/* node information request */
+#define ICMP6_NI_REPLY			140	/* node information reply */
+#define MLDV2_LISTENER_REPORT		143	/* RFC3810 listener report */
+
+/* The definitions below are experimental. TBA */
+#define MLD_MTRACE_RESP			200	/* mtrace resp (to sender) */
+#define MLD_MTRACE			201	/* mtrace messages */
+
+#ifndef _KERNEL
+#define MLD6_MTRACE_RESP	MLD_MTRACE_RESP
+#define MLD6_MTRACE		MLD_MTRACE
+#endif
+
+#define ICMP6_MAXTYPE			201
+
+#define ICMP6_DST_UNREACH_NOROUTE	0	/* no route to destination */
+#define ICMP6_DST_UNREACH_ADMIN	 	1	/* administratively prohibited */
+#define ICMP6_DST_UNREACH_NOTNEIGHBOR	2	/* not a neighbor(obsolete) */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE	2	/* beyond scope of source address */
+#define ICMP6_DST_UNREACH_ADDR		3	/* address unreachable */
+#define ICMP6_DST_UNREACH_NOPORT	4	/* port unreachable */
+
+#define ICMP6_TIME_EXCEED_TRANSIT 	0	/* ttl==0 in transit */
+#define ICMP6_TIME_EXCEED_REASSEMBLY	1	/* ttl==0 in reass */
+
+#define ICMP6_PARAMPROB_HEADER 	 	0	/* erroneous header field */
+#define ICMP6_PARAMPROB_NEXTHEADER	1	/* unrecognized next header */
+#define ICMP6_PARAMPROB_OPTION		2	/* unrecognized option */
+
+#define ICMP6_INFOMSG_MASK		0x80	/* all informational messages */
+
+#define ICMP6_NI_SUBJ_IPV6	0	/* Query Subject is an IPv6 address */
+#define ICMP6_NI_SUBJ_FQDN	1	/* Query Subject is a Domain name */
+#define ICMP6_NI_SUBJ_IPV4	2	/* Query Subject is an IPv4 address */
+
+#define ICMP6_NI_SUCCESS	0	/* node information successful reply */
+#define ICMP6_NI_REFUSED	1	/* node information request is refused */
+#define ICMP6_NI_UNKNOWN	2	/* unknown Qtype */
+
+#define ICMP6_ROUTER_RENUMBERING_COMMAND  0	/* rr command */
+#define ICMP6_ROUTER_RENUMBERING_RESULT   1	/* rr result */
+#define ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET   255	/* rr seq num reset */
+
+/* Used in kernel only */
+#define ND_REDIRECT_ONLINK	0	/* redirect to an on-link node */
+#define ND_REDIRECT_ROUTER	1	/* redirect to a better router */
+
+/*
+ * Multicast Listener Discovery
+ */
+struct mld_hdr {
+	struct icmp6_hdr	mld_icmp6_hdr;
+	struct in6_addr		mld_addr; /* multicast address */
+} _PACKED;
+
+/* definitions to provide backward compatibility to old KAME applications */
+#ifndef _KERNEL
+#define mld6_hdr	mld_hdr
+#define mld6_type	mld_type
+#define mld6_code	mld_code
+#define mld6_cksum	mld_cksum
+#define mld6_maxdelay	mld_maxdelay
+#define mld6_reserved	mld_reserved
+#define mld6_addr	mld_addr
+#endif
+
+/* shortcut macro definitions */
+#define mld_type	mld_icmp6_hdr.icmp6_type
+#define mld_code	mld_icmp6_hdr.icmp6_code
+#define mld_cksum	mld_icmp6_hdr.icmp6_cksum
+#define mld_maxdelay	mld_icmp6_hdr.icmp6_data16[0]
+#define mld_reserved	mld_icmp6_hdr.icmp6_data16[1]
+#define mld_v2_reserved	mld_icmp6_hdr.icmp6_data16[0]
+#define mld_v2_numrecs	mld_icmp6_hdr.icmp6_data16[1]
+
+/*
+ * Neighbor Discovery
+ */
+
+struct nd_router_solicit {	/* router solicitation */
+	struct icmp6_hdr 	nd_rs_hdr;
+	/* could be followed by options */
+} _PACKED;
+
+#define nd_rs_type	nd_rs_hdr.icmp6_type
+#define nd_rs_code	nd_rs_hdr.icmp6_code
+#define nd_rs_cksum	nd_rs_hdr.icmp6_cksum
+#define nd_rs_reserved	nd_rs_hdr.icmp6_data32[0]
+
+struct nd_router_advert {	/* router advertisement */
+	struct icmp6_hdr	nd_ra_hdr;
+	uint32_t		nd_ra_reachable;	/* reachable time */
+	uint32_t		nd_ra_retransmit;	/* retransmit timer */
+	/* could be followed by options */
+} _PACKED;
+
+#define nd_ra_type		nd_ra_hdr.icmp6_type
+#define nd_ra_code		nd_ra_hdr.icmp6_code
+#define nd_ra_cksum		nd_ra_hdr.icmp6_cksum
+#define nd_ra_curhoplimit	nd_ra_hdr.icmp6_data8[0]
+#define nd_ra_flags_reserved	nd_ra_hdr.icmp6_data8[1]
+#define ND_RA_FLAG_MANAGED	0x80
+#define ND_RA_FLAG_OTHER	0x40
+#define ND_RA_FLAG_HA		0x20
+
+/*
+ * Router preference values based on draft-draves-ipngwg-router-selection-01.
+ * These are non-standard definitions.
+ */
+#define ND_RA_FLAG_RTPREF_MASK	0x18 /* 00011000 */
+
+#define ND_RA_FLAG_RTPREF_HIGH	0x08 /* 00001000 */
+#define ND_RA_FLAG_RTPREF_MEDIUM	0x00 /* 00000000 */
+#define ND_RA_FLAG_RTPREF_LOW	0x18 /* 00011000 */
+#define ND_RA_FLAG_RTPREF_RSV	0x10 /* 00010000 */
+
+#define nd_ra_router_lifetime	nd_ra_hdr.icmp6_data16[1]
+
+struct nd_neighbor_solicit {	/* neighbor solicitation */
+	struct icmp6_hdr	nd_ns_hdr;
+	struct in6_addr		nd_ns_target;	/*target address */
+	/* could be followed by options */
+} _PACKED;
+
+#define nd_ns_type		nd_ns_hdr.icmp6_type
+#define nd_ns_code		nd_ns_hdr.icmp6_code
+#define nd_ns_cksum		nd_ns_hdr.icmp6_cksum
+#define nd_ns_reserved		nd_ns_hdr.icmp6_data32[0]
+
+struct nd_neighbor_advert {	/* neighbor advertisement */
+	struct icmp6_hdr	nd_na_hdr;
+	struct in6_addr		nd_na_target;	/* target address */
+	/* could be followed by options */
+} _PACKED;
+
+#define nd_na_type		nd_na_hdr.icmp6_type
+#define nd_na_code		nd_na_hdr.icmp6_code
+#define nd_na_cksum		nd_na_hdr.icmp6_cksum
+#define nd_na_flags_reserved	nd_na_hdr.icmp6_data32[0]
+#if BYTE_ORDER == BIG_ENDIAN
+#define ND_NA_FLAG_ROUTER		0x80000000
+#define ND_NA_FLAG_SOLICITED	0x40000000
+#define ND_NA_FLAG_OVERRIDE		0x20000000
+#else
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define ND_NA_FLAG_ROUTER		0x80
+#define ND_NA_FLAG_SOLICITED	0x40
+#define ND_NA_FLAG_OVERRIDE		0x20
+#endif
+#endif
+
+struct nd_redirect {		/* redirect */
+	struct icmp6_hdr	nd_rd_hdr;
+	struct in6_addr		nd_rd_target;	/* target address */
+	struct in6_addr		nd_rd_dst;	/* destination address */
+	/* could be followed by options */
+} _PACKED;
+
+#define nd_rd_type		nd_rd_hdr.icmp6_type
+#define nd_rd_code		nd_rd_hdr.icmp6_code
+#define nd_rd_cksum		nd_rd_hdr.icmp6_cksum
+#define nd_rd_reserved		nd_rd_hdr.icmp6_data32[0]
+
+struct nd_opt_hdr {		/* Neighbor discovery option header */
+	uint8_t	nd_opt_type;
+	uint8_t	nd_opt_len;
+	/* followed by option specific data*/
+} _PACKED;
+
+#define ND_OPT_SOURCE_LINKADDR		1
+#define ND_OPT_TARGET_LINKADDR		2
+#define ND_OPT_PREFIX_INFORMATION	3
+#define ND_OPT_REDIRECTED_HEADER	4
+#define ND_OPT_MTU			5
+
+#define ND_OPT_ROUTE_INFO		200	/* draft-ietf-ipngwg-router-preference, not officially assigned yet */
+
+struct nd_opt_prefix_info {	/* prefix information */
+	uint8_t		nd_opt_pi_type;
+	uint8_t		nd_opt_pi_len;
+	uint8_t		nd_opt_pi_prefix_len;
+	uint8_t		nd_opt_pi_flags_reserved;
+	uint32_t	nd_opt_pi_valid_time;
+	uint32_t	nd_opt_pi_preferred_time;
+	uint32_t	nd_opt_pi_reserved2;
+	struct in6_addr	nd_opt_pi_prefix;
+} _PACKED;
+
+#define ND_OPT_PI_FLAG_ONLINK		0x80
+#define ND_OPT_PI_FLAG_AUTO			0x40
+
+struct nd_opt_rd_hdr {		/* redirected header */
+	uint8_t		nd_opt_rh_type;
+	uint8_t		nd_opt_rh_len;
+	uint16_t	nd_opt_rh_reserved1;
+	uint32_t	nd_opt_rh_reserved2;
+	/* followed by IP header and data */
+} _PACKED;
+
+struct nd_opt_mtu {		/* MTU option */
+	uint8_t		nd_opt_mtu_type;
+	uint8_t		nd_opt_mtu_len;
+	uint16_t	nd_opt_mtu_reserved;
+	uint32_t	nd_opt_mtu_mtu;
+} _PACKED;
+
+struct nd_opt_route_info {	/* route info */
+	uint8_t		nd_opt_rti_type;
+	uint8_t		nd_opt_rti_len;
+	uint8_t		nd_opt_rti_prefixlen;
+	uint8_t		nd_opt_rti_flags;
+	uint32_t	nd_opt_rti_lifetime;
+	/* prefix follows */
+} _PACKED;
+
+/*
+ * icmp6 namelookup
+ */
+
+struct icmp6_namelookup {
+	struct icmp6_hdr 	icmp6_nl_hdr;
+	uint8_t		icmp6_nl_nonce[8];
+	int32_t		icmp6_nl_ttl;
+#if 0
+	uint8_t		icmp6_nl_len;
+	uint8_t		icmp6_nl_name[3];
+#endif
+	/* could be followed by options */
+} _PACKED;
+
+/*
+ * icmp6 node information
+ */
+struct icmp6_nodeinfo {
+	struct icmp6_hdr icmp6_ni_hdr;
+	uint8_t icmp6_ni_nonce[8];
+	/* could be followed by reply data */
+} _PACKED;
+
+#define ni_type		icmp6_ni_hdr.icmp6_type
+#define ni_code		icmp6_ni_hdr.icmp6_code
+#define ni_cksum	icmp6_ni_hdr.icmp6_cksum
+#define ni_qtype	icmp6_ni_hdr.icmp6_data16[0]
+#define ni_flags	icmp6_ni_hdr.icmp6_data16[1]
+
+#define NI_QTYPE_NOOP		0 /* NOOP  */
+#define NI_QTYPE_SUPTYPES	1 /* Supported Qtypes */
+#define NI_QTYPE_FQDN		2 /* FQDN (draft 04) */
+#define NI_QTYPE_DNSNAME	2 /* DNS Name */
+#define NI_QTYPE_NODEADDR	3 /* Node Addresses */
+#define NI_QTYPE_IPV4ADDR	4 /* IPv4 Addresses */
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define NI_SUPTYPE_FLAG_COMPRESS	0x1
+#define NI_FQDN_FLAG_VALIDTTL		0x1
+#elif BYTE_ORDER == LITTLE_ENDIAN
+#define NI_SUPTYPE_FLAG_COMPRESS	0x0100
+#define NI_FQDN_FLAG_VALIDTTL		0x0100
+#endif
+
+#ifdef NAME_LOOKUPS_04
+#if BYTE_ORDER == BIG_ENDIAN
+#define NI_NODEADDR_FLAG_LINKLOCAL	0x1
+#define NI_NODEADDR_FLAG_SITELOCAL	0x2
+#define NI_NODEADDR_FLAG_GLOBAL		0x4
+#define NI_NODEADDR_FLAG_ALL		0x8
+#define NI_NODEADDR_FLAG_TRUNCATE	0x10
+#define NI_NODEADDR_FLAG_ANYCAST	0x20 /* just experimental. not in spec */
+#elif BYTE_ORDER == LITTLE_ENDIAN
+#define NI_NODEADDR_FLAG_LINKLOCAL	0x0100
+#define NI_NODEADDR_FLAG_SITELOCAL	0x0200
+#define NI_NODEADDR_FLAG_GLOBAL		0x0400
+#define NI_NODEADDR_FLAG_ALL		0x0800
+#define NI_NODEADDR_FLAG_TRUNCATE	0x1000
+#define NI_NODEADDR_FLAG_ANYCAST	0x2000 /* just experimental. not in spec */
+#endif
+#else  /* draft-ietf-ipngwg-icmp-name-lookups-05 (and later?) */
+#if BYTE_ORDER == BIG_ENDIAN
+#define NI_NODEADDR_FLAG_TRUNCATE	0x1
+#define NI_NODEADDR_FLAG_ALL		0x2
+#define NI_NODEADDR_FLAG_COMPAT		0x4
+#define NI_NODEADDR_FLAG_LINKLOCAL	0x8
+#define NI_NODEADDR_FLAG_SITELOCAL	0x10
+#define NI_NODEADDR_FLAG_GLOBAL		0x20
+#define NI_NODEADDR_FLAG_ANYCAST	0x40 /* just experimental. not in spec */
+#elif BYTE_ORDER == LITTLE_ENDIAN
+#define NI_NODEADDR_FLAG_TRUNCATE	0x0100
+#define NI_NODEADDR_FLAG_ALL		0x0200
+#define NI_NODEADDR_FLAG_COMPAT		0x0400
+#define NI_NODEADDR_FLAG_LINKLOCAL	0x0800
+#define NI_NODEADDR_FLAG_SITELOCAL	0x1000
+#define NI_NODEADDR_FLAG_GLOBAL		0x2000
+#define NI_NODEADDR_FLAG_ANYCAST	0x4000 /* just experimental. not in spec */
+#endif
+#endif
+
+struct ni_reply_fqdn {
+	uint32_t ni_fqdn_ttl;	/* TTL */
+	uint8_t ni_fqdn_namelen; /* length in octets of the FQDN */
+	uint8_t ni_fqdn_name[3]; /* XXX: alignment */
+} _PACKED;
+
+/*
+ * Router Renumbering. as router-renum-08.txt
+ */
+struct icmp6_router_renum {	/* router renumbering header */
+	struct icmp6_hdr	rr_hdr;
+	uint8_t	rr_segnum;
+	uint8_t	rr_flags;
+	uint16_t	rr_maxdelay;
+	uint32_t	rr_reserved;
+} _PACKED;
+
+#define ICMP6_RR_FLAGS_TEST			0x80
+#define ICMP6_RR_FLAGS_REQRESULT	0x40
+#define ICMP6_RR_FLAGS_FORCEAPPLY	0x20
+#define ICMP6_RR_FLAGS_SPECSITE		0x10
+#define ICMP6_RR_FLAGS_PREVDONE		0x08
+
+#define rr_type		rr_hdr.icmp6_type
+#define rr_code		rr_hdr.icmp6_code
+#define rr_cksum	rr_hdr.icmp6_cksum
+#define rr_seqnum 	rr_hdr.icmp6_data32[0]
+
+struct rr_pco_match {		/* match prefix part */
+	uint8_t		rpm_code;
+	uint8_t		rpm_len;
+	uint8_t		rpm_ordinal;
+	uint8_t		rpm_matchlen;
+	uint8_t		rpm_minlen;
+	uint8_t		rpm_maxlen;
+	uint16_t	rpm_reserved;
+	struct	in6_addr	rpm_prefix;
+} _PACKED;
+
+#define RPM_PCO_ADD			1
+#define RPM_PCO_CHANGE		2
+#define RPM_PCO_SETGLOBAL	3
+#define RPM_PCO_MAX			4
+
+struct rr_pco_use {		/* use prefix part */
+	uint8_t		rpu_uselen;
+	uint8_t		rpu_keeplen;
+	uint8_t		rpu_ramask;
+	uint8_t		rpu_raflags;
+	uint32_t	rpu_vltime;
+	uint32_t	rpu_pltime;
+	uint32_t	rpu_flags;
+	struct	in6_addr rpu_prefix;
+} _PACKED;
+#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK	0x80
+#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO	0x40
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80000000
+#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40000000
+#elif BYTE_ORDER == LITTLE_ENDIAN
+#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME     0x80
+#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME     0x40
+#endif
+
+struct rr_result {		/* router renumbering result message */
+	uint16_t	rrr_flags;
+	uint8_t		rrr_ordinal;
+	uint8_t		rrr_matchedlen;
+	uint32_t	rrr_ifid;
+	struct	in6_addr rrr_prefix;
+} _PACKED;
+#if BYTE_ORDER == BIG_ENDIAN
+#define ICMP6_RR_RESULT_FLAGS_OOB			0x0002
+#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0001
+#elif BYTE_ORDER == LITTLE_ENDIAN
+#define ICMP6_RR_RESULT_FLAGS_OOB			0x0200
+#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN		0x0100
+#endif
+
+/*
+ * icmp6 filter structures.
+ */
+
+struct icmp6_filter {
+	uint32_t icmp6_filt[8];
+};
+
+#ifdef _KERNEL
+#define	ICMP6_FILTER_SETPASSALL(filterp) \
+do {								\
+	int i; u_char *p;					\
+	p = (u_char *)filterp;					\
+	for (i = 0; i < sizeof(struct icmp6_filter); i++)	\
+		p[i] = 0xff;					\
+} while (/*CONSTCOND*/ 0)
+#define	ICMP6_FILTER_SETBLOCKALL(filterp) \
+	bzero(filterp, sizeof(struct icmp6_filter))
+#else /* _KERNEL */
+#define	ICMP6_FILTER_SETPASSALL(filterp) \
+	memset(filterp, 0xff, sizeof(struct icmp6_filter))
+#define	ICMP6_FILTER_SETBLOCKALL(filterp) \
+	memset(filterp, 0x00, sizeof(struct icmp6_filter))
+#endif /* _KERNEL */
+
+#define	ICMP6_FILTER_SETPASS(type, filterp) \
+	(((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31)))
+#define	ICMP6_FILTER_SETBLOCK(type, filterp) \
+	(((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31)))
+#define	ICMP6_FILTER_WILLPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
+#define	ICMP6_FILTER_WILLBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
+
+#endif /* not _NETINET_ICMP6_H_ */
Index: headers/posix/netinet/ip6.h
===================================================================
--- headers/posix/netinet/ip6.h	(revision 0)
+++ headers/posix/netinet/ip6.h	(revision 0)
@@ -0,0 +1,352 @@
+/*	$FreeBSD: src/sys/netinet/ip6.h,v 1.15 2005/07/20 10:30:52 ume Exp $	*/
+/*	$KAME: ip6.h,v 1.18 2001/03/29 05:34:30 itojun Exp $	*/
+
+/*-
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip.h	8.1 (Berkeley) 6/10/93
+ */
+#ifndef _NETINET_IP6_H_
+#define _NETINET_IP6_H_
+
+#include <BeBuild.h>
+
+/*
+ * Definition for internet protocol version 6.
+ * RFC 2460
+ */
+
+struct ip6_hdr {
+	union {
+		struct ip6_hdrctl {
+			u_int32_t ip6_un1_flow;	/* 20 bits of flow-ID */
+			u_int16_t ip6_un1_plen;	/* payload length */
+			u_int8_t  ip6_un1_nxt;	/* next header */
+			u_int8_t  ip6_un1_hlim;	/* hop limit */
+		} ip6_un1;
+		u_int8_t ip6_un2_vfc;	/* 4 bits version, top 4 bits class */
+	} ip6_ctlun;
+	struct in6_addr ip6_src;	/* source address */
+	struct in6_addr ip6_dst;	/* destination address */
+} _PACKED;
+
+#define ip6_vfc		ip6_ctlun.ip6_un2_vfc
+#define ip6_flow	ip6_ctlun.ip6_un1.ip6_un1_flow
+#define ip6_plen	ip6_ctlun.ip6_un1.ip6_un1_plen
+#define ip6_nxt		ip6_ctlun.ip6_un1.ip6_un1_nxt
+#define ip6_hlim	ip6_ctlun.ip6_un1.ip6_un1_hlim
+#define ip6_hops	ip6_ctlun.ip6_un1.ip6_un1_hlim
+
+#define IPV6_VERSION		0x60
+#define IPV6_VERSION_MASK	0xf0
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define IPV6_FLOWINFO_MASK	0x0fffffff	/* flow info (28 bits) */
+#define IPV6_FLOWLABEL_MASK	0x000fffff	/* flow label (20 bits) */
+#else
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define IPV6_FLOWINFO_MASK	0xffffff0f	/* flow info (28 bits) */
+#define IPV6_FLOWLABEL_MASK	0xffff0f00	/* flow label (20 bits) */
+#endif /* LITTLE_ENDIAN */
+#endif
+#if 1
+/* ECN bits proposed by Sally Floyd */
+#define IP6TOS_CE		0x01	/* congestion experienced */
+#define IP6TOS_ECT		0x02	/* ECN-capable transport */
+#endif
+
+/*
+ * Extension Headers
+ */
+
+struct	ip6_ext {
+	u_int8_t ip6e_nxt;
+	u_int8_t ip6e_len;
+} _PACKED;
+
+/* Hop-by-Hop options header */
+/* XXX should we pad it to force alignment on an 8-byte boundary? */
+struct ip6_hbh {
+	u_int8_t ip6h_nxt;	/* next header */
+	u_int8_t ip6h_len;	/* length in units of 8 octets */
+	/* followed by options */
+} _PACKED;
+
+/* Destination options header */
+/* XXX should we pad it to force alignment on an 8-byte boundary? */
+struct ip6_dest {
+	u_int8_t ip6d_nxt;	/* next header */
+	u_int8_t ip6d_len;	/* length in units of 8 octets */
+	/* followed by options */
+} _PACKED;
+
+/* Option types and related macros */
+#define IP6OPT_PAD1		0x00	/* 00 0 00000 */
+#define IP6OPT_PADN		0x01	/* 00 0 00001 */
+#define IP6OPT_JUMBO		0xC2	/* 11 0 00010 = 194 */
+#define IP6OPT_NSAP_ADDR	0xC3	/* 11 0 00011 */
+#define IP6OPT_TUNNEL_LIMIT	0x04	/* 00 0 00100 */
+#ifndef _KERNEL
+#define IP6OPT_RTALERT		0x05	/* 00 0 00101 (KAME definition) */
+#endif
+#define IP6OPT_ROUTER_ALERT	0x05	/* 00 0 00101 (RFC3542, recommended) */
+
+#define IP6OPT_RTALERT_LEN	4
+#define IP6OPT_RTALERT_MLD	0	/* Datagram contains an MLD message */
+#define IP6OPT_RTALERT_RSVP	1	/* Datagram contains an RSVP message */
+#define IP6OPT_RTALERT_ACTNET	2 	/* contains an Active Networks msg */
+#define IP6OPT_MINLEN		2
+
+#define IP6OPT_EID		0x8a	/* 10 0 01010 */
+
+#define IP6OPT_TYPE(o)		((o) & 0xC0)
+#define IP6OPT_TYPE_SKIP	0x00
+#define IP6OPT_TYPE_DISCARD	0x40
+#define IP6OPT_TYPE_FORCEICMP	0x80
+#define IP6OPT_TYPE_ICMP	0xC0
+
+#define IP6OPT_MUTABLE		0x20
+
+/* IPv6 options: common part */
+struct ip6_opt {
+	u_int8_t ip6o_type;
+	u_int8_t ip6o_len;
+} _PACKED;
+
+/* Jumbo Payload Option */
+struct ip6_opt_jumbo {
+	u_int8_t ip6oj_type;
+	u_int8_t ip6oj_len;
+	u_int8_t ip6oj_jumbo_len[4];
+} _PACKED;
+#define IP6OPT_JUMBO_LEN	6
+
+/* NSAP Address Option */
+struct ip6_opt_nsap {
+	u_int8_t ip6on_type;
+	u_int8_t ip6on_len;
+	u_int8_t ip6on_src_nsap_len;
+	u_int8_t ip6on_dst_nsap_len;
+	/* followed by source NSAP */
+	/* followed by destination NSAP */
+} _PACKED;
+
+/* Tunnel Limit Option */
+struct ip6_opt_tunnel {
+	u_int8_t ip6ot_type;
+	u_int8_t ip6ot_len;
+	u_int8_t ip6ot_encap_limit;
+} _PACKED;
+
+/* Router Alert Option */
+struct ip6_opt_router {
+	u_int8_t ip6or_type;
+	u_int8_t ip6or_len;
+	u_int8_t ip6or_value[2];
+} _PACKED;
+/* Router alert values (in network byte order) */
+#if BYTE_ORDER == BIG_ENDIAN
+#define IP6_ALERT_MLD	0x0000
+#define IP6_ALERT_RSVP	0x0001
+#define IP6_ALERT_AN	0x0002
+#else
+#if BYTE_ORDER == LITTLE_ENDIAN
+#define IP6_ALERT_MLD	0x0000
+#define IP6_ALERT_RSVP	0x0100
+#define IP6_ALERT_AN	0x0200
+#endif /* LITTLE_ENDIAN */
+#endif
+
+/* Routing header */
+struct ip6_rthdr {
+	u_int8_t  ip6r_nxt;	/* next header */
+	u_int8_t  ip6r_len;	/* length in units of 8 octets */
+	u_int8_t  ip6r_type;	/* routing type */
+	u_int8_t  ip6r_segleft;	/* segments left */
+	/* followed by routing type specific data */
+} _PACKED;
+
+/* Type 0 Routing header */
+struct ip6_rthdr0 {
+	u_int8_t  ip6r0_nxt;		/* next header */
+	u_int8_t  ip6r0_len;		/* length in units of 8 octets */
+	u_int8_t  ip6r0_type;		/* always zero */
+	u_int8_t  ip6r0_segleft;	/* segments left */
+	u_int32_t  ip6r0_reserved;	/* reserved field */
+	/* followed by up to 127 struct in6_addr */
+} _PACKED;
+
+/* Fragment header */
+struct ip6_frag {
+	u_int8_t  ip6f_nxt;		/* next header */
+	u_int8_t  ip6f_reserved;	/* reserved field */
+	u_int16_t ip6f_offlg;		/* offset, reserved, and flag */
+	u_int32_t ip6f_ident;		/* identification */
+} _PACKED;
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define IP6F_OFF_MASK		0xfff8	/* mask out offset from _offlg */
+#define IP6F_RESERVED_MASK	0x0006	/* reserved bits in ip6f_offlg */
+#define IP6F_MORE_FRAG		0x0001	/* more-fragments flag */
+#else /* BYTE_ORDER == LITTLE_ENDIAN */
+#define IP6F_OFF_MASK		0xf8ff	/* mask out offset from _offlg */
+#define IP6F_RESERVED_MASK	0x0600	/* reserved bits in ip6f_offlg */
+#define IP6F_MORE_FRAG		0x0100	/* more-fragments flag */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
+
+/*
+ * Internet implementation parameters.
+ */
+#define IPV6_MAXHLIM	255	/* maximum hoplimit */
+#define IPV6_DEFHLIM	64	/* default hlim */
+#define IPV6_FRAGTTL	120	/* ttl for fragment packets, in slowtimo tick */
+#define IPV6_HLIMDEC	1	/* subtracted when forwarding */
+
+#define IPV6_MMTU	1280	/* minimal MTU and reassembly. 1024 + 256 */
+#define IPV6_MAXPACKET	65535	/* ip6 max packet size without Jumbo payload*/
+#define IPV6_MAXOPTHDR	2048	/* max option header size, 256 64-bit words */
+
+#ifdef _KERNEL
+/*
+ * IP6_EXTHDR_CHECK ensures that region between the IP6 header and the
+ * target header (including IPv6 itself, extension headers and
+ * TCP/UDP/ICMP6 headers) are continuous. KAME requires drivers
+ * to store incoming data into one internal mbuf or one or more external
+ * mbufs(never into two or more internal mbufs). Thus, the third case is
+ * supposed to never be matched but is prepared just in case.
+ */
+
+#define IP6_EXTHDR_CHECK(m, off, hlen, ret)				\
+do {									\
+    if ((m)->m_next != NULL) {						\
+	if (((m)->m_flags & M_LOOP) &&					\
+	    ((m)->m_len < (off) + (hlen)) &&				\
+	    (((m) = m_pullup((m), (off) + (hlen))) == NULL)) {		\
+		ip6stat.ip6s_exthdrtoolong++;				\
+		return ret;						\
+	} else if ((m)->m_flags & M_EXT) {				\
+		if ((m)->m_len < (off) + (hlen)) {			\
+			ip6stat.ip6s_exthdrtoolong++;			\
+			m_freem(m);					\
+			return ret;					\
+		}							\
+	} else {							\
+		if ((m)->m_len < (off) + (hlen)) {			\
+			ip6stat.ip6s_exthdrtoolong++;			\
+			m_freem(m);					\
+			return ret;					\
+		}							\
+	}								\
+    } else {								\
+	if ((m)->m_len < (off) + (hlen)) {				\
+		ip6stat.ip6s_tooshort++;				\
+		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);	\
+		m_freem(m);						\
+		return ret;						\
+	}								\
+    }									\
+} while (/*CONSTCOND*/ 0)
+
+/*
+ * IP6_EXTHDR_GET ensures that intermediate protocol header (from "off" to
+ * "len") is located in single mbuf, on contiguous memory region.
+ * The pointer to the region will be returned to pointer variable "val",
+ * with type "typ".
+ * IP6_EXTHDR_GET0 does the same, except that it aligns the structure at the
+ * very top of mbuf.  GET0 is likely to make memory copy than GET.
+ *
+ * XXX we're now testing this, needs m_pulldown()
+ */
+#define IP6_EXTHDR_GET(val, typ, m, off, len) \
+do {									\
+	struct mbuf *t;							\
+	int tmp;							\
+	if ((m)->m_len >= (off) + (len))				\
+		(val) = (typ)(mtod((m), caddr_t) + (off));		\
+	else {								\
+		t = m_pulldown((m), (off), (len), &tmp);		\
+		if (t) {						\
+			if (t->m_len < tmp + (len))			\
+				panic("m_pulldown malfunction");	\
+			(val) = (typ)(mtod(t, caddr_t) + tmp);		\
+		} else {						\
+			(val) = (typ)NULL;				\
+			(m) = NULL;					\
+		}							\
+	}								\
+} while (/*CONSTCOND*/ 0)
+
+#define IP6_EXTHDR_GET0(val, typ, m, off, len) \
+do {									\
+	struct mbuf *t;							\
+	if ((off) == 0)							\
+		(val) = (typ)mtod(m, caddr_t);				\
+	else {								\
+		t = m_pulldown((m), (off), (len), NULL);		\
+		if (t) {						\
+			if (t->m_len < (len))				\
+				panic("m_pulldown malfunction");	\
+			(val) = (typ)mtod(t, caddr_t);			\
+		} else {						\
+			(val) = (typ)NULL;				\
+			(m) = NULL;					\
+		}							\
+	}								\
+} while (/*CONSTCOND*/ 0)
+#endif /*_KERNEL*/
+
+#endif /* not _NETINET_IP6_H_ */
Index: headers/posix/netinet/in.h
===================================================================
--- headers/posix/netinet/in.h	(revision 37465)
+++ headers/posix/netinet/in.h	(working copy)
@@ -46,13 +46,19 @@
 
 /* Protocol definitions */
 #define IPPROTO_IP				0	/* 0, IPv4 */
+#define IPPROTO_HOPOPTS			0	/* 0, IPv6 hop-by-hop options */
 #define IPPROTO_ICMP			1	/* 1, ICMP (v4) */
 #define IPPROTO_IGMP			2	/* 2, IGMP (group management) */
 #define IPPROTO_TCP				6	/* 6, tcp */
 #define IPPROTO_UDP				17	/* 17, UDP */
 #define IPPROTO_IPV6			41	/* 41, IPv6 in IPv6 */
 #define IPPROTO_ROUTING			43	/* 43, Routing */
+#define IPPROTO_FRAGMENT		44	/* 44, IPv6 fragmentation header */
+#define IPPROTO_ESP				50	/* 50, Encap Sec. Payload */
+#define IPPROTO_AH				51	/* 51, Auth Header */
 #define IPPROTO_ICMPV6			58	/* 58, IPv6 ICMP */
+#define IPPROTO_NONE			59	/* 59, IPv6 no next header */
+#define IPPROTO_DSTOPTS			60	/* 60, IPv6 destination option */
 #define IPPROTO_ETHERIP			97	/* 97, Ethernet in IPv4 */
 #define IPPROTO_RAW				255	/* 255 */
 
@@ -149,6 +155,15 @@
 #define IPV6_LEAVE_GROUP			29	/* struct ipv6_mreq */
 #define IPV6_V6ONLY					30	/* int */
 
+#define IPV6_PKTINFO				31	/* struct ipv6_pktinfo */
+#define IPV6_RECVPKTINFO			32	/* struct ipv6_pktinfo */
+#define IPV6_HOPLIMIT				33	/* int */
+#define IPV6_RECVHOPLIMIT			34	/* int */
+
+#define IPV6_HOPOPTS				35  /* struct ip6_hbh */
+#define IPV6_DSTOPTS				36  /* struct ip6_dest */
+#define IPV6_RTHDR					37  /* struct ip6_rthdr */
+
 #define INADDR_ANY					((in_addr_t)0x00000000)
 #define INADDR_LOOPBACK				((in_addr_t)0x7f000001)
 #define INADDR_BROADCAST			((in_addr_t)0xffffffff)	/* must be masked */
Index: headers/posix/netinet6/in6.h
===================================================================
--- headers/posix/netinet6/in6.h	(revision 37465)
+++ headers/posix/netinet6/in6.h	(working copy)
@@ -42,6 +42,12 @@
 };
 
 
+struct in6_pktinfo {
+	struct in6_addr ipi6_addr;      /* src/dst IPv6 address */
+	unsigned int    ipi6_ifindex;   /* send/recv interface index */
+};
+
+
 /* Non-standard helper defines (same as in FreeBSD, though) */
 #define __IPV6_ADDR_SCOPE_NODELOCAL			0x01
 #define __IPV6_ADDR_SCOPE_INTFACELOCAL		0x01
Index: headers/private/net/net_datalink.h
===================================================================
--- headers/private/net/net_datalink.h	(revision 37465)
+++ headers/private/net/net_datalink.h	(working copy)
@@ -100,6 +100,7 @@
 
 struct net_address_module_info {
 	module_info info;
+	bool has_broadcast_address;
 
 	status_t (*copy_address)(const sockaddr *from, sockaddr **to,
 					bool replaceWithZeros, const sockaddr *mask);
Index: headers/private/net/net_datalink_protocol.h
===================================================================
--- headers/private/net/net_datalink_protocol.h	(revision 37465)
+++ headers/private/net/net_datalink_protocol.h	(working copy)
@@ -24,6 +24,7 @@
 
 	status_t	(*send_data)(net_datalink_protocol *self,
 					net_buffer *buffer);
+	status_t	(*receive_data)(net_buffer *buffer);
 
 	status_t	(*interface_up)(net_datalink_protocol *self);
 	void		(*interface_down)(net_datalink_protocol *self);
Index: headers/private/net/net_buffer.h
===================================================================
--- headers/private/net/net_buffer.h	(revision 37465)
+++ headers/private/net/net_buffer.h	(working copy)
@@ -36,6 +36,7 @@
 	uint32	flags;
 	uint32	size;
 	uint8	protocol;
+	uint8	hoplimit;
 } net_buffer;
 
 struct ancillary_data_container;
